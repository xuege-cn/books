{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:41:25 "},"knowledge/react/":{"url":"knowledge/react/","title":"React","keywords":"","body":"React Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 10:51:30 "},"knowledge/react/theory/":{"url":"knowledge/react/theory/","title":"React原理","keywords":"","body":"React原理 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-20 10:55:49 "},"knowledge/react/theory/1/1.html":{"url":"knowledge/react/theory/1/1.html","title":"React中setState后发生了什么？","keywords":"","body":" 解答 调用setState之后，会经历一下几步： React会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程 经过调和过程，React会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个UI界面 在React得到元素树之后，React会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染 在差异计算算法中，React能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染 setState为什么默认是异步 假如所有setState是同步的，意味着没执行一次setSTate时，都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。 setState什么时候是同步 setTimeout 原生事件 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 11:17:01 "},"knowledge/react/theory/2/1.html":{"url":"knowledge/react/theory/2/1.html","title":"Redux中异步的请求如何处理？","keywords":"","body":" 解答 redux-thunk 第一步：配置redux-thunk： import { createStore, applyMiddleware, compose } from 'redux' import thunk from 'redux-thunk' const enhancer = composeEnhancers(applymiddleware(thunk)) const store = createStore(reducer, enhancer) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 15:56:26 "},"knowledge/react/theory/3/1.html":{"url":"knowledge/react/theory/3/1.html","title":"React组件之间的通信方式","keywords":"","body":" 解答 1. 父组件向自组件通信 - 属性传递 2. 子组件向父组件通信 - 属性方法传递 3. 跨组件通信 - 属性传递，传递层级较深增加复杂度 - 使用context 4. 没有嵌套关系的组件 - 自定义事件通信（发布订阅） - redux等全局状态管理 - 兄弟组件可以通信父组件通信 使用Context跨组件通信 const BatteryContext = createContext() { color => {} } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-07 11:17:24 "},"knowledge/react/theory/4/1.html":{"url":"knowledge/react/theory/4/1.html","title":"React.createElement主要做了什么？","keywords":"","body":" 为什么使用jsx的文件都需要import React？ 因为jsx会被解析为React.createElement，createElement接收三个参数： type：div config：节点属性，诸如className，id，key，ref children 来看一个简单的JSX被babel之后： this.ref = ref} key={1}> Hello World React.createElement('div', { className: '111', id: 'leo', ref: ref => this.ref = ref, key: 1 }, 'Hello World') 如果Hello World是多个复杂节点呢 this.ref = ref} key={1}> Hello World1 Hello World2 React.createElement('div', { className: '111', id: 'leo', ref: ref => this.ref = ref, key: 1 }, React.createElement('div', null, 'Hello World1'), React.createElement('div', null, 'Hello World2'), ) 从这里看出createElement的第三个参数children其实是个不定参数 createElement的主要流程 从config中获取保留字段key，ref，self， source 除了保留字段，其他属性从config赋值到props。tips：props为何物？const props = {} 处理不定参数children，通过arguments，赋值到props.children 获取type.defaultProps，当props[propName]为undefined时进行赋值 type.defaultProps是什么？ 普通节点是没有defaultProps的，只有组件才会有，如下： class App extends React.Component { render () { return Hello World } } App.defaultProps = { name: 'leo' } createElement功能 createElement其实就是个创建virtual Dom的函数Virtual Dom的结构是怎样的？ { $$typeof: 0xeac7, type: 'div' 或者 App， key: '1', ref: ref => this.ref = ref, props: { className: '111', id: 'leo', name: 'leo', children: [ { $$typeof: 0xeac7, type: 'div', props: { children: ['Hello World'] } } ] } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-12 11:37:19 "},"knowledge/react/theory/5/1.html":{"url":"knowledge/react/theory/5/1.html","title":"React Component","keywords":"","body":" React中PureComponent的实现： // 以下做的都是继承功能，让 PureComponent 继承自 Component function ComponentDummy() {} ComponentDummy.prototype = Component.prototype; function PureComponent(props, context, updater) { this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue; } const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy()); pureComponentPrototype.constructor = PureComponent; Object.assign(pureComponentPrototype, Component.prototype); // 通过这个变量区别下普通的 Component pureComponentPrototype.isPureReactComponent = true; Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-12 14:00:33 "},"knowledge/react/theory/6/1.html":{"url":"knowledge/react/theory/6/1.html","title":"React Ref的实现原理","keywords":"","body":" ref的三种用法 string模式的已被废弃 1. 回调函数模式 ref = { el => this.el = el } 2. createRef this.ref = React.createRef() ref = {this.ref} 3. forwardRef React.forwardRef((props, ref) => ( )) createRef function createRef () { const refObject = { current: null } return refObject } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-12 14:08:59 "},"knowledge/react/theory/7/1.html":{"url":"knowledge/react/theory/7/1.html","title":"React Children的实现细节","keywords":"","body":" React.Children.map的主要功能 三个参数：children，func，context 主要功能：使用上下文context对每个children执行func 返回结果的特殊处理，返回结果是数组，拍平 如何拍平？遍历每一项执行mapIntoWithKeyPrefixInterval 两个问题 React.Children.map的第一个参数children允许哪几种类型？ 为什么执行完回调的结果mappedChild，判断是还要进行mapIntoWithKeyPrefixInternal 解答 React.Children.map 就是ReacChildren.js中的mapChildren函数，主要流程如下： mapChildren函数： 1. 定义result，const result = [] 2. mapIntoKeyPrefixInternal(children, result, null, func, context) 3. 返回result mapIntoKeyPrefixInternal函数： 1. 生成context：getPooledTraverseContext { result: [], keyprefix: '', func: func, context: null, count: 0 } 2. traverseAllChildrenImpl 遍历children执行func 3. 释放context：releaseTraverseContext 3.1 把context下的属性都置为null，count置为0 3.2 把context放入traverseContextPool，上下文池size为10 traverseAllChildrenImpl函数： 1. children为string，number时：表示是文本节点 2. children为object类型，children.$$typeof为REACT_ELEMENT_TYPE，REACT_PORTAL_TYPE，说明是可以渲染的节点 3. 以上四种情况证明children是可渲染的节点，直接执行mapSingleChildIntoContext 4. children是数组，遍历children，对每个元素来一次traverseAllChildrenImpl 5. children是可迭代数据，调用Symbol.iterator，对每个元素来一次traverseAllChildrenImpl 6. children是object，放弃，非法数据警告 mapSingleChildIntoContext函数： 1. 获取数据：const { result, keyPrefix, func, context } = bookKeeping 2. 执行回调：let mappedChild = func.call(context, child, bookKeeping.count++) 3. 判断结果mappedChild是数组，从mapIntoKeyPrefixInternal对每一项再走一遍 4. mappedChild不是数组，result.push(mappedChild) 为什么在执行完func回调拿到mappedChild，还要对其处理 因为React需要对其进行拍平，比如下面这种场景： React.Children.map(this.props.children, child => [child, child]) 这种情况如果Children是[div1, div2]，map之后的结果为[div1, div1, div2, div2] 性能优化点 const POOL_SIZE = 10; const traverseContextPool = []; function getPooledTraverseContext( mapResult, keyPrefix, mapFunction, mapContext, ) { if (traverseContextPool.length) { const traverseContext = traverseContextPool.pop(); traverseContext.result = mapResult; traverseContext.keyPrefix = keyPrefix; traverseContext.func = mapFunction; traverseContext.context = mapContext; traverseContext.count = 0; return traverseContext; } else { return { result: mapResult, keyPrefix: keyPrefix, func: mapFunction, context: mapContext, count: 0, }; } } function releaseTraverseContext(traverseContext) { traverseContext.result = null; traverseContext.keyPrefix = null; traverseContext.func = null; traverseContext.context = null; traverseContext.count = 0; if (traverseContextPool.length 搞一个traverseContextPool池子，存储traverseContext对象，就不用频繁创建一个有很多属性的对象，很消耗性能 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-13 10:50:19 "},"knowledge/react/theory/8/1.html":{"url":"knowledge/react/theory/8/1.html","title":"React Fiber","keywords":"","body":" Fiber出现的背景 Stack reconciler的工作流程很像函数的调用过程。 父组件里调用子组件，可以类比为函数的出递归 对于特别庞大的vDOM树来说，reconciler过程会很长，超过16ms reconciler期间，主线程是被js占用的，因为任何交互，布局，渲染都会停止，给用户卡了的感觉 React在进行组件渲染时，从setState到渲染完成整个过程是同步的 如果渲染的组件比较大，js执行会占据主线程事件比较长，导致react在动画，手势等应用中效果比较差 Fiber实现原理 实现自己的组件调用栈，以链表的形式遍历组件树，可以灵活的暂停，继续和丢弃执行的任务。 Fiber其实是一种数据结构： const fiber = { stateNode, child, sibling, return, } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-13 17:38:44 "},"knowledge/react/theory/9/1.html":{"url":"knowledge/react/theory/9/1.html","title":"React如何自定义实现requestIdleCallback","keywords":"","body":" 为什么React放弃使用原生requestIdleCallback? 了解几个名称：FPS：frame per second，每秒的帧数 帧的几个问题 setTimeout(callback) 和 setInterval(callback) 实现原理 react使用requestAnimationFrame + MessageChannel 实现requestIdleCallback的polyfill版本： let frameDeadline let activeFrameTime = 16 let channel = new MessageChannel() let port = channel.port2 channel.port1.onmessage = () => { const currentTime = performance.now() console.log('当前时间:', currentTime) console.log('当前帧剩余时间:', frameDeadline - currentTime) } const startTime = performance.now() const requestAnimationFrameCircle = () => { requestAnimationFrame(timestamp => { frameDeadline = timestamp + activeFrameTime port.postMessage(undefined) if (performance.now() - startTime Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-31 20:22:13 "},"knowledge/react/theory/10/":{"url":"knowledge/react/theory/10/","title":"hooks实现原理","keywords":"","body":"hooks 原理 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 11:02:45 "},"knowledge/react/theory/10/1/1.html":{"url":"knowledge/react/theory/10/1/1.html","title":"useState实现","keywords":"","body":"useState实现 useState的使用 function App () { const [count, setCount] = React.useState(0); return {count} setCount(count + 1)}>增加 } useState自定义实现 let hookStates = [] let hookIndex = 0 function useState (initialState) { hookStates[hookIndex] = hookStates[hookIndex] || initialState const currentIndex = hookIndex function setState (newState) { hookStates[currentIndex] = newState render() } return [hookStates[hookIndex++], setState] } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 15:36:19 "},"knowledge/react/theory/10/2/1.html":{"url":"knowledge/react/theory/10/2/1.html","title":"useMemo实现","keywords":"","body":"useMemo的实现 useMemo的作用：根据依赖项返回一个记忆值，只有依赖项改变才会触发useMemo回调useMemo的使用 function App () { const [count, setCount] = React.useState(0) const [name, setName] = React.useState('xuqiang') const memoized = React.useMemo(() => { console.log('get memoized value') return name + count }, [name, count]); return setName(e.target.value)} /> setCount(count + 1)}>增加 } useMemo的实现： function useMemo (callback, dependencies) { if (hookStates[hookIndex]) { const [memoizedVal, oldDependencies] = hookStates[hookIndex] const isDependencySame = dependencies.every((dependency, idx) => dependency === oldDependencies[idx]) if (isDependencySame) { hookIndex++ return memoizedVal } else { const memoizedVal = callback() hookStates[hookIndex++] = [memoizedVal, dependencies] return memoizedVal } } else { const memoizedVal = callback() hookStates[hookIndex++] = [memoizedVal, dependencies] return memoizedVal } } 这里会有个问题是：hookIndex自增之后，每次hookStates[hookIndex]应该都是undefined这里是个误区：useMemo只会进一次，hookStates和hookIndex只是保存了当前组件中的各个hook，如果点击等导致组件被重新渲染，那么得保证hookIndex被重置 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 17:14:18 "},"knowledge/react/theory/10/3/1.html":{"url":"knowledge/react/theory/10/3/1.html","title":"useCallback实现","keywords":"","body":"useCallback实现 useCallback的使用：函数句柄的改变会导致组件重新渲染，useCallback可以使句柄保持不变，结合React.memo可以避免自组件不必要的渲染 function Child (props) { console.log('Child init') return Submit } Child = React.memo(Child) function App () { const [count, setCount] = React.useState(0) const [name, setName] = React.useState('xuqiang') const onButtonClick = React.useCallback(() => { console.log('callback is executed') }, [name]) return setName(e.target.value)} /> setCount(count + 1)}>增加 } useCallback自定义实现 function useCallback (callback, dependencies) { if (hookStates[hookIndex]) { const [oldCallback, oldDependencies] = hookStates[hookIndex] const isDependencySame = dependencies.every((dependency, idx) => dependency === oldDependencies[idx]) if (isDependencySame) { hookIndex++ return oldCallback } else { hookStates[hookIndex++] = [callback, dependencies] return callback } } else { hookStates[hookIndex++] = [callback, dependencies] return callback } } useCallback的实现和useMemo的实现差不多 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 17:17:17 "},"knowledge/react/theory/10/4/1.html":{"url":"knowledge/react/theory/10/4/1.html","title":"useEffect实现","keywords":"","body":"useEffect实现 useEffect的使用 function App () { const [count, setCount] = React.useState(0) const [name, setName] = React.useState('xuqiang') React.useEffect(() => { console.log('effect executed') }, [name, count]) return setName(e.target.value)} /> setCount(count + 1)}>增加 } useEffect的执行时机： componentDidMount componentDidUpdate useEffect的实现： function useEffect (callback, dependencies) { if (hookStates[hookIndex]) { const oldDependencies = hookStates[hookIndex] const isDependencySame = dependencies.every((dependency, idx) => dependency === oldDependencies[idx]) if (isDependencySame) { hookIndex++ } else { hookStates[hookIndex++] = dependencies callback() } } else { hookStates[hookIndex++] = dependencies callback() } } useEffect的实现跟useMemo很相似 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 17:33:06 "},"knowledge/react/theory/10/5/1.html":{"url":"knowledge/react/theory/10/5/1.html","title":"React.memo的实现","keywords":"","body":"React.memo的实现 React.memo的作用：props改变了触发渲染，props未变，子组件不会重新渲染 React.memo = innerComponent => { return class extends React.PureComponent { render () { return } } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 17:39:05 "},"knowledge/react/theory/10/6/1.html":{"url":"knowledge/react/theory/10/6/1.html","title":"useContext实现","keywords":"","body":"useContext实现 useContext的使用：非直接组件数据传输 const Context = React.createContext() function Child () { const context = React.useContext(Context) return {context.name} } function App () { const [count, setCount] = React.useState(0) const [name, setName] = React.useState('xuqiang') return setName(e.target.value)} /> setCount(count + 1)}>增加 } useContext的实现： function useContext (Context) { return Context._currentValue } React.createContext返回的Context的结构： $$typeof: Symbol(react.context), _currentValue: undefined Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 17:48:31 "},"knowledge/html/":{"url":"knowledge/html/","title":"Html","keywords":"","body":"Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:45:28 "},"knowledge/html/1/1.html":{"url":"knowledge/html/1/1.html","title":"Html布局元素的分类有哪些","keywords":"","body":"Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-07 11:16:43 "},"knowledge/html/2/1.html":{"url":"knowledge/html/2/1.html","title":"资源预加载的处理方式","keywords":"","body":" preload link rel href as实现文件的预加载 as的取值： audio：音频文件 document：嵌入frame或iframe内部的文档 embed：嵌入embed元素内部的资源 fetch：将通过fetch或ajax请求获取的资源，如json文件或ArrayBuffer font：字体文件 image：图片文件 object：嵌入embed元素内的文件 script：js文件 style：样式表 worker：一个js的web worker或shared worker video：视频文件 prefetch rel为prefetch时，表示下载资源为下一个导航/页面使用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-07 11:38:24 "},"knowledge/html/3/1.html":{"url":"knowledge/html/3/1.html","title":"FP, FCP, TTI, FMP","keywords":"","body":" 名词解释 FP：first paint FCP：first content paint TTI：time to interactive FMP：first meaningful paint LCP：largest contentful paint FID：first input delay 跟踪FP/FCP const observer = new PerformanceObserver(list => { for (const entry of list.getEntries()) { const metricName = entry.name const time = Math.round(entry.startTime + entry.duration) console.log('entry: ', entry) } }) observer.observe({ entryTypes: ['paint'] }) 追踪LCP 最大内容绘制：浏览器自己判断 const observer = new PerformanceObserver(list => { for (let entry of list.getEntries()) { console.log(entry) } }) observer.observe({ type: 'largest-contentful-paint' }) 追踪FMP el.setAttribute('elementimg', 'meaningful') const observer = new PerformanceObserver(list => { for (let entry of list.getEntries()) { console.log(entry) } }) observer.observe({ type: 'element' }) FMP的entry结果是： entryType: \"element\" identifier: \"meaning\" 跟踪TTI google chrome有个库：tti-polyfill，可以借助这个库收集tti 跟踪FID：第一次输入延迟 const firstHiddenTime = document.visibilityState === 'hidden' ? 0 : Infinity document.addEventListener('visibilitychange', event => { firstHiddenTime = Math.min(firstHiddenTime, event.timeStamp) }) const observer = new PerformanceObserver(list => { for (let entry of list.getEntries()) { if (entry.startTime 跟踪长任务 entryTypes: ['longtask'] 跟踪输入延迟 btn.addEventListener('click', event => { const lag = performance.now() - event.timeStamp; if (lag > 100) { console.log('输入延迟') } }) 计算用户的逗留时长 使用document的visibilitychange事件来触发浏览器标签页隐藏和显示的回调 paint可以获取两个指标 name: 'first-paint' name: 'first-contentful-paint' entry对象中有entryType, startTime, duration, name四个属性 entryType有哪些 frame，navigation resource mark measure paint navigator.sendBeacon存在的意义 网页在unload或者beforeunload之前想要收集些数据：比如逗留时间等使用xhr发送数据的问题： 同步请求会导致延迟网页关闭 异步请求会导致网页关闭有些请求未发出 ``` // 同步请求导致网页关闭延迟 const xhr = new XMLHttpRequest() xhr.send('POST', url, false) // navigator.sendBeacon就是为解决这种场景而生 navigator.sendBeacon('/log', analyticsData) ``` Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-10 14:25:16 "},"knowledge/html/4/1.html":{"url":"knowledge/html/4/1.html","title":"HTML标签合法性及相关操作","keywords":"","body":" 统计 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-16 17:03:53 "}}