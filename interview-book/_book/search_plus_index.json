{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"interview/":{"url":"interview/","title":"每日一题","keywords":"","body":"每日一题 一天一题练习 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:33:17 "},"interview/vue/":{"url":"interview/vue/","title":"vue","keywords":"","body":"这里是vue专题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:11:09 "},"interview/vue/1/1.html":{"url":"interview/vue/1/1.html","title":"父组件监听子组件的生命周期","keywords":"","body":" 解法1: @hook @hook:搭配任意钩子函数，会在子组件触发相应生命周期钩子函数时回调父组件这个函数 解法2: $emit 这种方式比较蠢，而且是需要劳动力堆积的 mounted () { this.$emit('mounted') } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:36:45 "},"interview/vue/2/1.html":{"url":"interview/vue/2/1.html","title":"$set解决新增属性不能相应的问题","keywords":"","body":" 解答： 是因为Vue在实例化的过程中就需要对data中的数据使用defineProperty方法来定义存取器实现的响应式。而直接新增属性因为仍是值属性，所以是不能实现响应式的 源码实现 const isValidArrayIndex = index => { return index > 0 && Math.floor(index) === index && isFinite(index) } exprt function set (target, key, val) { if (Array.isArray(target) && isValidArrayIndex(key)) { target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } if (key in target && !(key in target.prototype)) { target[key] = val return val } const __ob__ = target.__ob__ if (!__ob__) { target[key] = val return val } else { defineReactive(__ob__.value, key, val) __ob__.dep.notify() return val } } set分为四步骤： 判断是否为数组，以及索引是否合法 Array.isArray判断target是否为数组 索引是否合法：index > 0 && Math.floor(index) === index && isFinite(index) 数组可能不够长，先把数组扩充下：target.length = Math.max(target.length, key) 通过splice往数组中添加：target.splice(key, 1, val) 判断target对象下是否已经该属性key 存在的话就是修改操作，直接target[key] = val，通过setter存取器触发notify target是否已被响应式 否：不管响应式，target[key] = val完事 已设置响应式，defineReactive(ob.value, key, val), ob.dep.notify()触发更新 defineProperty的缺点 从这个问题可以看出：defineProperty实现响应式，需要在vue实例化时对所有属性进行重定义，不然的话就不能实现响应式有点类似事件绑定时，对单个节点 Proxy的使用 let obj = { a: 1, b: 2 } let obj1 = new Proxy(obj, { get (obj, prop) { console.log(`正在获取属性：${prop}，值为：${obj[prop]}`) return obj[prop] } }) obj1.a obj1.b Proxy类似事件委托，把属性访问委托到另一个对象上，可是不具体关心是什么属性，所以在Vue实例化阶段减少了对data下所有属性进行defineProperty定义存取器 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:21:01 "},"interview/vue/3/1.html":{"url":"interview/vue/3/1.html","title":"自定义指令实现图片懒加载","keywords":"","body":" 图片懒加载的三种实现方式 scroll事件 + getBoundingClientRect const imgs = document.getElementsByTagName('img') const body = document.body function imgLoad () { for (let img of imgs) { const clientRect = img.getBoundingClientRect() if (clientRect.bottom { timer = null func.apply(this, args) }, wait) } } } document.addEventListener('scroll', throttle(imgLoad, 0)) imgLoad() InsectionObserver const imgs = document.getElementsByTagName('img') const intersectionObserver = new IntersectionObserver(function(entries) { for (let entry of entries) { if (entry.intersectionRatio > 0) { const target = entry.target target.style.height = 'auto' target.src = target.getAttribute('data-src') intersectionObserver.unobserve(target) } } }) for (let img of imgs) { intersectionObserver.observe(img) } 浏览器原生支持loading=\"lazy\" Vue自定义指令 + 图片懒加载 模版： const intersectionObserver = new IntersectionObserver(function(entries) { for (let entry of entries) { if (entry.intersectionRatio > 0) { const target = entry.target target.style.height = 'auto' target.src = target.getAttribute('data-src') intersectionObserver.unobserve(target) } } }) directives: { lazy: { inserted: function (el) { intersectionObserver.observe(el) } } } directive的钩子函数 bind：指令第一次绑定到元素时调用 inserted：元素插入父节点时调用 update：所在组件VNode更新时调用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-03 15:50:13 "},"interview/js/":{"url":"interview/js/","title":"js","keywords":"","body":"js高频题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-02 15:11:57 "},"interview/js/1/1.html":{"url":"interview/js/1/1.html","title":"写一个深拷贝，考虑 正则，Date这种类型的数据","keywords":"","body":" 解答 方案一：JSON.parse(JSON.stringify(source)) 缺点： undefined, 函数，symbol值，在序列化过程中会被忽略 不能处理Bigint类型的数据和循环引用，会报错 Map，Set，RegExp类型的数据，会引用丢失，变成空值 Date类型的数据会被当作字符串处理 NaN，Infinity，null都会被当作null Map/Set/WeakMap/WeakSet 仅会序列化可枚举的数据 方案二：判断类型为object 判断参数类型为object后，复制键/值到目标对象，否则返回源对象 function deepClone (source) { if (typeof source === 'object') { const result = Array.isArray(source) ? [] : {} for (let key in source) { const prop = source[key] if (typeof prop === 'object') { result[key] = deepClone(prop) } else { result[key] = prop } } return result } return source } 方案三：Reflect代理法 Reflect.ownKeys可以获取不可枚举属性，Object.keys只能列举可枚举属性 function deepClone (obj) { if (typeof obj === 'object') { let cloneObj = Array.isArray(obj) ? [] : {} Reflect.ownKeys(cloneObj).forEach(key => { const prop = obj[key] cloneObj[key] = typeof prop === 'object' ? deepClone(prop) : obj[key] }) return cloneObj } return obj } 方案四：终极方案 方案二和方案三的思想都是遍历属性，然后重新赋值，但是仍然解决不了Map，Set，RegExp，Date之类的问题深拷贝的几个特殊类型： Date Map Set RegExp Function Symbol 日期拷贝 let source = new Date() let copy = new date.constructor(source) Map拷贝 let source = new Map([['name', 'xuqiang'], ['age', 29]]) let copy = new Map() source.forEach((val, key) => { copy.set(key, val) }) Set拷贝 let source = new Set([1, 2, 3, 4, 5]) let copy = new Set() source.forEach(item => { copy.add(item) }) RegExp拷贝 let source = /a/ let copy = new source.constructor(source.source, /\\w*$/.exec(source)) copy.lastIndex = source.lastIndex Symbol拷贝 let source = { [Symbol('name')]: Symbol('xuqiang') } let copy = {} let symbols = Object.getOwnPropertySymbols(source) for (let symbol of symbols) { copy[symbol] = source[symbol] } 函数的拷贝 函数转字符串 function func (name, age) { console.log(name, age) } const funcString = func.toString() 字符串转函数 // 方案一: const func = eval(`(${funcString})`) // 方案二： const func = new Function('return ' + funcString)() 匹配参数和函数体 匹配参数 const paramReg = /(?匹配函数体 const bodyReg = /(?函数拷贝的两种方法 eval const funcString = func.toString() const funcCopy = eval(`(${funcString})`) new Function ``` const paramReg = /(?(?=)\\s[{|=>])/ const bodyReg = /(? const param = paramReg.exec(funcString) const bodyReg = bodyReg.exec(funcString) if (body) { if (param) { const params = param[0].split(',') new Function (...params, body[0]) } else { new Function (body[0]) } } ``` Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-02 20:25:50 "},"interview/js/2/1.html":{"url":"interview/js/2/1.html","title":"有1000个dom，需要更新其中的100个，如何操作才能减少dom的操作？","keywords":"","body":" 解答 性能瓶颈： DOM访问 DOM修改导致重绘和重排 缓存DOM对象 将DOM对象缓存。避免重复查询 文档片段 在文档片段上添加dom节点，不会影响到真是的dom结构可以利用这一点将需要修改的dom一并修改完，保存至文档片段中，避免频繁修改dom而导致的重排跟重绘的过程 如果要对元素进行复杂的操作（删减，添加子节点），应将此元素先移除或cloneNode，操作完成之后再替换原来节点 使用innerHtml代替高频的appendChild 最优的layout方案 批量读，一次性写。把任何导致重绘的操作放入requestAnimationFrame 虚拟DOM 将dom抽象为虚拟dom，在dom变化时先对虚拟dom进行操作，通过dom diff将虚拟dom和原虚拟dom做对比，最终批量修改真实dom结构 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-11 17:50:35 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:41:25 "},"knowledge/react/":{"url":"knowledge/react/","title":"React","keywords":"","body":"React Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 10:51:30 "},"knowledge/react/theory/":{"url":"knowledge/react/theory/","title":"React原理","keywords":"","body":"React原理 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-20 10:55:49 "},"knowledge/react/theory/1/1.html":{"url":"knowledge/react/theory/1/1.html","title":"React中setState后发生了什么？","keywords":"","body":" 解答 调用setState之后，会经历一下几步： React会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程 经过调和过程，React会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个UI界面 在React得到元素树之后，React会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染 在差异计算算法中，React能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染 setState为什么默认是异步 假如所有setState是同步的，意味着没执行一次setSTate时，都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。 setState什么时候是同步 setTimeout 原生事件 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 11:17:01 "},"knowledge/react/theory/2/1.html":{"url":"knowledge/react/theory/2/1.html","title":"Redux中异步的请求如何处理？","keywords":"","body":" 解答 redux-thunk 第一步：配置redux-thunk： import { createStore, applyMiddleware, compose } from 'redux' import thunk from 'redux-thunk' const enhancer = composeEnhancers(applymiddleware(thunk)) const store = createStore(reducer, enhancer) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 15:56:26 "},"knowledge/react/theory/3/1.html":{"url":"knowledge/react/theory/3/1.html","title":"React组件之间的通信方式","keywords":"","body":" 解答 1. 父组件向自组件通信 - 属性传递 2. 子组件向父组件通信 - 属性方法传递 3. 跨组件通信 - 属性传递，传递层级较深增加复杂度 - 使用context 4. 没有嵌套关系的组件 - 自定义事件通信（发布订阅） - redux等全局状态管理 - 兄弟组件可以通信父组件通信 使用Context跨组件通信 const BatteryContext = createContext() { color => {} } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-07 11:17:24 "},"knowledge/react/theory/4/1.html":{"url":"knowledge/react/theory/4/1.html","title":"React.createElement主要做了什么？","keywords":"","body":" 为什么使用jsx的文件都需要import React？ 因为jsx会被解析为React.createElement，createElement接收三个参数： type：div config：节点属性，诸如className，id，key，ref children 来看一个简单的JSX被babel之后： this.ref = ref} key={1}> Hello World React.createElement('div', { className: '111', id: 'leo', ref: ref => this.ref = ref, key: 1 }, 'Hello World') 如果Hello World是多个复杂节点呢 this.ref = ref} key={1}> Hello World1 Hello World2 React.createElement('div', { className: '111', id: 'leo', ref: ref => this.ref = ref, key: 1 }, React.createElement('div', null, 'Hello World1'), React.createElement('div', null, 'Hello World2'), ) 从这里看出createElement的第三个参数children其实是个不定参数 createElement的主要流程 从config中获取保留字段key，ref，self， source 除了保留字段，其他属性从config赋值到props。tips：props为何物？const props = {} 处理不定参数children，通过arguments，赋值到props.children 获取type.defaultProps，当props[propName]为undefined时进行赋值 type.defaultProps是什么？ 普通节点是没有defaultProps的，只有组件才会有，如下： class App extends React.Component { render () { return Hello World } } App.defaultProps = { name: 'leo' } createElement功能 createElement其实就是个创建virtual Dom的函数Virtual Dom的结构是怎样的？ { $$typeof: 0xeac7, type: 'div' 或者 App， key: '1', ref: ref => this.ref = ref, props: { className: '111', id: 'leo', name: 'leo', children: [ { $$typeof: 0xeac7, type: 'div', props: { children: ['Hello World'] } } ] } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-12 11:37:19 "},"knowledge/react/theory/5/1.html":{"url":"knowledge/react/theory/5/1.html","title":"React Component","keywords":"","body":" React中PureComponent的实现： // 以下做的都是继承功能，让 PureComponent 继承自 Component function ComponentDummy() {} ComponentDummy.prototype = Component.prototype; function PureComponent(props, context, updater) { this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue; } const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy()); pureComponentPrototype.constructor = PureComponent; Object.assign(pureComponentPrototype, Component.prototype); // 通过这个变量区别下普通的 Component pureComponentPrototype.isPureReactComponent = true; Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-12 14:00:33 "},"knowledge/react/theory/6/1.html":{"url":"knowledge/react/theory/6/1.html","title":"React Ref的实现原理","keywords":"","body":" ref的三种用法 string模式的已被废弃 1. 回调函数模式 ref = { el => this.el = el } 2. createRef this.ref = React.createRef() ref = {this.ref} 3. forwardRef React.forwardRef((props, ref) => ( )) createRef function createRef () { const refObject = { current: null } return refObject } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-12 14:08:59 "},"knowledge/react/theory/7/1.html":{"url":"knowledge/react/theory/7/1.html","title":"React Children的实现细节","keywords":"","body":" React.Children.map的主要功能 三个参数：children，func，context 主要功能：使用上下文context对每个children执行func 返回结果的特殊处理，返回结果是数组，拍平 如何拍平？遍历每一项执行mapIntoWithKeyPrefixInterval 两个问题 React.Children.map的第一个参数children允许哪几种类型？ 为什么执行完回调的结果mappedChild，判断是还要进行mapIntoWithKeyPrefixInternal 解答 React.Children.map 就是ReacChildren.js中的mapChildren函数，主要流程如下： mapChildren函数： 1. 定义result，const result = [] 2. mapIntoKeyPrefixInternal(children, result, null, func, context) 3. 返回result mapIntoKeyPrefixInternal函数： 1. 生成context：getPooledTraverseContext { result: [], keyprefix: '', func: func, context: null, count: 0 } 2. traverseAllChildrenImpl 遍历children执行func 3. 释放context：releaseTraverseContext 3.1 把context下的属性都置为null，count置为0 3.2 把context放入traverseContextPool，上下文池size为10 traverseAllChildrenImpl函数： 1. children为string，number时：表示是文本节点 2. children为object类型，children.$$typeof为REACT_ELEMENT_TYPE，REACT_PORTAL_TYPE，说明是可以渲染的节点 3. 以上四种情况证明children是可渲染的节点，直接执行mapSingleChildIntoContext 4. children是数组，遍历children，对每个元素来一次traverseAllChildrenImpl 5. children是可迭代数据，调用Symbol.iterator，对每个元素来一次traverseAllChildrenImpl 6. children是object，放弃，非法数据警告 mapSingleChildIntoContext函数： 1. 获取数据：const { result, keyPrefix, func, context } = bookKeeping 2. 执行回调：let mappedChild = func.call(context, child, bookKeeping.count++) 3. 判断结果mappedChild是数组，从mapIntoKeyPrefixInternal对每一项再走一遍 4. mappedChild不是数组，result.push(mappedChild) 为什么在执行完func回调拿到mappedChild，还要对其处理 因为React需要对其进行拍平，比如下面这种场景： React.Children.map(this.props.children, child => [child, child]) 这种情况如果Children是[div1, div2]，map之后的结果为[div1, div1, div2, div2] 性能优化点 const POOL_SIZE = 10; const traverseContextPool = []; function getPooledTraverseContext( mapResult, keyPrefix, mapFunction, mapContext, ) { if (traverseContextPool.length) { const traverseContext = traverseContextPool.pop(); traverseContext.result = mapResult; traverseContext.keyPrefix = keyPrefix; traverseContext.func = mapFunction; traverseContext.context = mapContext; traverseContext.count = 0; return traverseContext; } else { return { result: mapResult, keyPrefix: keyPrefix, func: mapFunction, context: mapContext, count: 0, }; } } function releaseTraverseContext(traverseContext) { traverseContext.result = null; traverseContext.keyPrefix = null; traverseContext.func = null; traverseContext.context = null; traverseContext.count = 0; if (traverseContextPool.length 搞一个traverseContextPool池子，存储traverseContext对象，就不用频繁创建一个有很多属性的对象，很消耗性能 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-13 10:50:19 "},"knowledge/react/theory/8/1.html":{"url":"knowledge/react/theory/8/1.html","title":"React Fiber","keywords":"","body":" Fiber出现的背景 Stack reconciler的工作流程很像函数的调用过程。 父组件里调用子组件，可以类比为函数的出递归 对于特别庞大的vDOM树来说，reconciler过程会很长，超过16ms reconciler期间，主线程是被js占用的，因为任何交互，布局，渲染都会停止，给用户卡了的感觉 React在进行组件渲染时，从setState到渲染完成整个过程是同步的 如果渲染的组件比较大，js执行会占据主线程事件比较长，导致react在动画，手势等应用中效果比较差 Fiber实现原理 实现自己的组件调用栈，以链表的形式遍历组件树，可以灵活的暂停，继续和丢弃执行的任务。 Fiber其实是一种数据结构： const fiber = { stateNode, child, sibling, return, } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-13 17:38:44 "},"knowledge/react/theory/9/1.html":{"url":"knowledge/react/theory/9/1.html","title":"React如何自定义实现requestIdleCallback","keywords":"","body":" 为什么React放弃使用原生requestIdleCallback? 了解几个名称：FPS：frame per second，每秒的帧数 帧的几个问题 setTimeout(callback) 和 setInterval(callback) 实现原理 react使用requestAnimationFrame + MessageChannel 实现requestIdleCallback的polyfill版本： let frameDeadline let activeFrameTime = 16 let channel = new MessageChannel() let port = channel.port2 channel.port1.onmessage = () => { const currentTime = performance.now() console.log('当前时间:', currentTime) console.log('当前帧剩余时间:', frameDeadline - currentTime) } const startTime = performance.now() const requestAnimationFrameCircle = () => { requestAnimationFrame(timestamp => { frameDeadline = timestamp + activeFrameTime port.postMessage(undefined) if (performance.now() - startTime Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-31 20:22:13 "},"knowledge/react/theory/10/1.html":{"url":"knowledge/react/theory/10/1.html","title":"hooks实现原理","keywords":"","body":"Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 11:02:17 "},"knowledge/react/theory/10/":{"url":"knowledge/react/theory/10/","title":"hooks实现原理","keywords":"","body":"hooks 原理 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 11:02:45 "},"knowledge/react/theory/10/1/1.html":{"url":"knowledge/react/theory/10/1/1.html","title":"useState实现","keywords":"","body":"useState实现 useState的使用 function App () { const [count, setCount] = React.useState(0); return {count} setCount(count + 1)}>增加 } useState自定义实现 let hookStates = [] let hookIndex = 0 function useState (initialState) { hookStates[hookIndex] = hookStates[hookIndex] || initialState const currentIndex = hookIndex function setState (newState) { hookStates[currentIndex] = newState render() } return [hookStates[hookIndex++], setState] } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 15:36:19 "},"knowledge/react/theory/10/2/1.html":{"url":"knowledge/react/theory/10/2/1.html","title":"useMemo实现","keywords":"","body":"useMemo的实现 useMemo的作用：根据依赖项返回一个记忆值，只有依赖项改变才会触发useMemo回调useMemo的使用 function App () { const [count, setCount] = React.useState(0) const [name, setName] = React.useState('xuqiang') const memoized = React.useMemo(() => { console.log('get memoized value') return name + count }, [name, count]); return setName(e.target.value)} /> setCount(count + 1)}>增加 } useMemo的实现： function useMemo (callback, dependencies) { if (hookStates[hookIndex]) { const [memoizedVal, oldDependencies] = hookStates[hookIndex] const isDependencySame = dependencies.every((dependency, idx) => dependency === oldDependencies[idx]) if (isDependencySame) { hookIndex++ return memoizedVal } else { const memoizedVal = callback() hookStates[hookIndex++] = [memoizedVal, dependencies] return memoizedVal } } else { const memoizedVal = callback() hookStates[hookIndex++] = [memoizedVal, dependencies] return memoizedVal } } 这里会有个问题是：hookIndex自增之后，每次hookStates[hookIndex]应该都是undefined这里是个误区：useMemo只会进一次，hookStates和hookIndex只是保存了当前组件中的各个hook，如果点击等导致组件被重新渲染，那么得保证hookIndex被重置 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 17:14:18 "},"knowledge/react/theory/10/3/1.html":{"url":"knowledge/react/theory/10/3/1.html","title":"useCallback实现","keywords":"","body":"useCallback实现 useCallback的使用：函数句柄的改变会导致组件重新渲染，useCallback可以使句柄保持不变，结合React.memo可以避免自组件不必要的渲染 function Child (props) { console.log('Child init') return Submit } Child = React.memo(Child) function App () { const [count, setCount] = React.useState(0) const [name, setName] = React.useState('xuqiang') const onButtonClick = React.useCallback(() => { console.log('callback is executed') }, [name]) return setName(e.target.value)} /> setCount(count + 1)}>增加 } useCallback自定义实现 function useCallback (callback, dependencies) { if (hookStates[hookIndex]) { const [oldCallback, oldDependencies] = hookStates[hookIndex] const isDependencySame = dependencies.every((dependency, idx) => dependency === oldDependencies[idx]) if (isDependencySame) { hookIndex++ return oldCallback } else { hookStates[hookIndex++] = [callback, dependencies] return callback } } else { hookStates[hookIndex++] = [callback, dependencies] return callback } } useCallback的实现和useMemo的实现差不多 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 17:17:17 "},"knowledge/react/theory/10/4/1.html":{"url":"knowledge/react/theory/10/4/1.html","title":"useEffect实现","keywords":"","body":"useEffect实现 useEffect的使用 function App () { const [count, setCount] = React.useState(0) const [name, setName] = React.useState('xuqiang') React.useEffect(() => { console.log('effect executed') }, [name, count]) return setName(e.target.value)} /> setCount(count + 1)}>增加 } useEffect的执行时机： componentDidMount componentDidUpdate useEffect的实现： function useEffect (callback, dependencies) { if (hookStates[hookIndex]) { const oldDependencies = hookStates[hookIndex] const isDependencySame = dependencies.every((dependency, idx) => dependency === oldDependencies[idx]) if (isDependencySame) { hookIndex++ } else { hookStates[hookIndex++] = dependencies callback() } } else { hookStates[hookIndex++] = dependencies callback() } } useEffect的实现跟useMemo很相似 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 17:33:06 "},"knowledge/react/theory/10/5/1.html":{"url":"knowledge/react/theory/10/5/1.html","title":"React.memo的实现","keywords":"","body":"React.memo的实现 React.memo的作用：props改变了触发渲染，props未变，子组件不会重新渲染 React.memo = innerComponent => { return class extends React.PureComponent { render () { return } } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 17:39:05 "},"knowledge/react/theory/10/6/1.html":{"url":"knowledge/react/theory/10/6/1.html","title":"useContext实现","keywords":"","body":"useContext实现 useContext的使用：非直接组件数据传输 const Context = React.createContext() function Child () { const context = React.useContext(Context) return {context.name} } function App () { const [count, setCount] = React.useState(0) const [name, setName] = React.useState('xuqiang') return setName(e.target.value)} /> setCount(count + 1)}>增加 } useContext的实现： function useContext (Context) { return Context._currentValue } React.createContext返回的Context的结构： $$typeof: Symbol(react.context), _currentValue: undefined Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-14 17:48:31 "}}