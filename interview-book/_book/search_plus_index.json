{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"interview/":{"url":"interview/","title":"每日一题","keywords":"","body":"每日一题 一天一题练习 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:33:17 "},"interview/vue/":{"url":"interview/vue/","title":"vue","keywords":"","body":"这里是vue专题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:11:09 "},"interview/vue/1/1.html":{"url":"interview/vue/1/1.html","title":"父组件监听子组件的生命周期","keywords":"","body":" 解法1: @hook @hook:搭配任意钩子函数，会在子组件触发相应生命周期钩子函数时回调父组件这个函数 解法2: $emit 这种方式比较蠢，而且是需要劳动力堆积的 mounted () { this.$emit('mounted') } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:36:45 "},"interview/vue/2/1.html":{"url":"interview/vue/2/1.html","title":"$set解决新增属性不能相应的问题","keywords":"","body":" 解答： 是因为Vue在实例化的过程中就需要对data中的数据使用defineProperty方法来定义存取器实现的响应式。而直接新增属性因为仍是值属性，所以是不能实现响应式的 源码实现 const isValidArrayIndex = index => { return index > 0 && Math.floor(index) === index && isFinite(index) } exprt function set (target, key, val) { if (Array.isArray(target) && isValidArrayIndex(key)) { target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } if (key in target && !(key in target.prototype)) { target[key] = val return val } const __ob__ = target.__ob__ if (!__ob__) { target[key] = val return val } else { defineReactive(__ob__.value, key, val) __ob__.dep.notify() return val } } set分为四步骤： 判断是否为数组，以及索引是否合法 Array.isArray判断target是否为数组 索引是否合法：index > 0 && Math.floor(index) === index && isFinite(index) 数组可能不够长，先把数组扩充下：target.length = Math.max(target.length, key) 通过splice往数组中添加：target.splice(key, 1, val) 判断target对象下是否已经该属性key 存在的话就是修改操作，直接target[key] = val，通过setter存取器触发notify target是否已被响应式 否：不管响应式，target[key] = val完事 已设置响应式，defineReactive(ob.value, key, val), ob.dep.notify()触发更新 defineProperty的缺点 从这个问题可以看出：defineProperty实现响应式，需要在vue实例化时对所有属性进行重定义，不然的话就不能实现响应式有点类似事件绑定时，对单个节点 Proxy的使用 let obj = { a: 1, b: 2 } let obj1 = new Proxy(obj, { get (obj, prop) { console.log(`正在获取属性：${prop}，值为：${obj[prop]}`) return obj[prop] } }) obj1.a obj1.b Proxy类似事件委托，把属性访问委托到另一个对象上，可是不具体关心是什么属性，所以在Vue实例化阶段减少了对data下所有属性进行defineProperty定义存取器 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:21:01 "},"interview/vue/3/1.html":{"url":"interview/vue/3/1.html","title":"自定义指令实现图片懒加载","keywords":"","body":" 图片懒加载的三种实现方式 scroll事件 + getBoundingClientRect const imgs = document.getElementsByTagName('img') const body = document.body function imgLoad () { for (let img of imgs) { const clientRect = img.getBoundingClientRect() if (clientRect.bottom { timer = null func.apply(this, args) }, wait) } } } document.addEventListener('scroll', throttle(imgLoad, 0)) imgLoad() InsectionObserver const imgs = document.getElementsByTagName('img') const intersectionObserver = new IntersectionObserver(function(entries) { for (let entry of entries) { if (entry.intersectionRatio > 0) { const target = entry.target target.style.height = 'auto' target.src = target.getAttribute('data-src') intersectionObserver.unobserve(target) } } }) for (let img of imgs) { intersectionObserver.observe(img) } 浏览器原生支持loading=\"lazy\" Vue自定义指令 + 图片懒加载 模版： const intersectionObserver = new IntersectionObserver(function(entries) { for (let entry of entries) { if (entry.intersectionRatio > 0) { const target = entry.target target.style.height = 'auto' target.src = target.getAttribute('data-src') intersectionObserver.unobserve(target) } } }) directives: { lazy: { inserted: function (el) { intersectionObserver.observe(el) } } } directive的钩子函数 bind：指令第一次绑定到元素时调用 inserted：元素插入父节点时调用 update：所在组件VNode更新时调用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-03 15:50:13 "},"interview/vue/4/1.html":{"url":"interview/vue/4/1.html","title":"keep-alive","keywords":"","body":"keep-alive如何实现组件缓存 keep-alive 介绍 keep-alive 是 vue 的一个内置组件，主要接收三个参数，include，exclude 和 max，include 和 exclude 可以接收 String，RegExp， Array 三种类型数据，用以匹配组件 Name，max 表示最多保存实例个数，若超过这个数字，已缓存组件中最久没有被访问的实例会被销毁掉 keep-alive的使用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 14:29:40 "},"interview/vue/5/1.html":{"url":"interview/vue/5/1.html","title":"next-tick","keywords":"","body":"next-tick next-tick的作用 next-tick 就是丢一个任务进去，在空闲的时候去执行 next-tick的自定义实现 let timerFunc; let callbacks = []; function nextTick (cb, ctx) { const callback = () => { cb.call(ctx); } callbacks.push(callback); timerFunc(); } if (typeof Promise !== 'undefined') { const p = Promise.resolve(); timerFunc = () => { p.then(flushCallbacks); } } else if (typeof MutationObserver !== 'undefined') { let count = 1; const mo = new MutationObserver(flushCallbacks); const textNode = document.createTextNode(); mo.observe(textNode, { characterData: true }); timerFunc = () => { count = 1 - count; textNode.data = String(count); } } else if (typeof setImmediate === 'function') { timerFunc = setImmediate(flushCallbacks); } else if (typeof setTimeout === 'function') { timerFunc = setTimeout(flushCallbacks, 0); } function flushCallbacks () { let cbs = callbacks.slice(0); for (let cb of cbs) { cb(); } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 15:33:52 "},"interview/vue/6/1.html":{"url":"interview/vue/6/1.html","title":"vue如何做编译时优化AOT？","keywords":"","body":" JIT 即时编译：just-in-time compile React 的模版中允许写 js 代码，然而 vue 的模版中不允许写 js 代码 React 是即时编译，会在执行时把 jsx 编译为 js 代码 Vue 是即时编译兼运行前编译，就看 $options.render 是否存在，存在为运行前编译，反之即时编译 AOT 运行前编译：Ahead-of-time compile Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-22 16:57:59 "},"interview/vue/7/1.html":{"url":"interview/vue/7/1.html","title":"如何给Vue定义全局方法","keywords":"","body":" 解答 Vue.prototype Vue.prototype.call = () => console.log('call') mixin 方式 const mixin = { methods: { call () { console.log('call') } } } Vue.mixin(mixin) Plugin 方式 const plugin = { install (Vue) { Vue.prototype.$call = () => { console.log('call') } } } Vue.use(plugin) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 18:30:17 "},"interview/js/":{"url":"interview/js/","title":"js","keywords":"","body":"js高频题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-02 15:11:57 "},"interview/js/1/1.html":{"url":"interview/js/1/1.html","title":"写一个深拷贝，考虑 正则，Date这种类型的数据","keywords":"","body":" 解答 方案一：JSON.parse(JSON.stringify(source)) 缺点： undefined, 函数，symbol值，在序列化过程中会被忽略 不能处理Bigint类型的数据和循环引用，会报错 Map，Set，RegExp类型的数据，会引用丢失，变成空值 Date类型的数据会被当作字符串处理 NaN，Infinity，null都会被当作null Map/Set/WeakMap/WeakSet 仅会序列化可枚举的数据 方案二：判断类型为object 判断参数类型为object后，复制键/值到目标对象，否则返回源对象 function deepClone (source) { if (typeof source === 'object') { const result = Array.isArray(source) ? [] : {} for (let key in source) { const prop = source[key] if (typeof prop === 'object') { result[key] = deepClone(prop) } else { result[key] = prop } } return result } return source } 方案三：Reflect代理法 Reflect.ownKeys可以获取不可枚举属性，Object.keys只能列举可枚举属性 function deepClone (obj) { if (typeof obj === 'object') { let cloneObj = Array.isArray(obj) ? [] : {} Reflect.ownKeys(cloneObj).forEach(key => { const prop = obj[key] cloneObj[key] = typeof prop === 'object' ? deepClone(prop) : obj[key] }) return cloneObj } return obj } 方案四：终极方案 方案二和方案三的思想都是遍历属性，然后重新赋值，但是仍然解决不了Map，Set，RegExp，Date之类的问题深拷贝的几个特殊类型： Date Map Set RegExp Function Symbol 日期拷贝 let source = new Date() let copy = new date.constructor(source) Map拷贝 let source = new Map([['name', 'xuqiang'], ['age', 29]]) let copy = new Map() source.forEach((val, key) => { copy.set(key, val) }) Set拷贝 let source = new Set([1, 2, 3, 4, 5]) let copy = new Set() source.forEach(item => { copy.add(item) }) RegExp拷贝 let source = /a/ let copy = new source.constructor(source.source, /\\w*$/.exec(source)) copy.lastIndex = source.lastIndex Symbol拷贝 let source = { [Symbol('name')]: Symbol('xuqiang') } let copy = {} let symbols = Object.getOwnPropertySymbols(source) for (let symbol of symbols) { copy[symbol] = source[symbol] } 函数的拷贝 函数转字符串 function func (name, age) { console.log(name, age) } const funcString = func.toString() 字符串转函数 // 方案一: const func = eval(`(${funcString})`) // 方案二： const func = new Function('return ' + funcString)() 匹配参数和函数体 匹配参数 const paramReg = /(?匹配函数体 const bodyReg = /(?函数拷贝的两种方法 eval const funcString = func.toString() const funcCopy = eval(`(${funcString})`) new Function ``` const paramReg = /(?(?=)\\s[{|=>])/ const bodyReg = /(? const param = paramReg.exec(funcString) const bodyReg = bodyReg.exec(funcString) if (body) { if (param) { const params = param[0].split(',') new Function (...params, body[0]) } else { new Function (body[0]) } } ``` Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-02 20:25:50 "},"interview/js/2/1.html":{"url":"interview/js/2/1.html","title":"有1000个dom，需要更新其中的100个，如何操作才能减少dom的操作？","keywords":"","body":" 解答 性能瓶颈： DOM访问 DOM修改导致重绘和重排 缓存DOM对象 将DOM对象缓存。避免重复查询 文档片段 在文档片段上添加dom节点，不会影响到真是的dom结构可以利用这一点将需要修改的dom一并修改完，保存至文档片段中，避免频繁修改dom而导致的重排跟重绘的过程 如果要对元素进行复杂的操作（删减，添加子节点），应将此元素先移除或cloneNode，操作完成之后再替换原来节点 使用innerHtml代替高频的appendChild 最优的layout方案 批量读，一次性写。把任何导致重绘的操作放入requestAnimationFrame 虚拟DOM 将dom抽象为虚拟dom，在dom变化时先对虚拟dom进行操作，通过dom diff将虚拟dom和原虚拟dom做对比，最终批量修改真实dom结构 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-11 17:50:35 "},"interview/js/3/1.html":{"url":"interview/js/3/1.html","title":"关于事件轮询，微任务宏任务的一道题","keywords":"","body":"关于事件轮询，微任务宏任务的一道题 以下输出是什么 console.log('start'); setTimeout(() => { console.log('children2'); // 测试一： // Promise.resolve().then(() => { // console.log('children'); // }) // 测试二： new Promise(resolve => { resolve() }).then(() => { console.log('children'); }); }, 0); new Promise(function (resolve, reject) { console.log('children4'); setTimeout(function () { console.log('children5'); resolve('children6') }, 0); }).then(res => { console.log('children7'); setTimeout(() => { console.log(res); }, 0); }); Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-25 16:28:49 "},"interview/js/4/1.html":{"url":"interview/js/4/1.html","title":"事件循环","keywords":"","body":"事件循环 栈 函数调用形成了一个由若干帧组成的栈 栈存储数据的特点： 基本数据类型 堆 堆表示一大块内存区域 事件循环 while (queue.waitForMessage()) { queue.processNextMessage(); } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-27 15:23:01 "},"interview/js/5/1.html":{"url":"interview/js/5/1.html","title":"实现一个cacheRequest，保证发出多次同一个ajax请求时都能拿到数据，而实际上只发出一次请求","keywords":"","body":" function cacheRequest (): (method: string, url: string, param: string | Document | Blob | ArrayBufferView | ArrayBuffer | FormData | URLSearchParams | ReadableStream) => Promise { const cache = {} return (method, url, param) => { const key = `${method}:${url}:${JSON.stringify(param)}` if (cache[key]) { return cache[key]; } return ( cache[key] = new Promise((resolve, reject) => { const xhr = new XMLHttpRequest(); xhr.onreadystatechange = () => { if (xhr.status === 200) { const { response } = xhr cache[url] = response resolve(response) } } xhr.open(method, url, true); xhr.setRequestHeader('Content-Type', 'applicetion/json'); xhr.send(param); }).catch(e => { console.log('error:', e); }) ) } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-27 16:53:20 "},"interview/js/6/1.html":{"url":"interview/js/6/1.html","title":"爬楼梯！每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？","keywords":"","body":" 解答 每次只能爬 1 层或者 2层台阶，那么到达 n 层的方法有两种： 从 n-1 走 1 层到 n 层 从 n-2 走 2 层到 n 层 那么以此类推 n 为 3 时，n3 = n2 + n1：可以看出这是个斐波那契数列 function stairs () { const fibonacii = []; return (stairNum) => { if (fibonacii[stairNum - 1]) { return fibonacii[stairNum - 1]; } let len = fibonacii.length while (len Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-29 10:32:35 "},"interview/js/7/1.html":{"url":"interview/js/7/1.html","title":"for_of 和 for_in 的区别","keywords":"","body":" 解答 for_in 是用于遍历非Symbol类型的可枚举属性for_of 是用于遍历迭代对象的 迭代对象 拥有 Symbol.iterator 属性，值为一个函数 iterator 函数返回一个对象，拥有next属性，next值为函数 next 函数返回一个对象，有 done 属性和 value 属性，done 代表迭代是否完成，value 代表当前迭代值 for_of 如何迭代普通对象 Object.keys Object.values Object.entries 自定义 Symbol.iterator Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-09 17:21:50 "},"interview/js/8/1.html":{"url":"interview/js/8/1.html","title":"Object.keys 和 for_in 的区别","keywords":"","body":" 解答 for_in 和 Object.keys 遍历顺序一致，遍历可枚举属性 for_in 会遍历原型链上的属性，Object.keys 不会 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-09 17:27:09 "},"interview/js/9/1.html":{"url":"interview/js/9/1.html","title":"几种数据类型的深拷贝","keywords":"","body":" 解答 RegExp 对象拷贝 const sourceReg = /abc/gi; const copyReg = new RegExp(sourceReg.source, sourceReg.flags) 从 url 中提取子域名 const url = 'http://xxx.domain.com'; /http:\\/\\/(\\w+)\\./.exec(url); RegExp.$1 function 函数拷贝 function aa (a, b) { console.log(a.toString(), a); console.log(b.toString(), b); } const funcStr = aa.toString(); const funcParaReg = /^function\\s\\w+\\s{0,}\\((.*)\\)/; const funcParaRet = funcStr.match(funcParaReg); const funcPara = funcParaRet[1]; const funcBodyReg = /^function\\s\\w+\\s{0,}\\(.*\\)\\s{0,}{\\n(.*)\\n}$/s; const funcBodyRet = funcStr.match(funcBodyReg); const funcBody = funcBodyRet[1]; const params = [] funcPara && funcPara.split(',').forEach(param => params.push(param.trim())) const b = new Function (...params, funcBody); b(1111, 2222) Map 对象拷贝 const map = new Map(); if (Object.prototype.toString.call(target) === '[object Map]') { for (let [key, value] of target.entries()) { map.set(key, value) } } Set 对象拷贝 const set = new Set(); if (Object.prototype.toString.call(target) === '[object Set]') { for (let item of target.values) { set.add(item) } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-10 18:02:04 "},"interview/js/10/1.html":{"url":"interview/js/10/1.html","title":"输入两个日期，输出中间的年份和月份","keywords":"","body":" 解答 function outputDate (startDate, endDate) { const ret = [] const _start = new Date(startDate); const _end = new Date(endDate); function step () { const _month = _start.getMonth() + 1; const _year = _start.getFullYear(); if (_month Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-12 16:28:46 "},"interview/js/11/1.html":{"url":"interview/js/11/1.html","title":"动手实现一个repeat方法","keywords":"","body":" 解答 function repeat (func, times, wait) { return function (...args) { function timeout () { if (times > 0) { times--; func.call(this, args); setTimeout(timeout, wait); } } timeout() } } const repeatFunc = repeat(() => console.log(111), 4, 3000); repeatFunc(); Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-13 16:27:56 "},"interview/js/12/1.html":{"url":"interview/js/12/1.html","title":"输入一个数字，找到对应的字母","keywords":"","body":" 解答 function transfer (num) { const times = num / 26 | 0; const last = num % 26; let bit16Str = last > 0 ? `\\\\u00${last > 16 ? '7' : '6'}${(last % 16 || 16).toString(16)}` : '\\\\u007A'; const lastStr = new Function(`return '${bit16Str}'`)(); return ''.padStart(last ? times : times - 1, 'a') + lastStr; } 知识点 进制转换 // 十进制转十六进制 (15).toString(16) // 十六进制转十进制 Number('oxf') // 十进制转二进制 (15).toString(2) // 二进制转十进制 Number('0b1111') 进制表示 二进制：0b 八进制：0o 十六进制：0x unicode 表示法 a-z: \\u0061 - \\u006f \\u0070 - \\u007a // unicode 转 string 方法一：eval(`'${str}'`) 方法二：new Function(`return '${str}'`) 方法三：unescape(str.replace(/\\u/g, '%u')) // string 转unicode `\\\\u${str.charCodeAt(i).toString(16)}` charCodeAt 返回 Unicode 码点，需转为16进制 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 17:26:59 "},"interview/js/13/1.html":{"url":"interview/js/13/1.html","title":"如何判断浏览器事件是否支持捕获","keywords":"","body":" 解答 let supportPassive = false; const opts = { get passive () { console.log('browser event support passive'); suportPassive = true; } } window.addEventListener('test-passive', null, opts); Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-21 15:18:32 "},"interview/js/14/1.html":{"url":"interview/js/14/1.html","title":"🐜 金服 异步串行面试题","keywords":"","body":" 要求实现 createFlow，按照 a,b,延迟1秒,c,延迟1秒,d,e, done 的顺序打印 解答 const log = console.log; const isFunc = obj => typeof obj === 'function'; function createFlow (flows) { return new Flow(flows); } class Flow { constructor (flows) { this.flows = flows; } async run (callback) { for (let flow of this.flows) { if (flow instanceof Flow) { const _flows = flow.flows; for (let _flow of _flows) { isFunc(_flow) && await _flow(); } } if (isFunc(flow)) { await flow(); } if (Array.isArray(flow)) { for (let _flow of flow) { isFunc(_flow) && await _flow(); } } } isFunc(callback) && callback() } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-27 15:31:29 "},"interview/js/15/1.html":{"url":"interview/js/15/1.html","title":"dom 树和渲染树节点一一对应吗","keywords":"","body":" 解答 浏览器一帧绘制的主要步骤： 输入事件回调处理：比如滚动 requestAnimationFrame：上一帧定义的requestAnimationFrame Parse HTML 生成 dom tree Recalc Styles 生成 css tree Layout：dom tree 和 css tree 结合生成 layout tree Update Layer Tree Paint：绘制 Composite: 合并图层 微任务调用 宏任务调用 dom树和渲染树的节点并非一一对应的 css 为display的节点，dom树有，渲染树没有 css 伪元素，dom树没有，渲染树有 requestIdleCallback 是干什么用的 电脑屏幕一帧的时间根据屏幕刷新率确定 ✅ ：比如一台电脑为60HZ，意思就是1秒钟刷新60次，那么一帧的时间就是：1000/60 = 16.7ms一帧的绘制执行到 Composite ，有可能还没到16.7ms，有空闲时间，那么有多少空闲时间呢？使用 requestIdleCallback 查询空闲时间 window.requestIdleCallback(idleDeadline => { console.log('是否过期：', idleDeadline.didTimeout); console.log('剩余时间：', idleDeadline.timeRemaining()) }) 图解 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 19:28:59 "},"interview/react/":{"url":"interview/react/","title":"react","keywords":"","body":"React 每日一题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-09 19:16:37 "},"interview/react/1/1.html":{"url":"interview/react/1/1.html","title":"React Context的理解","keywords":"","body":" 解答 React Context 主要是解决跨层级组件数据传递，可以当作是特定一个组件树内共享的store 过时的Context class Parent extends PureComponent { getChildContext () { return { color: 'red' } } } Parent.childContextTupes = { color: PropTypes.string } Child.contextTypes = { color: PropTypes.string } 新Context const ThemeContext = React.createContext('light'); // Parent class ThemedButton extends PureComponent { static contextType = ThemeContext; render () { this.context } } 优缺点 优点：不同层级的组件需要访问同样一些数据 缺点：组件的复用性变差 组件复用是一种更好的方式 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-09 19:34:54 "},"interview/react/2/1.html":{"url":"interview/react/2/1.html","title":"React fiber是什么？怎么用","keywords":"","body":" 为什么需要 React fiber react v16 之前是通过 树形结构 保存 virtual dom，这种结构有两个问题： 更新任务是不可中止的：比如当前更新到了某个节点，如果任务停止了，那么需要重新进行更新 任务执行时长过长导致丢帧：由于更新任务是不可中止的，时间就很难掌控，当一个 dom tree 节点很多时，执行时间就会很长，比如一帧的时间更长。就可能导致丢帧 fiber 是什么 可以理解为 fiber 是一种数据结构，virtual dom 从 树形结构 变成 fiber tree 链表结构 如何实现 fiber 链接结构 树形结构是通过 children 来关联各个节点，通过深度优先遍历的方式进行 diff链表结构是通过 child，sibling return 来关联各个节点，通过深度优先遍历的方式以及 firstEffect，nextEffect，effectTag 的配合进行 diff 更新 React 原生 fiber 获取渲染的 fiber root document.getElementById('app')._reactRootContainer._internalRoot; fiber root 结构 FiberRootNode { - containerInfo: div#app - current: FiberNode - child: - child: - return: FiberRootNode - sibling: null - firstEffect: null - lastEffect: null - nextEffect: null - stateNode: ul.list - return: null - sibling: null - firstEffect: ul - lastEffect: ul - nextEffect: null - stateNode: div#app - hydrat: false } 如何实现一个简版 React fiber React fiber是一个链表结构，所以遍历链表 workLoop function workLoop () { while (nextUnitOfWork) { nextUnitOfWork = performUnitOfWork(nextUnitOfWork) } // 提交放到最后一起提交，避免部分节点渲染了，部分节点未渲染 commitRoot() } performUnitOfWork 两个作用： 开始当前 workInProgress 的工作 返回链表下一个节点: 有儿子返回儿子，没儿子返回叔叔，没叔叔往上走 当一个节点没儿子时，执行 compeleteUnitOfWork function performUnitOfWork (workInProgress) { beginWork(workInProgress) if (workInProgress.child) { return workInProgress.child } while (workInProgress) { completeUnitOfWork(workInProgress) if (workInProgress.sibling) { return workInProgress.sibling } workInProgress = workInProgress.return } } beginWork 两个作用： 创建 stateNode 维护 child，return，sibling，effectTag function beginWork (workInProgress) { if (!workInProgress.stateNode) { workInProgress.stateNode = document.createElement(workInProgress.type) } let prevFiber workInProgress.props.children.forEach((child, index) => { if (typeof child === 'string') { const childEl = document.createElement(child) workInProgress.stateNode.appendChild(childEl) } else { child = { ...child, return: workInProgress, child: null, sibling: null, effectTag: 'PLACEMENT', firstEffect: null, lastEffect: null, nextEffect: null } if (index === 0) { workInProgress.child = child } else { prevFiber.sibling = child } prevFiber = child } }) } completeUnitOfWork 维护firstEffect，lastEffect, nextEffect function completeUnitOfWork (workInProgress) { const returnFiber = workInProgress.return if (!returnFiber.firstEffect) { returnFiber.firstEffect = workInProgress.firstEffect } if (workInProgress.lastEffect) { if (returnFiber.lastEffect) { returnEffect.lastEffect.nextEffect = workInProgress.lastEffect } returnEffect.lastEffect = workInProgress.lastEffect } if (workInProgress.effectTag) { if (returnFiber.lastEffect) { returnFiber.lastEffect.nextEffect = workInprogress } else { returnFiber.firstEffect = workInProgress } returnFiber.lastEffect = workInProgress } } commitRoot 更新UI function commitRoot () { const nextEffect = workInProgressRoot.firstEffect while (nextEffect) { nextEffect.return.stateNode.appendChild(nextEffect.stateNode) nextEffect = nectEffect.return } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-29 14:39:49 "},"interview/react/3/1.html":{"url":"interview/react/3/1.html","title":"antd4 rc-field-form如何实现的","keywords":"","body":" 学习 rc-field-form 的几个知识点 实现Form组件的数据上下文高阶组件 实现Form组件中的数据托管 实现Form组件中的双向数据绑定 实现Form组件中的强制更新 实现Form组件中的异步表单校验 rc-field-form 的使用 import Form, { Field } from 'rc-field-form' const validateUniqueName = (name, value) => { return new Promise(resolve => { setTimeout(() => { resolve(value === 'xiur' ? `${name} is not unique` : '') }, 3000) }) } { console.log('成功：', values) }} onFinishFailed={(error) => { console.log('失败：', error) }} > 实现逻辑 Form 组件 实例化 formInstance 初始化 store 设置 callbacks 使用 context Field 组件 获取 context 克隆 children 重写 props 注册 Field 声明 onStateChange，store 改变 forceUpdate useForm useForm 返回 formInstance FormStore 数据托管 async-validate 数据校验 Form 实现 如何实现初始值只设置一次？场景：比如外部的父组件更新，会造成 Form 组件的更新，此时会重新设置 initialValue，可是此时已经不是初始化了使用 React.useRef 单例解决这个问题 const FieldContext = React.createContext() const Form = ({ initialValues, onFinish, onFinishFailed, children }) => { const [ formInstance ] = useForm() const mountRef = React.useRef(null) if(!mountRef.current) { formInstance.setInitialValues(initialValues) formInstance.setCallbacks({ onFinish, onFinishFailed }) mountRef.current = true } return {children} } useForm 实现 class FormStore { constructor (forceRootUpdate) { this.forceRootUpdate = forceRootUpdate this.store = {} this.callbacks = {} this.fieldEntities = [] } setCallbacks = callbacks => { this.callbacks = {...callbacks} } setInitialValues = store => { this.store = {...store} } setFieldValue = (name, value) => { this.store[name] = value this.notify() } getFieldValue = name => { return this.store[name] } registerField = (fieldEntity) => { this.fieldEntities.push(fieldEntity) } notify = () => { for (let fieldEntity of this.fieldEntities) { fieldEntity.onStateChange() } } submit = () => { const descriptor = {} this.fieldEntities.forEach(fieldEntity => { const { name, rules } = fieldEntity.props if (rules) { const ruleInfo = {} rules.forEach(rule => { const ruleKeys = Object.keys(rule) ruleKeys.forEach(ruleKey => { ruleInfo[ruleKey] = rule[ruleKey] }) }) descriptor[name] = ruleInfo } }) new Schema(descriptor).validate(this.store) .then(values => { this.callbacks.onFinish(values) }) .catch(error => { this.callbacks.onFinishFailed(error) }) } getForm = () => { return { setInitialValues: this.setInitialValues, setCallbacks: this.setCallbacks, setFieldValue: this.setFieldValue, getFieldValue: this.getFieldValue, registerField: this.registerField, submit: this.submit, } } } function useForm () { const formRef = React.useRef(null) const [, forceUpdate] = React.useState() if (!formRef.current) { const formStore = new FormStore(forceUpdate) const formInstance = formStore.getForm() formRef.current = formInstance } return [formRef.current] } async-validate 实现 class Schema { constructor (descriptor) { this.descriptor = descriptor } validate () { return new Promise(async (resolve, reject) => { let errorInfo = [] const fieldNames = Object.keys(this.descriptor) for (let i = 0; i filedRules[fieldRuleName]) { errors.push(`${fieldName} 最大为${filedRules[fieldRuleName]}位字符`) } break case 'validate': const validateFn = filedRules[fieldRuleName] const result = await validateFn(fieldName, values[fieldName]) if (result.length > 0) { errors.push(result) } } } errors.length > 0 ? errorInfo.push({ name: fieldName, errors }) : void(0) } errorInfo.length > 0 ? reject({ errorInfo, values }) : resolve(values) }) } } Field 实现 这里主要实现 双向数据绑定 和 强制刷新 input 的 value 的获取 从 this.context 通过 getFiledValue 获取 当 onChange 触发通过 setFieldValue 改变 store 时，需要更新UI，就通过 store 的 notify 调用各个 Field 的 onStateChange 实现 class Field extends React.Component { static contextType = FieldContext componentDidMount () { const formInstance = this.context formInstance.registerField(this) } onStateChange = () => { this.forceUpdate } getControlled = () => { const formInstance = this.context const { name, children } = this.props return React.cloneElement(children, { ...children.props, value: formInstance.getFieldValue(name), onChange: (e) => { formInstance.setFieldValue(name, e.target.value) } }) } render () { return this.getControlled() } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-04 15:16:15 "},"interview/js/16/1.html":{"url":"interview/js/16/1.html","title":"请动手实现一个 JSON.parse","keywords":"","body":" 解答 总共两种方案：eval，Function eval function parse (jsonStr) { return eval(`(${jsonStr})`) } new Function function parse (jsonStr) { return new Function(`return ${jsonStr}`)() } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-04 15:53:57 "},"interview/vue/8/1.html":{"url":"interview/vue/8/1.html","title":"响应式与cteated，$mount，mounted","keywords":"","body":" 以上代码模版中渲染的是什么值？ 解答 模版中显示为1 vue实例化的顺序是： initState：observe(options.data) callHook(vm, 'created') vm.$mount callHook(vm, 'mounted') 原因： 最先执行observe，所以在 created 和 mounted 添加的属性，都不是响应式属性 created 在 $mount 之前执行，$mount 挂载时值已经是1，所以渲染时为1 mounted 时把 b 改为了2，可是属性没有被 observe，且并没有重新渲染，所以还是1 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-04 16:12:47 "}}