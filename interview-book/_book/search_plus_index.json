{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"interview/":{"url":"interview/","title":"每日一题","keywords":"","body":"每日一题 一天一题练习 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:33:17 "},"interview/vue/":{"url":"interview/vue/","title":"vue","keywords":"","body":"这里是vue专题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:11:09 "},"interview/vue/1/1.html":{"url":"interview/vue/1/1.html","title":"父组件监听子组件的生命周期","keywords":"","body":" 解法1: @hook @hook:搭配任意钩子函数，会在子组件触发相应生命周期钩子函数时回调父组件这个函数 解法2: $emit 这种方式比较蠢，而且是需要劳动力堆积的 mounted () { this.$emit('mounted') } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:36:45 "},"interview/vue/2/1.html":{"url":"interview/vue/2/1.html","title":"$set解决新增属性不能相应的问题","keywords":"","body":" 解答： 是因为Vue在实例化的过程中就需要对data中的数据使用defineProperty方法来定义存取器实现的响应式。而直接新增属性因为仍是值属性，所以是不能实现响应式的 源码实现 const isValidArrayIndex = index => { return index > 0 && Math.floor(index) === index && isFinite(index) } exprt function set (target, key, val) { if (Array.isArray(target) && isValidArrayIndex(key)) { target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } if (key in target && !(key in target.prototype)) { target[key] = val return val } const __ob__ = target.__ob__ if (!__ob__) { target[key] = val return val } else { defineReactive(__ob__.value, key, val) __ob__.dep.notify() return val } } set分为四步骤： 判断是否为数组，以及索引是否合法 Array.isArray判断target是否为数组 索引是否合法：index > 0 && Math.floor(index) === index && isFinite(index) 数组可能不够长，先把数组扩充下：target.length = Math.max(target.length, key) 通过splice往数组中添加：target.splice(key, 1, val) 判断target对象下是否已经该属性key 存在的话就是修改操作，直接target[key] = val，通过setter存取器触发notify target是否已被响应式 否：不管响应式，target[key] = val完事 已设置响应式，defineReactive(ob.value, key, val), ob.dep.notify()触发更新 defineProperty的缺点 从这个问题可以看出：defineProperty实现响应式，需要在vue实例化时对所有属性进行重定义，不然的话就不能实现响应式有点类似事件绑定时，对单个节点 Proxy的使用 let obj = { a: 1, b: 2 } let obj1 = new Proxy(obj, { get (obj, prop) { console.log(`正在获取属性：${prop}，值为：${obj[prop]}`) return obj[prop] } }) obj1.a obj1.b Proxy类似事件委托，把属性访问委托到另一个对象上，可是不具体关心是什么属性，所以在Vue实例化阶段减少了对data下所有属性进行defineProperty定义存取器 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:21:01 "},"interview/vue/3/1.html":{"url":"interview/vue/3/1.html","title":"自定义指令实现图片懒加载","keywords":"","body":" 图片懒加载的三种实现方式 scroll事件 + getBoundingClientRect const imgs = document.getElementsByTagName('img') const body = document.body function imgLoad () { for (let img of imgs) { const clientRect = img.getBoundingClientRect() if (clientRect.bottom { timer = null func.apply(this, args) }, wait) } } } document.addEventListener('scroll', throttle(imgLoad, 0)) imgLoad() InsectionObserver const imgs = document.getElementsByTagName('img') const intersectionObserver = new IntersectionObserver(function(entries) { for (let entry of entries) { if (entry.intersectionRatio > 0) { const target = entry.target target.style.height = 'auto' target.src = target.getAttribute('data-src') intersectionObserver.unobserve(target) } } }) for (let img of imgs) { intersectionObserver.observe(img) } 浏览器原生支持loading=\"lazy\" Vue自定义指令 + 图片懒加载 模版： const intersectionObserver = new IntersectionObserver(function(entries) { for (let entry of entries) { if (entry.intersectionRatio > 0) { const target = entry.target target.style.height = 'auto' target.src = target.getAttribute('data-src') intersectionObserver.unobserve(target) } } }) directives: { lazy: { inserted: function (el) { intersectionObserver.observe(el) } } } directive的钩子函数 bind：指令第一次绑定到元素时调用 inserted：元素插入父节点时调用 update：所在组件VNode更新时调用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-03 15:50:13 "},"interview/js/":{"url":"interview/js/","title":"js","keywords":"","body":"js高频题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-02 15:11:57 "},"interview/js/1/1.html":{"url":"interview/js/1/1.html","title":"写一个深拷贝，考虑 正则，Date这种类型的数据","keywords":"","body":" 解答 方案一：JSON.parse(JSON.stringify(source)) 缺点： undefined, 函数，symbol值，在序列化过程中会被忽略 不能处理Bigint类型的数据和循环引用，会报错 Map，Set，RegExp类型的数据，会引用丢失，变成空值 Date类型的数据会被当作字符串处理 NaN，Infinity，null都会被当作null Map/Set/WeakMap/WeakSet 仅会序列化可枚举的数据 方案二：判断类型为object 判断参数类型为object后，复制键/值到目标对象，否则返回源对象 function deepClone (source) { if (typeof source === 'object') { const result = Array.isArray(source) ? [] : {} for (let key in source) { const prop = source[key] if (typeof prop === 'object') { result[key] = deepClone(prop) } else { result[key] = prop } } return result } return source } 方案三：Reflect代理法 Reflect.ownKeys可以获取不可枚举属性，Object.keys只能列举可枚举属性 function deepClone (obj) { if (typeof obj === 'object') { let cloneObj = Array.isArray(obj) ? [] : {} Reflect.ownKeys(cloneObj).forEach(key => { const prop = obj[key] cloneObj[key] = typeof prop === 'object' ? deepClone(prop) : obj[key] }) return cloneObj } return obj } 方案四：终极方案 方案二和方案三的思想都是遍历属性，然后重新赋值，但是仍然解决不了Map，Set，RegExp，Date之类的问题深拷贝的几个特殊类型： Date Map Set RegExp Function Symbol 日期拷贝 let source = new Date() let copy = new date.constructor(source) Map拷贝 let source = new Map([['name', 'xuqiang'], ['age', 29]]) let copy = new Map() source.forEach((val, key) => { copy.set(key, val) }) Set拷贝 let source = new Set([1, 2, 3, 4, 5]) let copy = new Set() source.forEach(item => { copy.add(item) }) RegExp拷贝 let source = /a/ let copy = new source.constructor(source.source, /\\w*$/.exec(source)) copy.lastIndex = source.lastIndex Symbol拷贝 let source = { [Symbol('name')]: Symbol('xuqiang') } let copy = {} let symbols = Object.getOwnPropertySymbols(source) for (let symbol of symbols) { copy[symbol] = source[symbol] } 函数的拷贝 函数转字符串 function func (name, age) { console.log(name, age) } const funcString = func.toString() 字符串转函数 // 方案一: const func = eval(`(${funcString})`) // 方案二： const func = new Function('return ' + funcString)() 匹配参数和函数体 匹配参数 const paramReg = /(?匹配函数体 const bodyReg = /(?函数拷贝的两种方法 eval const funcString = func.toString() const funcCopy = eval(`(${funcString})`) new Function ``` const paramReg = /(?(?=)\\s[{|=>])/ const bodyReg = /(? const param = paramReg.exec(funcString) const bodyReg = bodyReg.exec(funcString) if (body) { if (param) { const params = param[0].split(',') new Function (...params, body[0]) } else { new Function (body[0]) } } ``` Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-02 20:25:50 "},"interview/js/2/1.html":{"url":"interview/js/2/1.html","title":"有1000个dom，需要更新其中的100个，如何操作才能减少dom的操作？","keywords":"","body":" 解答 性能瓶颈： DOM访问 DOM修改导致重绘和重排 缓存DOM对象 将DOM对象缓存。避免重复查询 文档片段 在文档片段上添加dom节点，不会影响到真是的dom结构可以利用这一点将需要修改的dom一并修改完，保存至文档片段中，避免频繁修改dom而导致的重排跟重绘的过程 如果要对元素进行复杂的操作（删减，添加子节点），应将此元素先移除或cloneNode，操作完成之后再替换原来节点 使用innerHtml代替高频的appendChild 最优的layout方案 批量读，一次性写。把任何导致重绘的操作放入requestAnimationFrame 虚拟DOM 将dom抽象为虚拟dom，在dom变化时先对虚拟dom进行操作，通过dom diff将虚拟dom和原虚拟dom做对比，最终批量修改真实dom结构 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-11 17:50:35 "},"interview/js/3/1.html":{"url":"interview/js/3/1.html","title":"关于事件轮询，微任务宏任务的一道题","keywords":"","body":"关于事件轮询，微任务宏任务的一道题 以下输出是什么 console.log('start'); setTimeout(() => { console.log('children2'); // 测试一： // Promise.resolve().then(() => { // console.log('children'); // }) // 测试二： new Promise(resolve => { resolve() }).then(() => { console.log('children'); }); }, 0); new Promise(function (resolve, reject) { console.log('children4'); setTimeout(function () { console.log('children5'); resolve('children6') }, 0); }).then(res => { console.log('children7'); setTimeout(() => { console.log(res); }, 0); }); Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-25 16:28:49 "},"interview/js/4/1.html":{"url":"interview/js/4/1.html","title":"事件循环","keywords":"","body":"事件循环 栈 函数调用形成了一个由若干帧组成的栈 栈存储数据的特点： 基本数据类型 堆 堆表示一大块内存区域 事件循环 while (queue.waitForMessage()) { queue.processNextMessage(); } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-27 15:23:01 "},"interview/js/5/1.html":{"url":"interview/js/5/1.html","title":"实现一个cacheRequest，保证发出多次同一个ajax请求时都能拿到数据，而实际上只发出一次请求","keywords":"","body":" function cacheRequest (): (method: string, url: string, param: string | Document | Blob | ArrayBufferView | ArrayBuffer | FormData | URLSearchParams | ReadableStream) => Promise { const cache = {} return (method, url, param) => { const key = `${method}:${url}:${JSON.stringify(param)}` if (cache[key]) { return cache[key]; } return ( cache[key] = new Promise((resolve, reject) => { const xhr = new XMLHttpRequest(); xhr.onreadystatechange = () => { if (xhr.status === 200) { const { response } = xhr cache[url] = response resolve(response) } } xhr.open(method, url, true); xhr.setRequestHeader('Content-Type', 'applicetion/json'); xhr.send(param); }).catch(e => { console.log('error:', e); }) ) } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-27 16:53:20 "},"interview/js/6/1.html":{"url":"interview/js/6/1.html","title":"爬楼梯！每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？","keywords":"","body":" 解答 每次只能爬 1 层或者 2层台阶，那么到达 n 层的方法有两种： 从 n-1 走 1 层到 n 层 从 n-2 走 2 层到 n 层 那么以此类推 n 为 3 时，n3 = n2 + n1：可以看出这是个斐波那契数列 function stairs () { const fibonacii = []; return (stairNum) => { if (fibonacii[stairNum - 1]) { return fibonacii[stairNum - 1]; } let len = fibonacii.length while (len Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-29 10:32:35 "},"interview/js/7/1.html":{"url":"interview/js/7/1.html","title":"for_of 和 for_in 的区别","keywords":"","body":" 解答 for_in 是用于遍历非Symbol类型的可枚举属性for_of 是用于遍历迭代对象的 迭代对象 拥有 Symbol.iterator 属性，值为一个函数 iterator 函数返回一个对象，拥有next属性，next值为函数 next 函数返回一个对象，有 done 属性和 value 属性，done 代表迭代是否完成，value 代表当前迭代值 for_of 如何迭代普通对象 Object.keys Object.values Object.entries 自定义 Symbol.iterator Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-09 17:21:50 "},"interview/js/8/1.html":{"url":"interview/js/8/1.html","title":"Object.keys 和 for_in 的区别","keywords":"","body":" 解答 for_in 和 Object.keys 遍历顺序一致，遍历可枚举属性 for_in 会遍历原型链上的属性，Object.keys 不会 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-09 17:27:09 "},"interview/react/":{"url":"interview/react/","title":"react","keywords":"","body":"React 每日一题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-09 19:16:37 "},"interview/react/1/1.html":{"url":"interview/react/1/1.html","title":"React Context的理解","keywords":"","body":" 解答 React Context 主要是解决跨层级组件数据传递，可以当作是特定一个组件树内共享的store 过时的Context class Parent extends PureComponent { getChildContext () { return { color: 'red' } } } Parent.childContextTupes = { color: PropTypes.string } Child.contextTypes = { color: PropTypes.string } 新Context const ThemeContext = React.createContext('light'); // Parent class ThemedButton extends PureComponent { static contextType = ThemeContext; render () { this.context } } 优缺点 优点：不同层级的组件需要访问同样一些数据 缺点：组件的复用性变差 组件复用是一种更好的方式 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-09 19:34:54 "}}