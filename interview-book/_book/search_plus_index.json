{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球 🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-27 10:37:32 "},"interview/webpack/":{"url":"interview/webpack/","title":"webpack","keywords":"","body":"webpack 每日一题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-10 10:49:13 "},"interview/webpack/1/1.html":{"url":"interview/webpack/1/1.html","title":"webpack做过哪些优化？开发效率，打包策略等","keywords":"","body":" 解答 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-10 16:58:14 "},"interview/webpack/2/1.html":{"url":"interview/webpack/2/1.html","title":"HtmlWebpackPlugin 的配置","keywords":"","body":" 解答 filename new HtmlWebpackPlugin({ filename: 'order/index.html' }) title new HtmlWebpackPlugin({ title: 'Hello Webpack' }) template new HtmlWebpackPlugin({ template: 'template.html' }) templateContent inline html templateParameters new HtmlwebpackPlugin({ templateParameters: { __base_style__: ' .app { red } ' } }) inject inject: true | false | head | body true 跟 body 效果一样：在body末尾注入 false：不注入 js head：在 head 中注入 js publicPath 跟 output publicPath，在输出 js 路径加入 publicPath scriptLoading blocking： 正常注入 js defer：注入 js 添加 defer 属性 scriptLoading: blocking | defer favicon 注入 favicon，⚠️ ：需要是本地的，会带上 publicPath 前缀 minify 压缩，true | false hash js css icon 都会带上 ?hash，可有效清楚缓存 chunks 注入哪些 js chunks: ['main'] chunksSortMode // 插入 html 的很多 chunks，如何排序 chunks: ['index', 'main'], chunksSortMode: 'auto | manual' excludeChunks 不包含的 chunks Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-09 15:03:00 "},"interview/webpack/3/1.html":{"url":"interview/webpack/3/1.html","title":"有哪些有用的 webpack 插件","keywords":"","body":" Loader loader 的使用方式 如果不在 webpack.config.js 中配置 loader，那么怎么使用呢？ require('style-loader!css-loader!./index.css') file-loader 处理文件 把原图片拷贝到 dist，文件名也会变 可以处理任意二进制数据 require('file-loader?outputPath=./images!./1.jepg') { test: /.png/, use: { loader: 'file-loader', options: { outputPath: '/images' } } } 全局注入方案二：expose-loader 这样使用，需要手动 import jquery from 'jquery'；当 require 解析到这个 import 时，就会走 expose-loader但是好处是：只会在一个文件中打包 { test: require.resolve('jquery'), use: { loader: 'expose-loader', options: { exposes: { globalName: '$', override: true } } } } babel-loader babel非常慢，优化主要通过以下两点： exclude 或者 include 精确解析 cacheDirectory: true 开启缓存 { test: /.js$/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } } cache-loader { test: /\\.js$/, use: [ 'cache-loader', 'babel-loader' ], include: path.resolve('src') } css-loader css-loader 解释 @import 和 url() Plugins CleanWebpackPlugin 开发时 dist 目录不断产出，文件很多很乱 const CleanWebpackPlugin = require('clean-webpack-plugin') new CleanWebpackPlugin(['dist']) 不带参数的话，会把 output path 作为目标目录 全局注入方案一：ProvidePlugin 缺点：比如 $: jquery，使用到 $ 的模块都会打包jquery，造成重复打包 配置 noParse 也没用 const webpack = require('webpack') new webpack.ProvidePlugin({ $: 'jquery' }) extract-text-webpack-plugin const ExtractTextWebpackPlugin = require('extract-text-webpack-plugin') { test: /\\.css$/, use: ExtractTextWebpackPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } plugins: [ new ExtractTextPlugin('style.css'), ] 多个 css 模块 如何处理？ const lessExtractPlugin = new ExtractTextWebpackPlugin('css/less.css') const cssExtractPlugin = new ExtractTextWebpackPlugin('css/css.css') const sassExtractPlugin = new ExtractTextWebpackPlugin('css/sass.css') // 加载器以此类推 { test: /\\.css$/, use: cssExtractPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } plugins: [ lessExtractPlugin, cssExtractPlugin, sassExtractPlugin, ] CopyWebpackPlugin const CopyWebpackPlugin = require('copy-webpack-plugin') new CopyWebpackPlugin({ from: path.join(__dirname, 'public'), to: path.join(__dirname, 'dist') }) AggressiveSplittingPlugin new webpack.optimize.AggressiveSplittingPlugin({ minSize: 30000, maxSize: 50000, chunkOverhead: 0, }) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-09 19:41:18 "},"interview/webpack/4/1.html":{"url":"interview/webpack/4/1.html","title":"webpack动态导入 import 是如何实现的","keywords":"","body":" 解答 动态导入 import 使用 // index.js document.getElementById('app').addEventListener('click', () => { import('./console.js').then(_console => { _console.log('clicked') }) }) //console.js function log (msg) { console.log(`system log: ${msg}`) } export { log } webpack 打包之后的样子 // main.js { './index.js': function (module, __webpack_exports__, __webpack_require__) { document.getElementById('app').addEventListener('click', () => { __webpack_require__.e(0).then( __webpack_require__.bind(null, './console.js') ).then(_console_ => { _console_.log('clicked') }) }) } } // 0.js window.webpackJsonp = window.webpackJsonp || [] window.webpackJsonp.push([ [0], { './console.js': function (module, __webpack_exports__, __webpack_require__) { Object.defineProperty(__webpack_exports__, 'log', { enumerable: true, get: function () { return log } }) function log (msg) { console.log(msg) } } } ]) webpack_require 的实现 (function (modules) { var installedModules = {}; function __webpack_require__ (moduleId) { if (installedModules[moduleId]) { return installedModules[moduleId] } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} } modules[moduleId].call(module, module, module.exports, __webpack_require__) module.l = true return module.exports } })({ './index.js': function (){} }) webpack_require.e的实现 var installedChunks = {} __webpack_require__.e = function requireEnsuer (chunkId) { var promises = [] var installedChunkData = installedChunks[chunkId] if (installedChunkData !== 0) { if (installedChunkData) { promises.push(installedChunkData[2]) } else { var promise = new Promise((resolve, reject) => { installedChunkData = installedChunks[chunkId] = [resolve, reject] }) promises.push((installedChunkdata[2] = promise)) var script = document.createElement('script') script.src = `${chunkId}.js` document.head.appendChild(script) } } return Promise.all(promises) } window.webpackJsonp 是什么？ window.webpackJsonp 是个数组，但是传统 jsonp 应该是调用回调函数，可是打包之后代码为什么是：window.webpackJsonp.push，如何触发回调呢？ var jsonpArray = window.webpackJsonp = window.webpackJsonp || [] var parentJsonpFunction = jsonpArray.push.bind(jsonArray) jsonpArray.push = webpackJsonpCallback for (let jsonp of jsonpArray) { webpackJsonpCallback(jsonp) } 可以看出 window.webpackJsonp.push，如果在main.js已加载的情况下，其实已经是 webpackJsonpCallback 函数了 webpackJsonpCallback 的实现 function webpackJsonpCallback (data) { const chunkIds = data[0] const moreModules = data[1] vat resolves = [] for (let chunkId of chunkIds) { resolves.push(installedChunks[chunkId][0]) installedChunks[chunkId] = 0 } for (let moduleName in moreModules) { modules[moduleName] = moreModules[moduleName] } if (parentJsonpFunction) parentJsonpFunction(data) while (resolves.length) { resolves.shift()() } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-12 16:06:53 "},"interview/webpack/5/1.html":{"url":"interview/webpack/5/1.html","title":"开发一个loader，把代码中的箭头函数编译为普通函数","keywords":"","body":" 解答 const transformer = require(\"@babel/core\"); const t = require('@babel/types') module.exports = function(content, map, meta) { const ArrowFunctionToFunctionPlugin = { visitor: { ArrowFunctionExpression(path) { const ruturnStatement = t.returnStatement(path.node.body) const blockStatement = t.blockStatement([ruturnStatement]) const funcExpr = t.functionExpression(null, path.node.params, blockStatement) path.replaceWith(funcExpr) } } } const result = transformer.transform(content, { plugins: [ArrowFunctionToFunctionPlugin] }) return result.code } loader的配置 resolveLoader: { modules: [path.resolve(__dirname, 'loaders')], extensions: ['.js'], mainFields: ['loader'] } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-13 15:58:45 "},"interview/webpack/6/1.html":{"url":"interview/webpack/6/1.html","title":"tapable 的使用和原理","keywords":"","body":" 解答 SyncHook const { SyncHook } = require('tapable') const queue = new SyncHook(['n', 'a', 's']) queue.tap('1', function (name, age, sex) { console.log(name, age, sex) }) queue.tap('2', function (name, age) { console.log(name, age) }) queue.tap('3', function (name, age) { console.log(name, age) }) queue.call('1', 'xiur', 29, 'man') 自定义实现: class SyncHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (...args) { for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { plugin.apply(this, args) } } } } module.exports = SyncHook SyncBailHook const { SyncBailHook } = require('tapable') const queue = new SyncBailHook(['n', 'a', 's']) queue.tap('1', function (name, age, sex) { console.log(name, age, sex) return 'Wrong' }) queue.tap('2', function (name, age) { console.log(name, age) }) queue.tap('3', function (name, age) { console.log(name, age) }) queue.call('1', 'xiur', 29, 'man') 自定义实现： class SyncBailHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (...args) { for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { let result = plugin.apply(this, args) if (result) { return result } } } } } module.exports = SyncBailHook SyncWaterfallHook const { SyncWaterfallHook } = require('tapable') const queue = new SyncWaterfallHook(['n', 'a', 's']) queue.tap('1', function (name, age, sex) { console.log(name, age, sex) return name + '1' }) queue.tap('2', function (name, age) { console.log(name, age) return name + '2' }) queue.tap('3', function (name, age) { console.log(name, age) return name + '3' }) queue.call('xiur', 29, 'man') 自定义实现： class SyncWaterfallHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (init, ...args) { let current = init for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { current = plugin.apply(this, [current, ...args]) } } } } module.exports = SyncWaterfallHook SyncLoopHook const { SyncLoopHook } = require('tapable') const queue = new SyncLoopHook(['n', 'a', 's']) let count = 3; queue.tap('1', function (name, age, sex) { console.log(count) if (count > 0) { count--; return count } else { return } }) queue.call('xiur', 29, 'man') 自定义实现： class SyncLoopHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (...args) { for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { let result do { result = plugin.apply(this, args) } while (result !== undefined) } } } } module.exports = SyncLoopHook AsyncParalleHook 异步并行加载 // const { AsyncParallelHook } = require('tapable') const AsyncParallelHook = require('./AsyncParallelHook') const hook = new AsyncParallelHook(['name']); console.time('cost'); hook.tapAsync('a', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb(); }, 2000) }) hook.tapPromise('a', name => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve(); }, 4000) }) }) hook.callAsync('a', () => { console.log('done'); console.timeEnd('cost'); }); 自定义实现： class AsyncParallelHook { constructor () { this._plugins = {}; } tapAsync (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback.call(this, ...args, () => { ++this.i; if (this.i >= this._plugins[name].length) { return cb() } }); }) } tapPromise (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { callback.apply(this, args).then(() => { const cb = args.pop(); ++this.i; if (this.i >= this._plugins[name].length) { return cb() } }) }) } callAsync (...args) { this.i = 0; for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { plugin.apply(this, args) } } } } module.exports = AsyncParallelHook AsyncSeriesHook 异步串行加载 const { AsyncSeriesHook } = require('tapable'); const hook = new AsyncSeriesHook(['name']); console.time('cost'); hook.tapAsync('a', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb(); }, 2000); }); hook.tapPromise('a', (name) => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve(); }, 4000); }); }); hook.callAsync('a', () => { console.log('done'); console.timeEnd('cost'); }); 自定义实现： class AsyncSeriesHook { constructor () { this._plugins = {} this.next = this._next.bind(this) } tapAsync (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args, () => this.next(name, cb, [...args, cb])); }) } tapPromise (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args).then(() => this.next(name, cb, [...args, cb])) }) } _next (name, cb, args) { ++this.i; if (this.i >= this._plugins[name].length) { return cb(); } this._plugins[name][this.i].apply(this, args) } callAsync (...args) { this.i = 0 for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName]; if (plugins) { plugins[0].apply(this, args) } } } } module.exports = AsyncSeriesHook AsyncSeriesBailHook 异步串行熔断加载 const { AsyncSeriesHook } = require('tapable'); const hook = new AsyncSeriesHook(['name']); console.time('cost'); hook.tapAsync('a', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb('yes'); }, 2000); }); hook.tapPromise('a', (name) => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve('yes'); }, 4000); }); }); hook.callAsync('a', () => { console.log('done'); console.timeEnd('cost'); }); class AsyncSeriesBailHook { constructor () { this._plugins = {} this.next = this._next.bind(this) } tapAsync (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args, ret => this.next(name, cb, [...args, cb], ret)); }) } tapPromise (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args).then(ret => this.next(name, cb, [...args, cb], ret)) }) } _next (name, cb, args, ret) { ++this.i; if (this.i >= this._plugins[name].length || ret !== undefined) { return cb(); } this._plugins[name][this.i].apply(this, args) } callAsync (...args) { this.i = 0 for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName]; if (plugins) { plugins[0].apply(this, args) } } } } module.exports = AsyncSeriesBailHook Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-16 16:46:33 "},"interview/webpack/7/1.html":{"url":"interview/webpack/7/1.html","title":"style-loader 的使用及原理","keywords":"","body":" style-loader 的作用 把 css 插入 html 开发阶段模块热更新 style-loader 和 css-loader 的关系 style-loader 和 css-loader 经常一起使用，那么不使用 css-loader，只用 style-loader 加载 css 行不行呢？答案是不行的 🙅‍♂️ style-loader 只是把 css 插入 html，但是并不会解析 css 文件 那么 webpack 是不认识 css 文件的，需要 css-loader 来加载 css文件 css-loader 换成 less-loader 也是成立的，其作用就是加载 css 文件 试想一下 实现 style-loader需要解决什么问题 如何拿到 css-loader 解析之后的源码？ 如何避免 css-loader 的重复执行【死循环】？ 如何支持热更新？ 可以实行的一种方案： 每次热更新，比如更新了 index.css，网页端会收到一个补丁包：./node_modules/css-loader/dist/cjs.js!./index.css，网页端收到补丁包，会去更新这个模块 客户端监听 module.hot.accept('./node_modules/css-loader/dist/cjs.js!./index.css', function () {}) 回调函数中，重新获取这个模块然后进行更新 更新过程中，如何找到最初的那个 style 节点，客户端就需要用一个映射来保存 styleInDom，映射的值为更新函数，键是啥？ 加载 index.css 插入到 html，那么 index.css 这个名称就可以作为 key 从 style-loader 的使用分析原理 style-loader 的应用场景： loader: ['style-loader', 'css-loader'] webpack loader 的执行路径： | - style-loader `pitch` | - css-loader `pitch` | - requested module is picked up as a dependency | - css-loader normal execution | - style-loader normal execution css-loader 返回结果分析 css-loader 加载 css 之后，loader 的 source 如下： // Imports var ___CSS_LOADER_API_IMPORT___ = require(\"../node_modules/css-loader/dist/runtime/api.js\"); var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(function(i){return i[1]}); // Module ___CSS_LOADER_EXPORT___.push([module.id, \"nbody {n background: yellow;n}n\", \"\"]); // Exports module.exports = ___CSS_LOADER_EXPORT___; 从这个结果来看，在 style-loader 中需要对 source 进行 require 模块导入，然后才能拿到其中的 css 在 loader 中 require 导入其他模块不规范 过程很复杂 所以采用 pitch 的方式 pitch pitch 可以拦截 loader，pitch 中 return 会导致后续的 loader 不执行 pitch 的写法 module.exports.pitch = function (remainingRequest, precedingRequest, data) { remainingRequest： 剩下的请求 precedingRequest：已处理的请求 data：数据 } style-loader 首先需要拿到 css-loader 的处理结果： module.exports = function (remainingRequest) { const remainingPath = loaderUtils.stringifyRequest(this, `!!${remainingRequest}`) return ` import content from ${remainingPath} ` } 这样就拿到 css-loader 处理之后的数据了。如下： [ 0: [ 0: \"./node_modules/css-loader/dist/cjs.js!./index.css\" 1: \"body { color: red}\", 2: \"\" ], i: (modules, mediaQuery, dedupe) => {}, length: 1 ] 从这个数据中，可以看出：0 可以作为 id，1 可以作为css 模块热更新的写法 webpack.config.js 中配置 devServer devServer: { hot: true } 每个需要支持热更新的模块声明 module.hot.accept if (module.hot) { module.hot.accept('./index.css', function () { console.log('halo! css changed') }) } 可以看出我们的代码中是没有声明 module.hot.accept 的，可是 css 却支持热更新，说明 loader 中注入了accept accept 注入 accept 中重新获取css if (module.hot) { module.hot.accept(remainingPath, function () { try { const newContent = require(remainingPath); // 拿到新的内容，重新走渲染 injectStyle(newContent); } catch (e) { console.log('热更新发生错误：', e) } }) } 这里用try catch包起来，因为如果这个回调里报错，webpack会走 reload 导致页面刷新 利用闭包 哪些变量用到了闭包呢：styleInDom，updater，style function injectStyle (content) { for (let item of content) { const id = item[0]; const updater = styleInDom[id]; const css = item[1]; // 如果已经渲染过，拿到 updater 方法，该方法中利用闭包缓存了 style 节点，替换 style 中内容即可 if (updater) { updater(css); } else { styleInDom[id] = addStyle(css) } } } function addStyle (css) { const style = ducument.createElement('style'); style.appendChild(document.createTextNode(css)); document.head.appendChild(style); return function updater (css) { if (css) { while (style.firstChild) { style.removeChild(style.firstChild); } style.appendChild(document.createTextNode(css)); } else { style.parentNode.removeChild(style); delete styleInDom[id] } } } 这里不管第一次渲染，还是之后的热更新，每次 injectStyle 就行了，传入 css-loader 转换之后的结果 总结 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-19 18:03:03 "},"interview/webpack/8/1.html":{"url":"interview/webpack/8/1.html","title":"如何获取loader的配置参数","keywords":"","body":"module 的三种配置方法 // 方式 1 | 2 { test: /\\.js$/, use | loader: 'myloader' | ['myloader'] } // 方式 3 { test: /\\.js$/, use: { loader: 'myloader', options: { name: 'xiur' } } } webpack 配置本地 loader 的四种方法 方法一： { test: /\\.js$/, loader: path.resolve(__dirname, './loader/myloader.js'), } 方法二： resolveLoader: { alias: { myLoader: path.resolve(__dirname, './loader/myloader.js'), } } 方法三： resolveLoader: { modules: ['node_modules', path.resolve(__dirname, './loader')], } 目录：两种目录都可以 ｜ - node_modules | - myloader.js | - myloader | - index.js 方法四： 4.1 在 loader 目录下执行 npm link 4.2 回到项目目录下 执行 npm link myloader 4.3 在 webpack 配置文件中直接使用 myloader 即可 loader-utils 的使用 const loaderUtils = require('loader-utils'); getOptions 获取配置的 options 参数 loaderUtils.getOptions(this); parseQuery 获取 query 参数，query 是没办法配置的 使用场景：import content from './index.css?param1=xiur&param2=29' loaderUtils.parseQuery(this.resourceQuery) => { param1: 'xiur', param2: 29 } stringifyRequest 1. 利用 remainingRequest 参数获取 loader 链的剩余部分 2. 利用 ‘!!’ 前缀跳过其他 loader 2.1 ! 跳过 normal loader 2.2 -! 跳过 pre 和 normal loader 2.3 !! 跳过 pre，normal 和 post loader 3. loaderUtils 的 stringifyRequest 方法将模块的绝对路径转为相对路径 loaderUtils.stringifyRequest(this, '!!' + remainingRequest) => !!../node_modules/css-loader/dist/cjs.js!./index.css ! -! !! 阻断 loader 执行 urlToRequest convert that are root-relative URL into a module URl loaderUtils.urlToRequest('path/to/module.js') => './path/to/module.js' 单纯的路径拼接： loaderUtils.urlToRequest(process.cwd(), '/loader/myloader.js') interpolateName const interpolatedName = loaderUtils.interpolateName(this, '[emoji:4].js', { content: source }); this.emitFile(interpolatedName, source); return `module.exports = '${JSON.stringify(interpolatedName)}'`; name 可填参数： [ext] [name] [path] [folder] [query] [emoji] [emoji:] [contenthash] [hash] Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-18 11:20:34 "}}