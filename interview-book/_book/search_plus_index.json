{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:41:25 "},"knowledge/typescript/":{"url":"knowledge/typescript/","title":"typescript","keywords":"","body":"Typescript Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-18 16:43:34 "},"knowledge/typescript/1/1.html":{"url":"knowledge/typescript/1/1.html","title":"编译上下文","keywords":"","body":"编译上下文 告诉Typescript哪些文件有效，哪些是无效的 基础 项目根目录下创建tsconfig.json {} 此目录和子目录下的所有.ts文件会被作为编译上下文的一部分 编译 运行tsc，会在当前目录或者父级目录寻找tsconfig.json tsc -p ./path-to-project-directory tsc -w 观测模式 显示指定编译哪些文件 具体指定某个文件 { files: [ \"./some/file.ts\" ] } 指定include和exclude文件或文件夹 { include: [ \"./folder\" ], exclude: [ \"./folder/someFolder\", \"./folder/index.ts\" ] } 其他的配置项 { \"compilerOptions\": { /* 基本选项 */ \"target\": \"es5\", // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' \"lib\": [], // 指定要包含在编译中的库文件 \"allowJs\": true, // 允许编译 javascript 文件 \"checkJs\": true, // 报告 javascript 文件中的错误 \"jsx\": \"preserve\", // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react' \"declaration\": true, // 生成相应的 '.d.ts' 文件 \"sourceMap\": true, // 生成相应的 '.map' 文件 \"outFile\": \"./\", // 将输出文件合并为一个文件 \"outDir\": \"./\", // 指定输出目录 \"rootDir\": \"./\", // 用来控制输出目录结构 --outDir. \"removeComments\": true, // 删除编译后的所有的注释 \"noEmit\": true, // 不生成输出文件 \"importHelpers\": true, // 从 tslib 导入辅助工具函数 \"isolatedModules\": true, // 将每个文件作为单独的模块 （与 'ts.transpileModule' 类似）. /* 严格的类型检查选项 */ \"strict\": true, // 启用所有严格类型检查选项 \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错 \"strictNullChecks\": true, // 启用严格的 null 检查 \"noImplicitThis\": true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \"alwaysStrict\": true, // 以严格模式检查每个模块，并在每个文件里加入 'use strict' /* 额外的检查 */ \"noUnusedLocals\": true, // 有未使用的变量时，抛出错误 \"noUnusedParameters\": true, // 有未使用的参数时，抛出错误 \"noImplicitReturns\": true, // 并不是所有函数里的代码都有返回值时，抛出错误 \"noFallthroughCasesInSwitch\": true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ \"moduleResolution\": \"node\", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6) \"baseUrl\": \"./\", // 用于解析非相对模块名称的基目录 \"paths\": {}, // 模块名到基于 baseUrl 的路径映射的列表 \"rootDirs\": [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \"typeRoots\": [], // 包含类型声明的文件列表 \"types\": [], // 需要包含的类型声明文件名列表 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \"sourceRoot\": \"./\", // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 \"mapRoot\": \"./\", // 指定调试器应该找到映射文件而不是生成文件的位置 \"inlineSourceMap\": true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \"inlineSources\": true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ \"experimentalDecorators\": true, // 启用装饰器 \"emitDecoratorMetadata\": true // 为装饰器提供元数据的支持 } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-18 16:58:11 "},"knowledge/typescript/2/1.html":{"url":"knowledge/typescript/2/1.html","title":"配置项","keywords":"","body":"配置项 target { \"target\": \"ES6\" } 比如 const tag = Symbol('tag') target配置为ES6时可以正常编译，配置为ES5及以下时，tsc编译会报错 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-22 16:49:21 "},"knowledge/typescript/3/1.html":{"url":"knowledge/typescript/3/1.html","title":"声明空间","keywords":"","body":"声明空间 ts中存在两种声明空间： 类型声明空间 变量声明空间 类型声明空间 class Foo {} interface Bar {} type Bas = {} // 可以作为类型注解使用： let foo: Foo let bar: Bar let bas: Bas // 但不能作为变量使用： const bar = Bar ❌ 变量声明空间 class Foo {} const someVar = Foo // 一些用var声明的变量，只能在变量声明空间使用。不能用作类型注解 const foo = 123; let bar: foo ❌ 一些如interface定义的内容不能当作变量使用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-22 17:12:36 "},"knowledge/typescript/4/1.html":{"url":"knowledge/typescript/4/1.html","title":"模块","keywords":"","body":"模块 全局模块 在相同的项目不同文件，ts类型系统允许使用变量 // 1.ts const a = '123' // 2.ts const a = '123' ❌ 将会报错，a已被声明 文件模块 在ts文件根级别位置含有import或export，那么会在文件中创建一个本地的作用域 export const a = '123' 这就会转为文件模块了，变量a不会与其他文件中的变量a冲突 模块路径 相对模块路径 import foo from '../foo' 动态查找 import foo from 'foo' ./node_module/foo ../node_module/foo 后缀搜索规则 import foo from './foo' foo是个文件：foo.ts foo是个文件夹 foo/index.ts foo/package.json 重写类型动态查找 // 重写类型动态查找 declare module 'foo' { export var bar: number } import * as foo from 'foo' 配置项 module typescript的模块编译：commonjs，amd，system，umd，es2015这几种方式打包出来的效果： // commonjs exports.__esModule = true; exports.arr = void 0; exports.arr = [1, 2, 3]; // amd define([\"require\", \"exports\"], function (require, exports) { \"use strict\"; exports.__esModule = true; exports.arr = void 0; exports.arr = [1, 2, 3]; }); // system System.register([], function (exports_1, context_1) { \"use strict\"; var arr; var __moduleName = context_1 && context_1.id; return { setters: [], execute: function () { exports_1(\"arr\", arr = [1, 2, 3]); } }; }); // umd (function (factory) { if (typeof module === \"object\" && typeof module.exports === \"object\") { var v = factory(require, exports); if (v !== undefined) module.exports = v; } else if (typeof define === \"function\" && define.amd) { define([\"require\", \"exports\"], factory); } })(function (require, exports) { \"use strict\"; exports.__esModule = true; exports.arr = void 0; exports.arr = [1, 2, 3]; }); // es2015 export var arr = [1, 2, 3] Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-22 17:54:55 "},"knowledge/typescript/5/1.html":{"url":"knowledge/typescript/5/1.html","title":"命名空间","keywords":"","body":"命名空间 namespace Utility { export function log () {} export function error () {} } Utility.log('Call me') Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-22 18:56:58 "},"knowledge/typescript/6/1.html":{"url":"knowledge/typescript/6/1.html","title":"动态导入表达式","keywords":"","body":"动态导入表达式 使用module: esnext选项：ts保留import()语句，用于webpack Code Splitting import('moment').then(moment => { const time = moment().format() }) // tsconfig.json配置 { \"compilerOptions\": { \"module\": \"esnext\" } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-22 19:02:12 "},"knowledge/typescript/7/1.html":{"url":"knowledge/typescript/7/1.html","title":"类型注解","keywords":"","body":"类型注解 原始类型：string，number，boolean 数组：boolean[] 接口： interface name = { firstName: string; lastName: string; } 内联类型注解： let name: { firstName: string; lastName: string; } 特殊类型： undefined, null, any, void 泛型： function reverse(items: T[]): T[] {} interface Array { reverse(): T[]; } 联合类型： let conmand: string[] | string Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-22 19:26:07 "},"knowledge/typescript/8/1.html":{"url":"knowledge/typescript/8/1.html","title":"readonly","keywords":"","body":"readonly 以更安全的方式工作 基本使用 // readonly标记属性 function foo ( config: { readonly bar: number, readonly bas: number } ){ // ... } // 也可以在 interface 和 type 里使用 type FOO = { readonly bar: number; readonly bas: number } const foo: FOO = { bar: 1, bas: 2 } foo.bar = 2 ❌ // 也可以指定类的属性为只读，然后在声明时或者构造函数中初始化它 class FOO { private readonly bar = 1; constructor () { this.bar = 2; } } Readonly 映射类 通过 Readonly 映射类接受一个泛型，把其所有属性变为只读 type Foo = { bar: number; bas: number; } type FooReadonly = Readonly const fooReadonly: FooReadonly = { bar: 1, bas: 2 } fooReadonly.bar = 2 ❌ 把索引签名标记为只读 interface Foo { readonly [x: number]: number; } ReadonlyArray 只能读取，没有push， const foo = ReadonlyArray = [1, 2, 3] 自动推断 只有get，没有set的属性会被推断为readonly 与const的不同 readonly能确保我不能修改，但是把属性交给其他没有这种保证的使用者，他们能改变它如下示例不会报错 type Foo = { readonly baz: number }; const foo: Foo = { baz: 1 } function add (foo: { baz: number }) { foo.baz = 2 } add(foo) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-24 17:31:54 "},"knowledge/typescript/9/1.html":{"url":"knowledge/typescript/9/1.html","title":"@types","keywords":"","body":"@types 方案一： npm install @types/jquery --save-dev import * as $ from 'jquery'; 方案二： // tsconfig.json { \"compilerOptions\": { \"types\": [ \"jquery\" ] } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-25 16:07:55 "},"knowledge/typescript/10/1.html":{"url":"knowledge/typescript/10/1.html","title":"声明文件","keywords":"","body":"声明文件 global.d.ts vendor.d.ts文件有扩展名 .d.ts，每个根级别的声明都必须以 declare 关键字作为前缀 比如node的关键字process declare let process: any; 尽可能推荐使用接口，例如： interface Process { exitWithLog(code?: number): void; } process.exitWithLog = function (...args) { console.log('exiting'); process.exit.apply(process, args) } 这种方式允许其他人扩充这些全局变量 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-25 16:41:35 "},"knowledge/typescript/11/1.html":{"url":"knowledge/typescript/11/1.html","title":"接口","keywords":"","body":"接口 接口旨在声明 javascript 中可能存在的任意结构 接口的声明方式： interface Point { x: number; y: number; } 类可以实现接口: interface Crazy { new() : { hello: number; } } class CrazyClass implements Crazy { constructor () { return { hello: 1 } } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-25 16:47:28 "},"knowledge/typescript/12/1.html":{"url":"knowledge/typescript/12/1.html","title":"枚举","keywords":"","body":"枚举 enum Colors { Red, Blue, Yellow } Colors.Red => 0 Colors[0] => 'Red' Colors改变索引 enum Colors{ Red = 3, Blue, ... } 索引从3开始 位移运算符 二进制表示法：0b0001 八进制表示法：0o0001 十六进制表示法：0x01 左移：> Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-25 17:18:24 "},"knowledge/typescript/13/1.html":{"url":"knowledge/typescript/13/1.html","title":"lib.d.ts","keywords":"","body":"lib.d.ts 安装 Typescript 时，会顺带安装一个lib.d.ts，tsconfig.json中有noLib可以排除此文件 const foo = 123; foo.toString(); Window，Document，Math，String 可以对这些声明进行拓展，建议在 global.d.ts 中 interface Window { helloWorld(): void } interface Math { seedrandom(seed?: string): void; } interface String { endsWith(suffix: string): boolean; } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-25 17:24:33 "},"knowledge/typescript/14/1.html":{"url":"knowledge/typescript/14/1.html","title":"函数","keywords":"","body":"函数 函数不定参数，默认参数 // 函数重载 function padding(all: number); function padding(a: number, b?: number) {} 只声明不实现的场景： // 方案一： type LongHand = { (a: number): number; } // 方案二： type ShortHand = (a: number) => number; Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-25 17:57:06 "}}