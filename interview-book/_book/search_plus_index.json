{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球 🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-27 10:37:32 "},"interview/webpack/":{"url":"interview/webpack/","title":"webpack","keywords":"","body":"webpack 每日一题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-10 10:49:13 "},"interview/webpack/1/1.html":{"url":"interview/webpack/1/1.html","title":"webpack做过哪些优化？开发效率，打包策略等","keywords":"","body":" 解答 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-10 16:58:14 "},"interview/webpack/2/1.html":{"url":"interview/webpack/2/1.html","title":"HtmlWebpackPlugin 的配置","keywords":"","body":" 解答 filename new HtmlWebpackPlugin({ filename: 'order/index.html' }) title new HtmlWebpackPlugin({ title: 'Hello Webpack' }) template new HtmlWebpackPlugin({ template: 'template.html' }) templateContent inline html templateParameters new HtmlwebpackPlugin({ templateParameters: { __base_style__: ' .app { red } ' } }) inject inject: true | false | head | body true 跟 body 效果一样：在body末尾注入 false：不注入 js head：在 head 中注入 js publicPath 跟 output publicPath，在输出 js 路径加入 publicPath scriptLoading blocking： 正常注入 js defer：注入 js 添加 defer 属性 scriptLoading: blocking | defer favicon 注入 favicon，⚠️ ：需要是本地的，会带上 publicPath 前缀 minify 压缩，true | false hash js css icon 都会带上 ?hash，可有效清楚缓存 chunks 注入哪些 js chunks: ['main'] chunksSortMode // 插入 html 的很多 chunks，如何排序 chunks: ['index', 'main'], chunksSortMode: 'auto | manual' excludeChunks 不包含的 chunks Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-09 15:03:00 "},"interview/webpack/3/1.html":{"url":"interview/webpack/3/1.html","title":"有哪些有用的 webpack 插件","keywords":"","body":" Loader loader 的使用方式 如果不在 webpack.config.js 中配置 loader，那么怎么使用呢？ require('style-loader!css-loader!./index.css') file-loader 处理文件 把原图片拷贝到 dist，文件名也会变 可以处理任意二进制数据 require('file-loader?outputPath=./images!./1.jepg') { test: /.png/, use: { loader: 'file-loader', options: { outputPath: '/images' } } } 全局注入方案二：expose-loader 这样使用，需要手动 import jquery from 'jquery'；当 require 解析到这个 import 时，就会走 expose-loader但是好处是：只会在一个文件中打包 { test: require.resolve('jquery'), use: { loader: 'expose-loader', options: { exposes: { globalName: '$', override: true } } } } babel-loader babel非常慢，优化主要通过以下两点： exclude 或者 include 精确解析 cacheDirectory: true 开启缓存 { test: /.js$/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } } cache-loader { test: /\\.js$/, use: [ 'cache-loader', 'babel-loader' ], include: path.resolve('src') } css-loader css-loader 解释 @import 和 url() Plugins CleanWebpackPlugin 开发时 dist 目录不断产出，文件很多很乱 const CleanWebpackPlugin = require('clean-webpack-plugin') new CleanWebpackPlugin(['dist']) 不带参数的话，会把 output path 作为目标目录 全局注入方案一：ProvidePlugin 缺点：比如 $: jquery，使用到 $ 的模块都会打包jquery，造成重复打包 配置 noParse 也没用 const webpack = require('webpack') new webpack.ProvidePlugin({ $: 'jquery' }) extract-text-webpack-plugin const ExtractTextWebpackPlugin = require('extract-text-webpack-plugin') { test: /\\.css$/, use: ExtractTextWebpackPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } plugins: [ new ExtractTextPlugin('style.css'), ] 多个 css 模块 如何处理？ const lessExtractPlugin = new ExtractTextWebpackPlugin('css/less.css') const cssExtractPlugin = new ExtractTextWebpackPlugin('css/css.css') const sassExtractPlugin = new ExtractTextWebpackPlugin('css/sass.css') // 加载器以此类推 { test: /\\.css$/, use: cssExtractPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } plugins: [ lessExtractPlugin, cssExtractPlugin, sassExtractPlugin, ] CopyWebpackPlugin const CopyWebpackPlugin = require('copy-webpack-plugin') new CopyWebpackPlugin({ from: path.join(__dirname, 'public'), to: path.join(__dirname, 'dist') }) AggressiveSplittingPlugin new webpack.optimize.AggressiveSplittingPlugin({ minSize: 30000, maxSize: 50000, chunkOverhead: 0, }) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-09 19:41:18 "},"interview/webpack/4/1.html":{"url":"interview/webpack/4/1.html","title":"webpack动态导入 import 是如何实现的","keywords":"","body":" 解答 动态导入 import 使用 // index.js document.getElementById('app').addEventListener('click', () => { import('./console.js').then(_console => { _console.log('clicked') }) }) //console.js function log (msg) { console.log(`system log: ${msg}`) } export { log } webpack 打包之后的样子 // main.js { './index.js': function (module, __webpack_exports__, __webpack_require__) { document.getElementById('app').addEventListener('click', () => { __webpack_require__.e(0).then( __webpack_require__.bind(null, './console.js') ).then(_console_ => { _console_.log('clicked') }) }) } } // 0.js window.webpackJsonp = window.webpackJsonp || [] window.webpackJsonp.push([ [0], { './console.js': function (module, __webpack_exports__, __webpack_require__) { Object.defineProperty(__webpack_exports__, 'log', { enumerable: true, get: function () { return log } }) function log (msg) { console.log(msg) } } } ]) webpack_require 的实现 (function (modules) { var installedModules = {}; function __webpack_require__ (moduleId) { if (installedModules[moduleId]) { return installedModules[moduleId] } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} } modules[moduleId].call(module, module, module.exports, __webpack_require__) module.l = true return module.exports } })({ './index.js': function (){} }) webpack_require.e的实现 var installedChunks = {} __webpack_require__.e = function requireEnsuer (chunkId) { var promises = [] var installedChunkData = installedChunks[chunkId] if (installedChunkData !== 0) { if (installedChunkData) { promises.push(installedChunkData[2]) } else { var promise = new Promise((resolve, reject) => { installedChunkData = installedChunks[chunkId] = [resolve, reject] }) promises.push((installedChunkdata[2] = promise)) var script = document.createElement('script') script.src = `${chunkId}.js` document.head.appendChild(script) } } return Promise.all(promises) } window.webpackJsonp 是什么？ window.webpackJsonp 是个数组，但是传统 jsonp 应该是调用回调函数，可是打包之后代码为什么是：window.webpackJsonp.push，如何触发回调呢？ var jsonpArray = window.webpackJsonp = window.webpackJsonp || [] var parentJsonpFunction = jsonpArray.push.bind(jsonArray) jsonpArray.push = webpackJsonpCallback for (let jsonp of jsonpArray) { webpackJsonpCallback(jsonp) } 可以看出 window.webpackJsonp.push，如果在main.js已加载的情况下，其实已经是 webpackJsonpCallback 函数了 webpackJsonpCallback 的实现 function webpackJsonpCallback (data) { const chunkIds = data[0] const moreModules = data[1] vat resolves = [] for (let chunkId of chunkIds) { resolves.push(installedChunks[chunkId][0]) installedChunks[chunkId] = 0 } for (let moduleName in moreModules) { modules[moduleName] = moreModules[moduleName] } if (parentJsonpFunction) parentJsonpFunction(data) while (resolves.length) { resolves.shift()() } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-12 16:06:53 "},"interview/webpack/5/1.html":{"url":"interview/webpack/5/1.html","title":"开发一个loader，把代码中的箭头函数编译为普通函数","keywords":"","body":" 解答 const transformer = require(\"@babel/core\"); const t = require('@babel/types') module.exports = function(content, map, meta) { const ArrowFunctionToFunctionPlugin = { visitor: { ArrowFunctionExpression(path) { const ruturnStatement = t.returnStatement(path.node.body) const blockStatement = t.blockStatement([ruturnStatement]) const funcExpr = t.functionExpression(null, path.node.params, blockStatement) path.replaceWith(funcExpr) } } } const result = transformer.transform(content, { plugins: [ArrowFunctionToFunctionPlugin] }) return result.code } loader的配置 resolveLoader: { modules: [path.resolve(__dirname, 'loaders')], extensions: ['.js'], mainFields: ['loader'] } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-13 15:58:45 "},"interview/webpack/6/1.html":{"url":"interview/webpack/6/1.html","title":"tapable 的使用和原理","keywords":"","body":" 解答 SyncHook const { SyncHook } = require('tapable') const queue = new SyncHook(['n', 'a', 's']) queue.tap('1', function (name, age, sex) { console.log(name, age, sex) }) queue.tap('2', function (name, age) { console.log(name, age) }) queue.tap('3', function (name, age) { console.log(name, age) }) queue.call('1', 'xiur', 29, 'man') 自定义实现: class SyncHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (...args) { for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { plugin.apply(this, args) } } } } module.exports = SyncHook SyncBailHook const { SyncBailHook } = require('tapable') const queue = new SyncBailHook(['n', 'a', 's']) queue.tap('1', function (name, age, sex) { console.log(name, age, sex) return 'Wrong' }) queue.tap('2', function (name, age) { console.log(name, age) }) queue.tap('3', function (name, age) { console.log(name, age) }) queue.call('1', 'xiur', 29, 'man') 自定义实现： class SyncBailHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (...args) { for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { let result = plugin.apply(this, args) if (result) { return result } } } } } module.exports = SyncBailHook SyncWaterfallHook const { SyncWaterfallHook } = require('tapable') const queue = new SyncWaterfallHook(['n', 'a', 's']) queue.tap('1', function (name, age, sex) { console.log(name, age, sex) return name + '1' }) queue.tap('2', function (name, age) { console.log(name, age) return name + '2' }) queue.tap('3', function (name, age) { console.log(name, age) return name + '3' }) queue.call('xiur', 29, 'man') 自定义实现： class SyncWaterfallHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (init, ...args) { let current = init for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { current = plugin.apply(this, [current, ...args]) } } } } module.exports = SyncWaterfallHook SyncLoopHook const { SyncLoopHook } = require('tapable') const queue = new SyncLoopHook(['n', 'a', 's']) let count = 3; queue.tap('1', function (name, age, sex) { console.log(count) if (count > 0) { count--; return count } else { return } }) queue.call('xiur', 29, 'man') 自定义实现： class SyncLoopHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (...args) { for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { let result do { result = plugin.apply(this, args) } while (result !== undefined) } } } } module.exports = SyncLoopHook AsyncParalleHook 异步并行加载 // const { AsyncParallelHook } = require('tapable') const AsyncParallelHook = require('./AsyncParallelHook') const hook = new AsyncParallelHook(['name']); console.time('cost'); hook.tapAsync('a', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb(); }, 2000) }) hook.tapPromise('a', name => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve(); }, 4000) }) }) hook.callAsync('a', () => { console.log('done'); console.timeEnd('cost'); }); 自定义实现： class AsyncParallelHook { constructor () { this._plugins = {}; } tapAsync (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback.call(this, ...args, () => { ++this.i; if (this.i >= this._plugins[name].length) { return cb() } }); }) } tapPromise (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { callback.apply(this, args).then(() => { const cb = args.pop(); ++this.i; if (this.i >= this._plugins[name].length) { return cb() } }) }) } callAsync (...args) { this.i = 0; for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { plugin.apply(this, args) } } } } module.exports = AsyncParallelHook AsyncSeriesHook 异步串行加载 const { AsyncSeriesHook } = require('tapable'); const hook = new AsyncSeriesHook(['name']); console.time('cost'); hook.tapAsync('a', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb(); }, 2000); }); hook.tapPromise('a', (name) => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve(); }, 4000); }); }); hook.callAsync('a', () => { console.log('done'); console.timeEnd('cost'); }); 自定义实现： class AsyncSeriesHook { constructor () { this._plugins = {} this.next = this._next.bind(this) } tapAsync (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args, () => this.next(name, cb, [...args, cb])); }) } tapPromise (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args).then(() => this.next(name, cb, [...args, cb])) }) } _next (name, cb, args) { ++this.i; if (this.i >= this._plugins[name].length) { return cb(); } this._plugins[name][this.i].apply(this, args) } callAsync (...args) { this.i = 0 for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName]; if (plugins) { plugins[0].apply(this, args) } } } } module.exports = AsyncSeriesHook AsyncSeriesBailHook 异步串行熔断加载 const { AsyncSeriesHook } = require('tapable'); const hook = new AsyncSeriesHook(['name']); console.time('cost'); hook.tapAsync('a', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb('yes'); }, 2000); }); hook.tapPromise('a', (name) => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve('yes'); }, 4000); }); }); hook.callAsync('a', () => { console.log('done'); console.timeEnd('cost'); }); class AsyncSeriesBailHook { constructor () { this._plugins = {} this.next = this._next.bind(this) } tapAsync (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args, ret => this.next(name, cb, [...args, cb], ret)); }) } tapPromise (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args).then(ret => this.next(name, cb, [...args, cb], ret)) }) } _next (name, cb, args, ret) { ++this.i; if (this.i >= this._plugins[name].length || ret !== undefined) { return cb(); } this._plugins[name][this.i].apply(this, args) } callAsync (...args) { this.i = 0 for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName]; if (plugins) { plugins[0].apply(this, args) } } } } module.exports = AsyncSeriesBailHook Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-16 16:46:33 "},"interview/webpack/7/1.html":{"url":"interview/webpack/7/1.html","title":"style-loader 的使用及原理","keywords":"","body":" style-loader 的作用 把 css 插入 html 开发阶段模块热更新 style-loader 和 css-loader 的关系 style-loader 和 css-loader 经常一起使用，那么不使用 css-loader，只用 style-loader 加载 css 行不行呢？答案是不行的 🙅‍♂️ style-loader 只是把 css 插入 html，但是并不会解析 css 文件 那么 webpack 是不认识 css 文件的，需要 css-loader 来加载 css文件 css-loader 换成 less-loader 也是成立的，其作用就是加载 css 文件 试想一下 实现 style-loader需要解决什么问题 如何拿到 css-loader 解析之后的源码？ 如何避免 css-loader 的重复执行【死循环】？ 如何支持热更新？ 可以实行的一种方案： 每次热更新，比如更新了 index.css，网页端会收到一个补丁包：./node_modules/css-loader/dist/cjs.js!./index.css，网页端收到补丁包，会去更新这个模块 客户端监听 module.hot.accept('./node_modules/css-loader/dist/cjs.js!./index.css', function () {}) 回调函数中，重新获取这个模块然后进行更新 更新过程中，如何找到最初的那个 style 节点，客户端就需要用一个映射来保存 styleInDom，映射的值为更新函数，键是啥？ 加载 index.css 插入到 html，那么 index.css 这个名称就可以作为 key 从 style-loader 的使用分析原理 style-loader 的应用场景： loader: ['style-loader', 'css-loader'] webpack loader 的执行路径： | - style-loader `pitch` | - css-loader `pitch` | - requested module is picked up as a dependency | - css-loader normal execution | - style-loader normal execution css-loader 返回结果分析 css-loader 加载 css 之后，loader 的 source 如下： // Imports var ___CSS_LOADER_API_IMPORT___ = require(\"../node_modules/css-loader/dist/runtime/api.js\"); var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(function(i){return i[1]}); // Module ___CSS_LOADER_EXPORT___.push([module.id, \"nbody {n background: yellow;n}n\", \"\"]); // Exports module.exports = ___CSS_LOADER_EXPORT___; 从这个结果来看，在 style-loader 中需要对 source 进行 require 模块导入，然后才能拿到其中的 css 在 loader 中 require 导入其他模块不规范 过程很复杂 所以采用 pitch 的方式 pitch pitch 可以拦截 loader，pitch 中 return 会导致后续的 loader 不执行 pitch 的写法 module.exports.pitch = function (remainingRequest, precedingRequest, data) { remainingRequest： 剩下的请求 precedingRequest：已处理的请求 data：数据 } style-loader 首先需要拿到 css-loader 的处理结果： module.exports = function (remainingRequest) { const remainingPath = loaderUtils.stringifyRequest(this, `!!${remainingRequest}`) return ` import content from ${remainingPath} ` } 这样就拿到 css-loader 处理之后的数据了。如下： [ 0: [ 0: \"./node_modules/css-loader/dist/cjs.js!./index.css\" 1: \"body { color: red}\", 2: \"\" ], i: (modules, mediaQuery, dedupe) => {}, length: 1 ] 从这个数据中，可以看出：0 可以作为 id，1 可以作为css 模块热更新的写法 webpack.config.js 中配置 devServer devServer: { hot: true } 每个需要支持热更新的模块声明 module.hot.accept if (module.hot) { module.hot.accept('./index.css', function () { console.log('halo! css changed') }) } 可以看出我们的代码中是没有声明 module.hot.accept 的，可是 css 却支持热更新，说明 loader 中注入了accept accept 注入 accept 中重新获取css if (module.hot) { module.hot.accept(remainingPath, function () { try { const newContent = require(remainingPath); // 拿到新的内容，重新走渲染 injectStyle(newContent); } catch (e) { console.log('热更新发生错误：', e) } }) } 这里用try catch包起来，因为如果这个回调里报错，webpack会走 reload 导致页面刷新 利用闭包 哪些变量用到了闭包呢：styleInDom，updater，style function injectStyle (content) { for (let item of content) { const id = item[0]; const updater = styleInDom[id]; const css = item[1]; // 如果已经渲染过，拿到 updater 方法，该方法中利用闭包缓存了 style 节点，替换 style 中内容即可 if (updater) { updater(css); } else { styleInDom[id] = addStyle(css) } } } function addStyle (css) { const style = ducument.createElement('style'); style.appendChild(document.createTextNode(css)); document.head.appendChild(style); return function updater (css) { if (css) { while (style.firstChild) { style.removeChild(style.firstChild); } style.appendChild(document.createTextNode(css)); } else { style.parentNode.removeChild(style); delete styleInDom[id] } } } 这里不管第一次渲染，还是之后的热更新，每次 injectStyle 就行了，传入 css-loader 转换之后的结果 总结 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-20 10:43:13 "},"interview/webpack/8/1.html":{"url":"interview/webpack/8/1.html","title":"如何获取loader的配置参数","keywords":"","body":"module 的三种配置方法 // 方式 1 | 2 { test: /\\.js$/, use | loader: 'myloader' | ['myloader'] } // 方式 3 { test: /\\.js$/, use: { loader: 'myloader', options: { name: 'xiur' } } } webpack 配置本地 loader 的四种方法 方法一： { test: /\\.js$/, loader: path.resolve(__dirname, './loader/myloader.js'), } 方法二： resolveLoader: { alias: { myLoader: path.resolve(__dirname, './loader/myloader.js'), } } 方法三： resolveLoader: { modules: ['node_modules', path.resolve(__dirname, './loader')], } 目录：两种目录都可以 ｜ - node_modules | - myloader.js | - myloader | - index.js 方法四： 4.1 在 loader 目录下执行 npm link 4.2 回到项目目录下 执行 npm link myloader 4.3 在 webpack 配置文件中直接使用 myloader 即可 loader-utils 的使用 const loaderUtils = require('loader-utils'); getOptions 获取配置的 options 参数 loaderUtils.getOptions(this); parseQuery 获取 query 参数，query 是没办法配置的 使用场景：import content from './index.css?param1=xiur&param2=29' loaderUtils.parseQuery(this.resourceQuery) => { param1: 'xiur', param2: 29 } stringifyRequest 1. 利用 remainingRequest 参数获取 loader 链的剩余部分 2. 利用 ‘!!’ 前缀跳过其他 loader 2.1 ! 跳过 normal loader 2.2 -! 跳过 pre 和 normal loader 2.3 !! 跳过 pre，normal 和 post loader 3. loaderUtils 的 stringifyRequest 方法将模块的绝对路径转为相对路径 loaderUtils.stringifyRequest(this, '!!' + remainingRequest) => !!../node_modules/css-loader/dist/cjs.js!./index.css ! -! !! 阻断 loader 执行 urlToRequest convert that are root-relative URL into a module URl loaderUtils.urlToRequest('path/to/module.js') => './path/to/module.js' 单纯的路径拼接： loaderUtils.urlToRequest(process.cwd(), '/loader/myloader.js') interpolateName const interpolatedName = loaderUtils.interpolateName(this, '[emoji:4].js', { content: source }); this.emitFile(interpolatedName, source); return `module.exports = '${JSON.stringify(interpolatedName)}'`; name 可填参数： [ext] [name] [path] [folder] [query] [emoji] [emoji:] [contenthash] [hash] Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-18 11:20:34 "},"interview/webpack/9/1.html":{"url":"interview/webpack/9/1.html","title":"开发一个捕获函数异常的loader","keywords":"","body":" 解答 基本就是在 https://astexplorer.net/ 写一遍，然后根据类型，参考 https://babeljs.io/docs/en/babel-types 创建类型加入即可 const babel = require('@babel/core') const t = require('@babel/types') const ErrorCapturePlugin = { visitor: { Program (path) { path.node.body = [ t.functionDeclaration( t.identifier('errorCapture'), [ t.identifier('e') ], t.blockStatement([ t.expressionStatement( t.callExpression( t.memberExpression( t.identifier('console'), t.identifier('log') ), [ t.stringLiteral('发生异常：') , t.identifier('e') ] ) ), t.expressionStatement( t.callExpression( t.memberExpression( t.identifier('navigator'), t.identifier('sendBeacon') ), [ t.stringLiteral('/log'), t.callExpression( t.memberExpression( t.identifier('JSON'), t.identifier('stringify') ), [ t.identifier('e'), ] ) ] ) ) ]) ), ...path.node.body ] }, FunctionDeclaration (path) { const node = path.node if (node.id.name !== 'errorCapture') { // 把try catch 指定给函数体 node.body = t.blockStatement([ t.tryStatement( node.body, t.catchClause( t.identifier('e'), t.blockStatement([ t.expressionStatement( t.callExpression( t.identifier('errorCapture'), [ t.identifier('e') ] ) ) ]) ) ) ]) } } } } module.exports = function (source) { const reult = babel.transform(source, { plugins: [ ErrorCapturePlugin ] }) console.log('reult:', reult.code) return reult.code } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-20 17:01:08 "},"interview/webpack/10/1.html":{"url":"interview/webpack/10/1.html","title":"webpack5 tree-shaking能摇掉哪些代码","keywords":"","body":" tree-shaking webpack 的 tree-shaking 主要是基于 es6 的静态结构特性，如 import，export 没有导入和使用 代码不会被执行 或 不可到达 代码执行结果不会被用到 代码中只读不写的变量 没有导入和使用 bb 和 cc 两函数没有导入和使用，所以会被删除 // a.js function aa () { console.log('aa') } function bb () { console.log('bb') } export { aa, bb, } // index.js import { aa } from './a' aa(); function cc () { console.log('cc') } 代码不会被执行 或 不可到达 aa 函数体中代码不可到达，所以会被删除 function aa () { if (false) { console.log('aa') } } 代码执行结果不会被用到 aa 函数返回的结果没有被用到，所以会被删除 // a.js function aa () { return 'aa' } // index.js import { aa } from './a' aa(); 代码中只读不写的变量 以下 AA 会被删除，有点类似 Scope Hoisting const AA = 'hello tree-shaking' console.log(AA) => 打包结果 console.log('hello tree-shaking') 将文件标记为无副作用 比如在 index.js 中 import './index.css'，package 中配置了 sideEffects: false 就会把 css 删除掉 sideEffects 会把模块标记为有副作用或无副作用 // package.json { \"sideEffects\": false, \"sideEffects\": [ \"./src/some-side-effectful-file.js\", \"*.css\" ] } // index.js import './index.css' // index.css body { color: red } sideEffects 的配置方法： 有副作用：\"sideEffects\": true 无副作用：\"sideEffects\": false 正则匹配：\"sideEffects\": ['*/.css'] 具体文件：\"sideEffects\": ['./src/index.js'] 给语句标记为无副作用 通过给语句加 /#PURE/ 使其被 tree-shaking sideEffects 的原理跟 PURE 类似，sideEffects 是作用于模块，而 PURE 是作用于语句 function aa () { console.log('aaaa') } /*#__PURE__*/ aa(); 正常情况下，console.log('aaaa')会被打包进代码，加了 PURE 之后不会打包 scope Hoisting 分析出模块之间的依赖关系，尽可能把打散的模块合并到一个函数中去，用到 es6 模块 只有被引用了一次的模块才能被合并 通过 webpack 内置插件实现：webpack/lib/optimize/ModuleConcatenationPlugin 最佳实践 使用 es6 的 import 和 export 确保编译器不会把 es6 模块语法转换为 CommonJS的 package.json 中添加 sideEffects Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-07 16:31:28 "},"interview/webpack/11/1.html":{"url":"interview/webpack/11/1.html","title":"webpack5 公共代码拆分","keywords":"","body":" 场景 webpack 的默认拆分 默认不配置 splitChunks，出来四个打包文件 - page1.js - page2.js - page3.js - 3.js splitChunks webpack 公共代码拆分主要依赖 SplitChunksPlugin，配置 optimization optimization: { splitChunks: { async：只提取动态 import 代码，initial：提取同步代码（直接引入的模块），all：所有 chunks: 'async | all | initial', 分割出去的代码块的最大最小体积，0表示不限制 minSize: 0, maxSize: 0, 如果此模块被多个入口引用几次会被分割 minChunks: 1, 异步请求和同步请求最多分割出去多少个代码块 maxAsyncRequests: 30, maxInitialRequests: 30, 名称的分割符 vendors~main.js => page1~module1_jsf51c7e26.js automaticNameDelimiter: '~', 缓存组配置 配置如何对模块分组相同分组会分到一个代码块中 cacheGroups: { 第三方模块 defaultVendors: { 如果模块的路径匹配此正则的话 test: /[\\\\/]node_modules[\\\\/]/, 很多缓存组，如果一个模块同属于多个缓存组，应该分到哪个组里，看优先级高 priority: -10, 是否可复用现有的代码块，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了 reuseExistingChunk: true }, default: { 此模块最几个入口引用过，最少2个才取提取 minChunks: 2, priority: -20, reuseExistingChunk: true } } } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-08 19:56:26 "},"interview/js/":{"url":"interview/js/","title":"js","keywords":"","body":"js高频题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-02 15:11:57 "},"interview/js/1/1.html":{"url":"interview/js/1/1.html","title":"写一个深拷贝，考虑 正则，Date这种类型的数据","keywords":"","body":" 解答 方案一：JSON.parse(JSON.stringify(source)) 缺点： undefined, 函数，symbol值，在序列化过程中会被忽略 不能处理Bigint类型的数据和循环引用，会报错 Map，Set，RegExp类型的数据，会引用丢失，变成空值 Date类型的数据会被当作字符串处理 NaN，Infinity，null都会被当作null Map/Set/WeakMap/WeakSet 仅会序列化可枚举的数据 方案二：判断类型为object 判断参数类型为object后，复制键/值到目标对象，否则返回源对象 function deepClone (source) { if (typeof source === 'object') { const result = Array.isArray(source) ? [] : {} for (let key in source) { const prop = source[key] if (typeof prop === 'object') { result[key] = deepClone(prop) } else { result[key] = prop } } return result } return source } 方案三：Reflect代理法 Reflect.ownKeys可以获取不可枚举属性，Object.keys只能列举可枚举属性 function deepClone (obj) { if (typeof obj === 'object') { let cloneObj = Array.isArray(obj) ? [] : {} Reflect.ownKeys(cloneObj).forEach(key => { const prop = obj[key] cloneObj[key] = typeof prop === 'object' ? deepClone(prop) : obj[key] }) return cloneObj } return obj } 方案四：终极方案 方案二和方案三的思想都是遍历属性，然后重新赋值，但是仍然解决不了Map，Set，RegExp，Date之类的问题深拷贝的几个特殊类型： Date Map Set RegExp Function Symbol 日期拷贝 let source = new Date() let copy = new date.constructor(source) Map拷贝 let source = new Map([['name', 'xuqiang'], ['age', 29]]) let copy = new Map() source.forEach((val, key) => { copy.set(key, val) }) Set拷贝 let source = new Set([1, 2, 3, 4, 5]) let copy = new Set() source.forEach(item => { copy.add(item) }) RegExp拷贝 let source = /a/ let copy = new source.constructor(source.source, /\\w*$/.exec(source)) copy.lastIndex = source.lastIndex Symbol拷贝 let source = { [Symbol('name')]: Symbol('xuqiang') } let copy = {} let symbols = Object.getOwnPropertySymbols(source) for (let symbol of symbols) { copy[symbol] = source[symbol] } 函数的拷贝 函数转字符串 function func (name, age) { console.log(name, age) } const funcString = func.toString() 字符串转函数 // 方案一: const func = eval(`(${funcString})`) // 方案二： const func = new Function('return ' + funcString)() 匹配参数和函数体 匹配参数 const paramReg = /(?匹配函数体 const bodyReg = /(?函数拷贝的两种方法 eval const funcString = func.toString() const funcCopy = eval(`(${funcString})`) new Function ``` const paramReg = /(?(?=)\\s[{|=>])/ const bodyReg = /(? const param = paramReg.exec(funcString) const bodyReg = bodyReg.exec(funcString) if (body) { if (param) { const params = param[0].split(',') new Function (...params, body[0]) } else { new Function (body[0]) } } ``` Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-02 20:25:50 "},"interview/js/2/1.html":{"url":"interview/js/2/1.html","title":"有1000个dom，需要更新其中的100个，如何操作才能减少dom的操作？","keywords":"","body":" 解答 性能瓶颈： DOM访问 DOM修改导致重绘和重排 缓存DOM对象 将DOM对象缓存。避免重复查询 文档片段 在文档片段上添加dom节点，不会影响到真是的dom结构可以利用这一点将需要修改的dom一并修改完，保存至文档片段中，避免频繁修改dom而导致的重排跟重绘的过程 如果要对元素进行复杂的操作（删减，添加子节点），应将此元素先移除或cloneNode，操作完成之后再替换原来节点 使用innerHtml代替高频的appendChild 最优的layout方案 批量读，一次性写。把任何导致重绘的操作放入requestAnimationFrame 虚拟DOM 将dom抽象为虚拟dom，在dom变化时先对虚拟dom进行操作，通过dom diff将虚拟dom和原虚拟dom做对比，最终批量修改真实dom结构 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-11 17:50:35 "},"interview/js/3/1.html":{"url":"interview/js/3/1.html","title":"关于事件轮询，微任务宏任务的一道题","keywords":"","body":"关于事件轮询，微任务宏任务的一道题 以下输出是什么 console.log('start'); setTimeout(() => { console.log('children2'); // 测试一： // Promise.resolve().then(() => { // console.log('children'); // }) // 测试二： new Promise(resolve => { resolve() }).then(() => { console.log('children'); }); }, 0); new Promise(function (resolve, reject) { console.log('children4'); setTimeout(function () { console.log('children5'); resolve('children6') }, 0); }).then(res => { console.log('children7'); setTimeout(() => { console.log(res); }, 0); }); Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-25 16:28:49 "},"interview/js/4/1.html":{"url":"interview/js/4/1.html","title":"事件循环","keywords":"","body":"事件循环 栈 函数调用形成了一个由若干帧组成的栈 栈存储数据的特点： 基本数据类型 堆 堆表示一大块内存区域 事件循环 while (queue.waitForMessage()) { queue.processNextMessage(); } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-27 15:23:01 "},"interview/js/5/1.html":{"url":"interview/js/5/1.html","title":"实现一个cacheRequest，保证发出多次同一个ajax请求时都能拿到数据，而实际上只发出一次请求","keywords":"","body":" function cacheRequest (): (method: string, url: string, param: string | Document | Blob | ArrayBufferView | ArrayBuffer | FormData | URLSearchParams | ReadableStream) => Promise { const cache = {} return (method, url, param) => { const key = `${method}:${url}:${JSON.stringify(param)}` if (cache[key]) { return cache[key]; } return ( cache[key] = new Promise((resolve, reject) => { const xhr = new XMLHttpRequest(); xhr.onreadystatechange = () => { if (xhr.status === 200) { const { response } = xhr cache[url] = response resolve(response) } } xhr.open(method, url, true); xhr.setRequestHeader('Content-Type', 'applicetion/json'); xhr.send(param); }).catch(e => { console.log('error:', e); }) ) } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-27 16:53:20 "},"interview/js/6/1.html":{"url":"interview/js/6/1.html","title":"爬楼梯！每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？","keywords":"","body":" 解答 每次只能爬 1 层或者 2层台阶，那么到达 n 层的方法有两种： 从 n-1 走 1 层到 n 层 从 n-2 走 2 层到 n 层 那么以此类推 n 为 3 时，n3 = n2 + n1：可以看出这是个斐波那契数列 function stairs () { const fibonacii = []; return (stairNum) => { if (fibonacii[stairNum - 1]) { return fibonacii[stairNum - 1]; } let len = fibonacii.length while (len Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-29 10:32:35 "},"interview/js/7/1.html":{"url":"interview/js/7/1.html","title":"for_of 和 for_in 的区别","keywords":"","body":" 解答 for_in 是用于遍历非Symbol类型的可枚举属性for_of 是用于遍历迭代对象的 迭代对象 拥有 Symbol.iterator 属性，值为一个函数 iterator 函数返回一个对象，拥有next属性，next值为函数 next 函数返回一个对象，有 done 属性和 value 属性，done 代表迭代是否完成，value 代表当前迭代值 for_of 如何迭代普通对象 Object.keys Object.values Object.entries 自定义 Symbol.iterator Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-09 17:21:50 "},"interview/js/8/1.html":{"url":"interview/js/8/1.html","title":"Object.keys 和 for_in 的区别","keywords":"","body":" 解答 for_in 和 Object.keys 遍历顺序一致，遍历可枚举属性 for_in 会遍历原型链上的属性，Object.keys 不会 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-09 17:27:09 "},"interview/js/9/1.html":{"url":"interview/js/9/1.html","title":"几种数据类型的深拷贝","keywords":"","body":" 解答 RegExp 对象拷贝 const sourceReg = /abc/gi; const copyReg = new RegExp(sourceReg.source, sourceReg.flags) 从 url 中提取子域名 const url = 'http://xxx.domain.com'; /http:\\/\\/(\\w+)\\./.exec(url); RegExp.$1 function 函数拷贝 function aa (a, b) { console.log(a.toString(), a); console.log(b.toString(), b); } const funcStr = aa.toString(); const funcParaReg = /^function\\s\\w+\\s{0,}\\((.*)\\)/; const funcParaRet = funcStr.match(funcParaReg); const funcPara = funcParaRet[1]; const funcBodyReg = /^function\\s\\w+\\s{0,}\\(.*\\)\\s{0,}{\\n(.*)\\n}$/s; const funcBodyRet = funcStr.match(funcBodyReg); const funcBody = funcBodyRet[1]; const params = [] funcPara && funcPara.split(',').forEach(param => params.push(param.trim())) const b = new Function (...params, funcBody); b(1111, 2222) Map 对象拷贝 const map = new Map(); if (Object.prototype.toString.call(target) === '[object Map]') { for (let [key, value] of target.entries()) { map.set(key, value) } } Set 对象拷贝 const set = new Set(); if (Object.prototype.toString.call(target) === '[object Set]') { for (let item of target.values) { set.add(item) } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-10 18:02:04 "},"interview/js/10/1.html":{"url":"interview/js/10/1.html","title":"输入两个日期，输出中间的年份和月份","keywords":"","body":" 解答 function outputDate (startDate, endDate) { const ret = [] const _start = new Date(startDate); const _end = new Date(endDate); function step () { const _month = _start.getMonth() + 1; const _year = _start.getFullYear(); if (_month Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-12 16:28:46 "},"interview/js/11/1.html":{"url":"interview/js/11/1.html","title":"动手实现一个repeat方法","keywords":"","body":" 解答 function repeat (func, times, wait) { return function (...args) { function timeout () { if (times > 0) { times--; func.call(this, args); setTimeout(timeout, wait); } } timeout() } } const repeatFunc = repeat(() => console.log(111), 4, 3000); repeatFunc(); Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-13 16:27:56 "},"interview/js/12/1.html":{"url":"interview/js/12/1.html","title":"输入一个数字，找到对应的字母","keywords":"","body":" 解答 function transfer (num) { const times = num / 26 | 0; const last = num % 26; let bit16Str = last > 0 ? `\\\\u00${last > 16 ? '7' : '6'}${(last % 16 || 16).toString(16)}` : '\\\\u007A'; const lastStr = new Function(`return '${bit16Str}'`)(); return ''.padStart(last ? times : times - 1, 'a') + lastStr; } 知识点 进制转换 // 十进制转十六进制 (15).toString(16) // 十六进制转十进制 Number('oxf') // 十进制转二进制 (15).toString(2) // 二进制转十进制 Number('0b1111') 进制表示 二进制：0b 八进制：0o 十六进制：0x unicode 表示法 a-z: \\u0061 - \\u006f \\u0070 - \\u007a // unicode 转 string 方法一：eval(`'${str}'`) 方法二：new Function(`return '${str}'`) 方法三：unescape(str.replace(/\\u/g, '%u')) // string 转unicode `\\\\u${str.charCodeAt(i).toString(16)}` charCodeAt 返回 Unicode 码点，需转为16进制 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 17:26:59 "},"interview/js/13/1.html":{"url":"interview/js/13/1.html","title":"如何判断浏览器事件是否支持捕获","keywords":"","body":" 解答 let supportPassive = false; const opts = { get passive () { console.log('browser event support passive'); suportPassive = true; } } window.addEventListener('test-passive', null, opts); Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-21 15:18:32 "},"interview/js/14/1.html":{"url":"interview/js/14/1.html","title":"🐜 金服 异步串行面试题","keywords":"","body":" 要求实现 createFlow，按照 a,b,延迟1秒,c,延迟1秒,d,e, done 的顺序打印 解答 const log = console.log; const isFunc = obj => typeof obj === 'function'; function createFlow (flows) { return new Flow(flows); } class Flow { constructor (flows) { this.flows = flows; } async run (callback) { for (let flow of this.flows) { if (flow instanceof Flow) { const _flows = flow.flows; for (let _flow of _flows) { isFunc(_flow) && await _flow(); } } if (isFunc(flow)) { await flow(); } if (Array.isArray(flow)) { for (let _flow of flow) { isFunc(_flow) && await _flow(); } } } isFunc(callback) && callback() } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-27 15:31:29 "},"interview/js/15/1.html":{"url":"interview/js/15/1.html","title":"dom 树和渲染树节点一一对应吗","keywords":"","body":" 解答 浏览器一帧绘制的主要步骤： 输入事件回调处理：比如滚动 requestAnimationFrame：上一帧定义的requestAnimationFrame Parse HTML 生成 dom tree Recalc Styles 生成 css tree Layout：dom tree 和 css tree 结合生成 layout tree Update Layer Tree Paint：绘制 Composite: 合并图层 微任务调用 宏任务调用 dom树和渲染树的节点并非一一对应的 css 为display的节点，dom树有，渲染树没有 css 伪元素，dom树没有，渲染树有 requestIdleCallback 是干什么用的 电脑屏幕一帧的时间根据屏幕刷新率确定 ✅ ：比如一台电脑为60HZ，意思就是1秒钟刷新60次，那么一帧的时间就是：1000/60 = 16.7ms一帧的绘制执行到 Composite ，有可能还没到16.7ms，有空闲时间，那么有多少空闲时间呢？使用 requestIdleCallback 查询空闲时间 window.requestIdleCallback(idleDeadline => { console.log('是否过期：', idleDeadline.didTimeout); console.log('剩余时间：', idleDeadline.timeRemaining()) }) 图解 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 19:28:59 "},"interview/js/16/1.html":{"url":"interview/js/16/1.html","title":"请动手实现一个 JSON.parse","keywords":"","body":" 解答 总共两种方案：eval，Function eval function parse (jsonStr) { return eval(`(${jsonStr})`) } new Function function parse (jsonStr) { return new Function(`return ${jsonStr}`)() } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-04 15:53:57 "},"interview/js/17/1.html":{"url":"interview/js/17/1.html","title":"精度丢失 0.000000000001问题","keywords":"","body":" 解答 js 的精度丢失问题，想必都遇到过，比如👇 0.3 * 0.75 = 0.22499999999999998 其实值为 0.225，可是实际出来却是 0.22499999999999998，这是由 js 底层转换为二进制计算导致 解决方案 toPrecision (0.3 * 0.75).toPrecision(12) = '0.225000000000' Number((0.3 * 0.75).toPrecision(12)).toPrecision(2) = 0.23 为什么首次取精度为12，这是经验之谈，一般 12 位就够用了 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-01 15:32:44 "},"interview/js/18/1.html":{"url":"interview/js/18/1.html","title":"声明提升的问题","keywords":"","body":" 解答 输出 test is not function，因为自执行函数内函数的声明提升导致函数变成了 undefined Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-01 16:00:15 "},"interview/js/19/1.html":{"url":"interview/js/19/1.html","title":"巩固原生 js","keywords":"","body":"类数组如何转成数组 四种方法： [].slice(arguments) Array.from(arguments) [...arguments] Array.prototype.concat.apply([], arguments) forEach 中 return 有效果吗？ return 不能阻止 forEach 循环，要跳出循环的几种方法： 抛出异常，在外部捕获 使用 every + return false，some + return true 代替 forEach 判断数组中是否存在某元素 四种方法： ~arr.indexOf(1) arr.includes(1) arr.find(item => item === 1) arr.findIndex(item => item === 1) 数组扁平化 flat replace + split reduce 扩展运算符 const arr = [1, [2, 2], [3, 3, 3]]; const result1 = arr.flat(Infinity); const result2 = arr.toString().replace(/\\[\\]/g, '').split(',') function flatten (arr) { return arr.reduce((prevArr, cur, idx, arr) => { return prevArr.concat(Array.isArray(cur) ? flatten(cur) : cur); }, []) } const result3 = flatten(arr); while (arr.some(Array.isArray)) { arr = [].concat(...arr) } 高阶函数 一个函数把另一个函数作为参数或者返回值，简称闭包如数组的map，reduce，filter等都是 自定义 map 实现 Array.prototype.map = function (callback, thisArg) { let result = [] this.forEach((item, idx) => { let ret = callback.call(thisArg, item, idx, this); result.push(ret); }); return result; } reduce 实现 Array.prototype.reduce = function (callback, initialValue) { this.forEach((item, idx) => { initialValue = callback(initialValue, item, idx, this); }); return initialValue; } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-01 19:54:36 "},"interview/js/20/1.html":{"url":"interview/js/20/1.html","title":"js中堆栈的理解","keywords":"","body":" 名词解释 ECStack：Execution Context StackEC：Execution StackVO：Variable ObjectAO：Activation ObjectScope：作用域，函数声明时创建ScopeChain：作用域链 js 执行过程 解析 js 代码主要是以下步骤： 创建一个 EC(G) 全局执行上下文 创建一个 VO(G) 全局变量对象 遇到变量声明，把它挂载到 VO(G) 上 遇到函数声明，把它挂载到 VO(G) 上，并给函数赋予私有属性 [[Scopes]] [[Scopes]] 是个数组，赋予值为上一层作用域的变量对象 VO(G) 把 全局执行上下文 EC(G) 压入 执行环境栈 ECStack 遇到函数 A 执行创建 EC(A)，并把 EC(A) 压入 ECStack 函数 A 执行时会创建 AO(A) AO 包含形参，实参 arguments，变量声明，函数声明 变量对象 和 活动对象 的关系 活动对象属于变量对象 变量对象理论上是，js引擎解析之后生成的挂载变量的对象 当函数执行时，变量对象会被激活，变成活动对象 变量对象只包含：变量声明 + 函数声明 活动对象包含：形参 + 实参 arguments + 变量声明 + 函数声明 活动对象是函数执行时被创建的，通过 arguments 属性初始化，arguments 属性值是 Arguments 对象 作用域链 在每个函数上有个私有属性 [[Scopes]]，包含了它的上层用户域的 AO 一直循着 [[Scopes]] 查找，会找到全局 AO(G) 这些 [[Scopes]] 就是链式结构，成为作用域链 闭包 函数嵌套的情况下，内部函数可以沿着私有属性 [[Scopes]] 使用外部作用域的变量，所以内部函数没有销毁的情况下，外部函数变量就需一直存在内存中，这种现象就称为闭包 var let const var 声明的变量会被定义在 VO(G) 即 window 上 let const 声明的对象不在 VO(G)上，会有一个新的 Scopes function noop () { console.log(name) }; console.log(noop.prototype) 可以看到 noop 函数的 上层作用域 - prototype - consutructor - [[Scopes]] - 0: Script { name1: 'Alex', name2: 'Xiur' } - 1: Global { window } 上一道面试题 var a = { n: 1 }; var b = a; a.x = a = { n: 2 }; console.log(a.x) console.log(b) 这道题的难点主要是 a.x = a = 的执行顺序，真实的顺序为： a.x = { n: 2 } a = { n: 2 } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-09 16:09:20 "},"interview/js/21/1.html":{"url":"interview/js/21/1.html","title":"手写仓储系统","keywords":"","body":" 支付宝手写仓储系统 这道题看完了之后，主要是考虑到一个爆仓之后事件回滚 class Depository { constructor (options) { this.store = {} } transferIn (cargo) { this.transaction(transactions => { this.executeTask(this.store, cargo, (target, source, category, prodName) => { return () => { category[prodName] = (target || 0) + source } }, transactions); }) } transferOut (cargo) { this.transaction(transactions => { this.executeTask(this.store, cargo, (target, source, category, prodName) => { if (typeof target === 'number' && target >= source) { return () => { category[prodName] = target - source } } else { throw new Error(`${prodName} 爆仓了，需要 ${source}，仓储 ${target}`) } }, transactions); }) } executeTask (target, source, callback, transactions) { for (let prop in source) { const propType = typeof source[prop] if (propType === 'object') { this.executeTask(target[prop] || (target[prop] = {}), source[prop], callback, transactions) } if (propType === 'number') { transactions.push( callback(target[prop], source[prop], target, prop) ) } } } transaction (task) { let transactions = []; try { task(transactions); for (let transaction of transactions) { transaction(); } console.log('任务执行完毕，当前仓库储备：', JSON.stringify(this.store)) } catch (e) { console.error(e.message); console.log('已爆仓，任务回滚，请提工单联系仓储，当前仓库储备：', JSON.stringify(this.store)) } } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-09 17:23:13 "}}