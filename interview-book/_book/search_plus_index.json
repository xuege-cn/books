{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:41:25 "},"knowledge/react/":{"url":"knowledge/react/","title":"React","keywords":"","body":"React Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 10:51:30 "},"knowledge/react/theory/":{"url":"knowledge/react/theory/","title":"React原理","keywords":"","body":"React原理 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-20 10:55:49 "},"knowledge/react/theory/1/1.html":{"url":"knowledge/react/theory/1/1.html","title":"React中setState后发生了什么？","keywords":"","body":" 解答 调用setState之后，会经历一下几步： React会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程 经过调和过程，React会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个UI界面 在React得到元素树之后，React会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染 在差异计算算法中，React能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染 setState为什么默认是异步 假如所有setState是同步的，意味着没执行一次setSTate时，都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。 setState什么时候是同步 setTimeout 原生事件 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 11:17:01 "},"knowledge/react/theory/2/1.html":{"url":"knowledge/react/theory/2/1.html","title":"Redux中异步的请求如何处理？","keywords":"","body":" 解答 redux-thunk 第一步：配置redux-thunk： import { createStore, applyMiddleware, compose } from 'redux' import thunk from 'redux-thunk' const enhancer = composeEnhancers(applymiddleware(thunk)) const store = createStore(reducer, enhancer) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 15:56:26 "},"knowledge/react/theory/3/1.html":{"url":"knowledge/react/theory/3/1.html","title":"React组件之间的通信方式","keywords":"","body":" 解答 1. 父组件向自组件通信 - 属性传递 2. 子组件向父组件通信 - 属性方法传递 3. 跨组件通信 - 属性传递，传递层级较深增加复杂度 - 使用context 4. 没有嵌套关系的组件 - 自定义事件通信（发布订阅） - redux等全局状态管理 - 兄弟组件可以通信父组件通信 使用Context跨组件通信 const BatteryContext = createContext() { color => {} } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-07 11:17:24 "},"knowledge/react/theory/4/1.html":{"url":"knowledge/react/theory/4/1.html","title":"React.createElement主要做了什么？","keywords":"","body":" 为什么使用jsx的文件都需要import React？ 因为jsx会被解析为React.createElement，createElement接收三个参数： type：div config：节点属性，诸如className，id，key，ref children 来看一个简单的JSX被babel之后： this.ref = ref} key={1}> Hello World React.createElement('div', { className: '111', id: 'leo', ref: ref => this.ref = ref, key: 1 }, 'Hello World') 如果Hello World是多个复杂节点呢 this.ref = ref} key={1}> Hello World1 Hello World2 React.createElement('div', { className: '111', id: 'leo', ref: ref => this.ref = ref, key: 1 }, React.createElement('div', null, 'Hello World1'), React.createElement('div', null, 'Hello World2'), ) 从这里看出createElement的第三个参数children其实是个不定参数 createElement的主要流程 从config中获取保留字段key，ref，self， source 除了保留字段，其他属性从config赋值到props。tips：props为何物？const props = {} 处理不定参数children，通过arguments，赋值到props.children 获取type.defaultProps，当props[propName]为undefined时进行赋值 type.defaultProps是什么？ 普通节点是没有defaultProps的，只有组件才会有，如下： class App extends React.Component { render () { return Hello World } } App.defaultProps = { name: 'leo' } createElement功能 createElement其实就是个创建virtual Dom的函数Virtual Dom的结构是怎样的？ { $$typeof: 0xeac7, type: 'div' 或者 App， key: '1', ref: ref => this.ref = ref, props: { className: '111', id: 'leo', name: 'leo', children: [ { $$typeof: 0xeac7, type: 'div', props: { children: ['Hello World'] } } ] } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-12 11:37:19 "},"knowledge/react/theory/5/1.html":{"url":"knowledge/react/theory/5/1.html","title":"React Component","keywords":"","body":" React中PureComponent的实现： // 以下做的都是继承功能，让 PureComponent 继承自 Component function ComponentDummy() {} ComponentDummy.prototype = Component.prototype; function PureComponent(props, context, updater) { this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue; } const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy()); pureComponentPrototype.constructor = PureComponent; Object.assign(pureComponentPrototype, Component.prototype); // 通过这个变量区别下普通的 Component pureComponentPrototype.isPureReactComponent = true; Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-12 14:00:33 "},"knowledge/react/theory/6/1.html":{"url":"knowledge/react/theory/6/1.html","title":"React Ref的实现原理","keywords":"","body":" ref的三种用法 string模式的已被废弃 1. 回调函数模式 ref = { el => this.el = el } 2. createRef this.ref = React.createRef() ref = {this.ref} 3. forwardRef React.forwardRef((props, ref) => ( )) createRef function createRef () { const refObject = { current: null } return refObject } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-12 14:08:59 "},"knowledge/react/theory/7/1.html":{"url":"knowledge/react/theory/7/1.html","title":"React Children的实现细节","keywords":"","body":" React.Children.map的主要功能 三个参数：children，func，context 主要功能：使用上下文context对每个children执行func 返回结果的特殊处理，返回结果是数组，拍平 如何拍平？遍历每一项执行mapIntoWithKeyPrefixInterval 两个问题 React.Children.map的第一个参数children允许哪几种类型？ 为什么执行完回调的结果mappedChild，判断是还要进行mapIntoWithKeyPrefixInternal 解答 React.Children.map 就是ReacChildren.js中的mapChildren函数，主要流程如下： mapChildren函数： 1. 定义result，const result = [] 2. mapIntoKeyPrefixInternal(children, result, null, func, context) 3. 返回result mapIntoKeyPrefixInternal函数： 1. 生成context：getPooledTraverseContext { result: [], keyprefix: '', func: func, context: null, count: 0 } 2. traverseAllChildrenImpl 遍历children执行func 3. 释放context：releaseTraverseContext 3.1 把context下的属性都置为null，count置为0 3.2 把context放入traverseContextPool，上下文池size为10 traverseAllChildrenImpl函数： 1. children为string，number时：表示是文本节点 2. children为object类型，children.$$typeof为REACT_ELEMENT_TYPE，REACT_PORTAL_TYPE，说明是可以渲染的节点 3. 以上四种情况证明children是可渲染的节点，直接执行mapSingleChildIntoContext 4. children是数组，遍历children，对每个元素来一次traverseAllChildrenImpl 5. children是可迭代数据，调用Symbol.iterator，对每个元素来一次traverseAllChildrenImpl 6. children是object，放弃，非法数据警告 mapSingleChildIntoContext函数： 1. 获取数据：const { result, keyPrefix, func, context } = bookKeeping 2. 执行回调：let mappedChild = func.call(context, child, bookKeeping.count++) 3. 判断结果mappedChild是数组，从mapIntoKeyPrefixInternal对每一项再走一遍 4. mappedChild不是数组，result.push(mappedChild) 为什么在执行完func回调拿到mappedChild，还要对其处理 因为React需要对其进行拍平，比如下面这种场景： React.Children.map(this.props.children, child => [child, child]) 这种情况如果Children是[div1, div2]，map之后的结果为[div1, div1, div2, div2] 性能优化点 const POOL_SIZE = 10; const traverseContextPool = []; function getPooledTraverseContext( mapResult, keyPrefix, mapFunction, mapContext, ) { if (traverseContextPool.length) { const traverseContext = traverseContextPool.pop(); traverseContext.result = mapResult; traverseContext.keyPrefix = keyPrefix; traverseContext.func = mapFunction; traverseContext.context = mapContext; traverseContext.count = 0; return traverseContext; } else { return { result: mapResult, keyPrefix: keyPrefix, func: mapFunction, context: mapContext, count: 0, }; } } function releaseTraverseContext(traverseContext) { traverseContext.result = null; traverseContext.keyPrefix = null; traverseContext.func = null; traverseContext.context = null; traverseContext.count = 0; if (traverseContextPool.length 搞一个traverseContextPool池子，存储traverseContext对象，就不用频繁创建一个有很多属性的对象，很消耗性能 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-13 10:50:19 "},"knowledge/react/theory/8/1.html":{"url":"knowledge/react/theory/8/1.html","title":"React Fiber","keywords":"","body":" Fiber出现的背景 Stack reconciler的工作流程很像函数的调用过程。 父组件里调用子组件，可以类比为函数的出递归 对于特别庞大的vDOM树来说，reconciler过程会很长，超过16ms reconciler期间，主线程是被js占用的，因为任何交互，布局，渲染都会停止，给用户卡了的感觉 React在进行组件渲染时，从setState到渲染完成整个过程是同步的 如果渲染的组件比较大，js执行会占据主线程事件比较长，导致react在动画，手势等应用中效果比较差 Fiber实现原理 实现自己的组件调用栈，以链表的形式遍历组件树，可以灵活的暂停，继续和丢弃执行的任务。 Fiber其实是一种数据结构： const fiber = { stateNode, child, sibling, return, } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-13 17:38:44 "},"knowledge/react/theory/9/1.html":{"url":"knowledge/react/theory/9/1.html","title":"React如何自定义实现requestIdleCallback","keywords":"","body":" 为什么React放弃使用原生requestIdleCallback? 了解几个名称：FPS：frame per second，每秒的帧数 帧的几个问题 setTimeout(callback) 和 setInterval(callback) 实现原理 react使用requestAnimationFrame + MessageChannel 实现requestIdleCallback的polyfill版本： let frameDeadline let activeFrameTime = 16 let channel = new MessageChannel() let port = channel.port2 channel.port1.onmessage = () => { const currentTime = performance.now() console.log('当前时间:', currentTime) console.log('当前帧剩余时间:', frameDeadline - currentTime) } const startTime = performance.now() const requestAnimationFrameCircle = () => { requestAnimationFrame(timestamp => { frameDeadline = timestamp + activeFrameTime port.postMessage(undefined) if (performance.now() - startTime Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-31 20:17:06 "},"knowledge/react/redux/":{"url":"knowledge/react/redux/","title":"Redux实现","keywords":"","body":"Redux原理 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-20 10:56:55 "},"knowledge/react/redux/0/0.html":{"url":"knowledge/react/redux/0/0.html","title":"Redux的设计思路及实现","keywords":"","body":"Redux的设计思路及实现 Redux的定位 Predictable state container for JavaScript apps js应用的可预测状态容器 背景 导致数据结构更新的来源很丰富：事件，ajax，路由等 每个来源提供的数据结构不统一 action是什么？ action的功能 把数据从应用传到store的有效载荷，是store数据的唯一来源 action规范 约定action内必须有type字段表示将要执行的动作 尽量减少在action中传递数据 大应用中action往往拆分到单独的文件中 Redux的简单实现 function createStore (reducer, initState) { let state = initState let listeners = [] function subscribe (listener) { listeners.push(listener) return unsubscribe () { const index = listeners.indexOf(listener) listeners.splice(index, 1) } } function dispatch (action) { state = reducer(state,action) for (let listener of listeners) { listener(state) } } function getState () { return state } return { dispatch, subscribe, getState } } 为什么会有reducer action只是描述了有事情发生，并没有描述应用如何更新state，reducer才是真正改变state的地方 reducer内容多了之后需要进行拆分成多个文件，然后有需要combineReducers成一个 combineReducers的原理是什么呢？ 多个reducer和initState有个要求： { counter: function (state, action) {}, info: function (state, action) {} } { counter: {}, info: {} } combineReducers的实现： function combineReducers (reducers) { const keys = Object.keys(reducers) return combine (state, action) { for (ley key of keys) { const reducer = reducers[key] const prevState = state[key] const nextState = reducer(prevState, action) state[key] = nextState } return state } } 中间件扩展dispatch 中间件的最原始实现方法： let next = store.dispatch function log () { const prevState = store.getState() next() const nextState = store.getState() } 考虑以下几个场景： 多个中间件时：next需要提取到参数 中间件作为单独文件存储，store需要提取到参数 const log = store => next => action => { const prevState = store.getState() next(action) const nextState = store.getState() } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-21 16:12:53 "},"knowledge/react/redux/3/1.html":{"url":"knowledge/react/redux/3/1.html","title":"Redux的设计思路","keywords":"","body":"为什么要有action？ 每个web应用都至少对应一个数据结构，而导致这个数据结构状态更新的来源很丰富；光是用户对视图层的操作（dom事件）就有几十种，此外还有ajax获取数据，路由/hash状态变化的记录和跟踪等。 痛点： 导致数据更新的来源很丰富。 每个来源提供的数据结构并不统一。 来源萃取工作：action预处理函数在web应用中所有的数据与状态的变化，几乎都来自事件。action跟event并不等同，只在e.keyCode等于回车键或者取消键时，才触发一类action。action函数必须返回一个带type属性的plain object。 为什么要有reducer？ action未必产生了可以直接合并到全局对象的数据与结构，甚至可能只是提供了线索。reducer：数据再处理函数 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-20 17:35:48 "},"knowledge/react/redux/1/1.html":{"url":"knowledge/react/redux/1/1.html","title":"Redux中store的数据结构是如何存储的？","keywords":"","body":" 解答 state是如何存储的？ createStore函数内部有个currentState属性 外部访问不到state，获取通过store.getState方法获取state，其实就是利用了必报 state的数据结构是怎样的？ 初始值是preloadState，preloadState的结构即为state结构 state如果改变？ 通过dispatch函数改变state，接收一个action: { type: 'add' } dispatch的原理 核心就是这一段： currentState = currentReducer(currentState, action) 通过currentReducer获取新的state Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-20 11:45:48 "},"knowledge/react/redux/2/1.html":{"url":"knowledge/react/redux/2/1.html","title":"state改变之后，如何通知？","keywords":"","body":" 解答 用法： store.subscribe(() => { console.log('subscribe store') }) function subscribe () { nextListeners.push(listener) return function unsubscribe() { const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-20 15:26:02 "},"knowledge/browser/":{"url":"knowledge/browser/","title":"Browser","keywords":"","body":"browser Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 14:18:37 "},"knowledge/browser/1/1.html":{"url":"knowledge/browser/1/1.html","title":"渲染性能","keywords":"","body":"渲染性能 问题： 帧的概念 现在广泛使用的屏幕都有固定的刷新率（最新的一般在60Hz），在两次硬件刷新之间浏览器进行两次重绘是没有意义的只会消耗性能 渲染帧 指浏览器一次完整绘制过程 帧之间的时间间隔是DOM视图更新的最小间隔 是否意味着DOM视图更新最小时间为16ms 主流浏览器屏幕刷新率为60Hz，渲染一帧的时间必须控制在16ms之内才能保证不掉帧 浏览器执行一次渲染主要是做几件事，如下图 浏览器每帧处理流程： input event handlers: 处理事件回调，比如scroll等 requestAnimationFrame: 回调函数在下一次重绘之前执行 Parse HTML: 生成DOM tree Recalc Styles: 级联地生成每个节点地生效样式 Layout: 整合DOM tree和style tree，生成layout tree Update Layer tree: 解析层叠上下文，生成layer tree Paint: 各层分别进行绘制 Composite: 合成各层的渲染结果 掉帧的概念 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 11:57:42 "},"knowledge/browser/2/1.html":{"url":"knowledge/browser/2/1.html","title":"cookie","keywords":"","body":"cookie 为什么需要cookie http是无状态的，每次用户请求到达服务端，服务器都不知道用户是谁，是否登陆过 cookie的构成 author=leo; 键值对 expires=Fri, 31 Dec 9999 23:59:59 GMT; 失效时间 path=/; 控制相对路径下可以访问 domain=.foo.com\"; 控制相对域名可以访问 httpOnly=true; 是否只用于服务端传输，document.cookie不可取 Secure=true; 表示只会发送给https的主机 SameSite=true; 限制跨站携带cookie cookie的安全隐患 cookie是可以被篡改的，curl，nodejs等都可以发起http请求，可以设置任何头字段，容易被其欺骗 cookie的弊端 浏览器的每次请求都会携带cookie数据，会到来额外的性能开销 Cookie明文传输，安全性成问题 Cookie大小限制在4KB左右，复杂的存储需求不够用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 22:03:55 "},"knowledge/browser/0/1.html":{"url":"knowledge/browser/0/1.html","title":"DOMContentLoaded全面解析","keywords":"","body":" DOMContentLoaded 初始HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发 什么时候算是文档加载完？ 同步javascript会暂停DOM的解析 document.addEventListener('DOMContentLoaded', function () { console.log('DOMContentLoaded:', (Date.now() - domStart)) }) const start = Date.now() while (true) { const end = Date.now() if (end - start > 5000) { break } } console.log('script loaded!') 可以发现当时间是5000时，DOMContentLoaded的时间为5048，而while的时间为1000时，DOMContentLoaded的时间为1048所以：同步的JS文档阻塞了DOM的解析 async 和 defer对于DOMContentLoaded的影响 document.addEventListener('DOMContentLoaded', function () { console.log('DOMContentLoaded:', (Date.now() - domStart)) }) const start = Date.now() while (true) { const end = Date.now() if (end - start > 5000) { break } } console.log('script loaded!') 出现了两种不同情况： async async是异步加载，加载完成便执行 document.addEventListener('DOMContentLoaded', ...)在前面，DOMContentLoaded 马上执行 在前面，就看js的下载速度了，在执行DOMContentLoaded之前下载完成，DOMContentLoaded的时间就是5048 defer 该属性用来通知浏览器该脚本将在文档完成解析后，触发DOMContentLoaded事件前执行 所以这里DOMContentLoaded时间是5048 readyState readyState的三种状态： loading interactive complete readyState跟DOMContentLoaded的关联 DOMContentLoaded事件必须是在document.readyState为loading时绑定才有效 const script = document.createElement('script') script.src=\"./test.js\" document.body.appendChild(script) console.log('test.js load') document.addEventListener('DOMContentLoaded', function () { console.log('DOMContentLoaded') }) 这个🌰可以看到：DOMContentLoaded事件未被执行 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-28 18:06:20 "},"knowledge/browser/3/1.html":{"url":"knowledge/browser/3/1.html","title":"DOMContentLoaded全面解析","keywords":"","body":" DOMContentLoaded 初始HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发 什么时候算是文档加载完？ 同步javascript会暂停DOM的解析 document.addEventListener('DOMContentLoaded', function () { console.log('DOMContentLoaded:', (Date.now() - domStart)) }) const start = Date.now() while (true) { const end = Date.now() if (end - start > 5000) { break } } console.log('script loaded!') 可以发现当时间是5000时，DOMContentLoaded的时间为5048，而while的时间为1000时，DOMContentLoaded的时间为1048所以：同步的JS文档阻塞了DOM的解析 async 和 defer对于DOMContentLoaded的影响 document.addEventListener('DOMContentLoaded', function () { console.log('DOMContentLoaded:', (Date.now() - domStart)) }) const start = Date.now() while (true) { const end = Date.now() if (end - start > 5000) { break } } console.log('script loaded!') 出现了两种不同情况： async async是异步加载，加载完成便执行 document.addEventListener('DOMContentLoaded', ...)在前面，DOMContentLoaded 马上执行 在前面，就看js的下载速度了，在执行DOMContentLoaded之前下载完成，DOMContentLoaded的时间就是5048 defer 该属性用来通知浏览器该脚本将在文档完成解析后，触发DOMContentLoaded事件前执行 所以这里DOMContentLoaded时间是5048 readyState readyState是一个只读属性readyState的三种状态： loading interactive complete readyState改变的事件：document.onreadystatechange readyState跟DOMContentLoaded的关联 DOMContentLoaded事件必须是在document.readyState为loading时绑定才有效 const script = document.createElement('script') script.src=\"./test.js\" document.body.appendChild(script) console.log('test.js load') document.addEventListener('DOMContentLoaded', function () { console.log('DOMContentLoaded') }) 这个🌰 可以看到：DOMContentLoaded事件未被执行 readyState和DOMContentLoaded执行顺序： readyState: loading ↓ readyState: interctive ↓ DOMContentLoaded事件 ↓ readyState: complete ↓ load事件 js代码放在文档最后 此时js是不需要像下面这样写的 $(document).ready(function() { // 少年的你，代码写在这里... }); 其实js在文档最后，文档已经解析好了，所以只需要像下面这样写就行了： (function() { // 这里代码... })(); 优点是：执行时机更快 readyState现在还有啥锤子用？ 判断时机为loading，绑定DOMContentLoaded事件 if (document.readyState != 'loading') { init(); } else { window.addEventListener(\"DOMContentLoaded\", function () { init(); }); } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-31 16:47:34 "}}