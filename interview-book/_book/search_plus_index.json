{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:41:25 "},"knowledge/browser/":{"url":"knowledge/browser/","title":"Browser","keywords":"","body":"browser Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 14:18:37 "},"knowledge/browser/1/1.html":{"url":"knowledge/browser/1/1.html","title":"渲染性能","keywords":"","body":"渲染性能 问题： 帧的概念 现在广泛使用的屏幕都有固定的刷新率（最新的一般在60Hz），在两次硬件刷新之间浏览器进行两次重绘是没有意义的只会消耗性能 渲染帧 指浏览器一次完整绘制过程 帧之间的时间间隔是DOM视图更新的最小间隔 是否意味着DOM视图更新最小时间为16ms 主流浏览器屏幕刷新率为60Hz，渲染一帧的时间必须控制在16ms之内才能保证不掉帧 浏览器执行一次渲染主要是做几件事，如下图 浏览器每帧处理流程： input event handlers: 处理事件回调，比如scroll等 requestAnimationFrame: 回调函数在下一次重绘之前执行 Parse HTML: 生成DOM tree Recalc Styles: 级联地生成每个节点地生效样式 Layout: 整合DOM tree和style tree，生成layout tree Update Layer tree: 解析层叠上下文，生成layer tree Paint: 各层分别进行绘制 Composite: 合成各层的渲染结果 掉帧的概念 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 11:57:42 "},"knowledge/browser/2/1.html":{"url":"knowledge/browser/2/1.html","title":"cookie","keywords":"","body":"cookie 为什么需要cookie http是无状态的，每次用户请求到达服务端，服务器都不知道用户是谁，是否登陆过 cookie的构成 author=leo; 键值对 expires=Fri, 31 Dec 9999 23:59:59 GMT; 失效时间 path=/; 控制相对路径下可以访问 domain=.foo.com\"; 控制相对域名可以访问 httpOnly=true; 是否只用于服务端传输，document.cookie不可取 Secure=true; 表示只会发送给https的主机 SameSite=true; 限制跨站携带cookie cookie的安全隐患 cookie是可以被篡改的，curl，nodejs等都可以发起http请求，可以设置任何头字段，容易被其欺骗 cookie的弊端 浏览器的每次请求都会携带cookie数据，会到来额外的性能开销 Cookie明文传输，安全性成问题 Cookie大小限制在4KB左右，复杂的存储需求不够用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 22:03:55 "},"knowledge/browser/3/1.html":{"url":"knowledge/browser/3/1.html","title":"DOMContentLoaded全面解析","keywords":"","body":" DOMContentLoaded 初始HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发 什么时候算是文档加载完？ 同步javascript会暂停DOM的解析 document.addEventListener('DOMContentLoaded', function () { console.log('DOMContentLoaded:', (Date.now() - domStart)) }) const start = Date.now() while (true) { const end = Date.now() if (end - start > 5000) { break } } console.log('script loaded!') 可以发现当时间是5000时，DOMContentLoaded的时间为5048，而while的时间为1000时，DOMContentLoaded的时间为1048所以：同步的JS文档阻塞了DOM的解析 async 和 defer对于DOMContentLoaded的影响 document.addEventListener('DOMContentLoaded', function () { console.log('DOMContentLoaded:', (Date.now() - domStart)) }) const start = Date.now() while (true) { const end = Date.now() if (end - start > 5000) { break } } console.log('script loaded!') 出现了两种不同情况： async async是异步加载，加载完成便执行 document.addEventListener('DOMContentLoaded', ...)在前面，DOMContentLoaded 马上执行 在前面，就看js的下载速度了，在执行DOMContentLoaded之前下载完成，DOMContentLoaded的时间就是5048 defer 该属性用来通知浏览器该脚本将在文档完成解析后，触发DOMContentLoaded事件前执行 所以这里DOMContentLoaded时间是5048 readyState readyState是一个只读属性readyState的三种状态： loading interactive complete readyState改变的事件：document.onreadystatechange readyState跟DOMContentLoaded的关联 DOMContentLoaded事件必须是在document.readyState为loading时绑定才有效 const script = document.createElement('script') script.src=\"./test.js\" document.body.appendChild(script) console.log('test.js load') document.addEventListener('DOMContentLoaded', function () { console.log('DOMContentLoaded') }) 这个🌰 可以看到：DOMContentLoaded事件未被执行 readyState和DOMContentLoaded执行顺序： readyState: loading ↓ readyState: interctive ↓ DOMContentLoaded事件 ↓ readyState: complete ↓ load事件 js代码放在文档最后 此时js是不需要像下面这样写的 $(document).ready(function() { // 少年的你，代码写在这里... }); 其实js在文档最后，文档已经解析好了，所以只需要像下面这样写就行了： (function() { // 这里代码... })(); 优点是：执行时机更快 readyState现在还有啥锤子用？ 判断时机为loading，绑定DOMContentLoaded事件 if (document.readyState != 'loading') { init(); } else { window.addEventListener(\"DOMContentLoaded\", function () { init(); }); } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-31 16:47:34 "},"knowledge/browser/4/1.html":{"url":"knowledge/browser/4/1.html","title":"web通信","keywords":"","body":" web通信方式 跨文档通信：window.postMessage 通道通信：MessageChannel postMessage跨文档通信 三个参数： message：将要发送的数据 targetOrigin：目标源 transfer：Transfer对象（ArrayBuffer ｜ MessagePort ｜ ImageBitmap） // 父html // 1.html document.forms.addEventListener('submit', () => { const message = document.querySeletor('input[type=\"text\"]').value window.parent.frames[1].postMessage(message) }) window.addEventListener('message', msg => { alert('接收到消息：' + msg.data) }) otherWindow.postMessage(message, targetOrigin, [transfer]) otherWindow： iframe的contentWindow属性 window.open返回的窗口对象 window.frames targetOrigin: 同源（协议，域名，端口）或者 * 跨文档通信 + 通道通信 通过postMessage来传输channel.port // 1.html const mc = new MessageChannel() mc.port2.onmessage = data => { console.log('channel resceive message: ', data) } window.parent.postMessage('来自1.html的消息', '*', [mc.port1]) // test.html window.onmessage = msg => { window.frames[1].postMessage('来自test.html的消息', '*', msg.ports) } // 2.html window.onmessage = msg => { msg.ports[0].postMessage('hello from 2.html') } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-01 17:32:33 "},"test/vue/":{"url":"test/vue/","title":"vue","keywords":"","body":"这里是vue专题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:11:09 "},"test/vue/1/1.html":{"url":"test/vue/1/1.html","title":"父组件监听子组件的生命周期","keywords":"","body":" 解法1: @hook @hook:搭配任意钩子函数，会在子组件触发相应生命周期钩子函数时回调父组件这个函数 解法2: $emit 这种方式比较蠢，而且是需要劳动力堆积的 mounted () { this.$emit('mounted') } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:36:45 "},"test/vue/2/1.html":{"url":"test/vue/2/1.html","title":"$set解决新增属性不能相应的问题","keywords":"","body":" 解答： 是因为Vue在实例化的过程中就需要对data中的数据使用defineProperty方法来定义存取器实现的响应式。而直接新增属性因为仍是值属性，所以是不能实现响应式的 源码实现 const isValidArrayIndex = index => { return index > 0 && Math.floor(index) === index && isFinite(index) } exprt function set (target, key, val) { if (Array.isArray(target) && isValidArrayIndex(key)) { target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } if (key in target && !(key in target.prototype)) { target[key] = val return val } const __ob__ = target.__ob__ if (!__ob__) { target[key] = val return val } else { defineReactive(__ob__.value, key, val) __ob__.dep.notify() return val } } set分为四步骤： 判断是否为数组，以及索引是否合法 Array.isArray判断target是否为数组 索引是否合法：index > 0 && Math.floor(index) === index && isFinite(index) 数组可能不够长，先把数组扩充下：target.length = Math.max(target.length, key) 通过splice往数组中添加：target.splice(key, 1, val) 判断target对象下是否已经该属性key 存在的话就是修改操作，直接target[key] = val，通过setter存取器触发notify target是否已被响应式 否：不管响应式，target[key] = val完事 已设置响应式，defineReactive(ob.value, key, val), ob.dep.notify()触发更新 defineProperty的缺点 从这个问题可以看出：defineProperty实现响应式，需要在vue实例化时对所有属性进行重定义，不然的话就不能实现响应式有点类似事件绑定时，对单个节点 Proxy的使用 let obj = { a: 1, b: 2 } let obj1 = new Proxy(obj, { get (obj, prop) { console.log(`正在获取属性：${prop}，值为：${obj[prop]}`) return obj[prop] } }) obj1.a obj1.b Proxy类似事件委托，把属性访问委托到另一个对象上，可是不具体关心是什么属性，所以在Vue实例化阶段减少了对data下所有属性进行defineProperty定义存取器 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:21:01 "},"system/":{"url":"system/","title":"知识体系架构","keywords":"","body":"知识体系架构 HTML核心技巧 HTML语义话 埋点，监控，日志分析 LocalStorage扩容 跨域问题解决方案 漏洞攻防 CSS核心技巧 CSS经典布局 CSS高级绘制 CSS分层理论 CSS魔术师 Houdini CSS矩阵与高性能渲染 CSS WorkFlow js核心技能 基本数据类型，变量提升 函数与对象，构造函数 闭包，this和作用域 call，apply，bind 继承 语句与表达式 高阶函数 js典型错误分析 原型链与原型对象 递归与尾递归 js函数式编程 范畴论，函数式编程基础理论 纯函数，柯里化，函数组合 高阶函数，尾调用优化，闭包 范畴与容器，函子，AP因子，IO ES5核心技术 深入this解析 作用域与闭包 值传递与引用传递分析 深入分析原型与原型链 微任务，宏任务，同步队列，异步队列 暂时性死区 GC 执行堆栈 ES6核心知识 const，let，解构，字符串，数组，对象，函数 yield与遍历 class，set，map export/import 与 Module 异步 修饰 Symbol新特性详解 ES7到ES10 Array.flat / flatMap / array.includes Object.entries / Object.values / fromEntries String.padStart / trimStart / trimStart Trailing coma 模版字面量 异步迭代器 Promise.finally 对象销毁 jquery经典源码解读 重写与多态实现分析 链式调用 二进制运算的性能提升 Hook应用 参数映射分析 ready实现分析 typescript上手 数据类型 枚举 接口 类 函数 泛型 类型断言与类型守卫，类型兼容性 高级类型之交叉类型，联合类型，类型别名 装饰器，Reflect Metadata 赋值断言，is关键字，可调用类型注解和类型推导 高级类型索引类型，映射类型，条件类型，强大的infer关键字 模块与命名空间，声明文件编写 常用工具类型 typescript深入 ts与工程化 ts与React实践 ts与Vue实践 ts的编译原理 编写ts transformer plugin linux linux 环境安装与配置 web程序员必会的linux命令 文件管理 用户管理 网络管理 进程管理 linux安全加固 代码与反向代理服务器 反响代理实战 Nodejs基础 非阻塞IO EventLoop 模块，第三方模块，自定义模块 Get/Post 全局对象，常用工具 Net，FS，Stream，Buffer Http 核心API，回调函数，路由 进程与线程 Promise，Async/Await Nodejs进阶 Koa，Express，Egg，Hapi 路由，参数，中间件，模版引擎，静态文件，重定向，cookie，session 中间件原理 Restful API设计 Cookie，Token，鉴权 Linux下的Nodejs服务管理：pm2 Node异步IO原理及优化 内存管理机制及优化 大规模Node站点结构原理分析 Node编码规范 规避Node内存泄漏及相关工具 Node集群管理 线上部署与压力测试 BFF架构 Node源码深入 Node源码解析 手写Koa2源码 手写中间件机制 手写MVC开发框架 网络协议 协议 缓存机制 https协议分析 http2协议分析 http3协议分析 tcp协议栈 三次握手与四次挥手 拥塞控制（慢开始，快速重传） 流量控制（华东窗口） Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-31 17:48:44 "},"test/":{"url":"test/","title":"每日一题","keywords":"","body":"每日一题 一天一题练习 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:33:17 "},"interview/":{"url":"interview/","title":"每日一题","keywords":"","body":"每日一题 一天一题练习 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:33:17 "},"interview/vue/":{"url":"interview/vue/","title":"vue","keywords":"","body":"这里是vue专题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:11:09 "},"interview/vue/1/1.html":{"url":"interview/vue/1/1.html","title":"父组件监听子组件的生命周期","keywords":"","body":" 解法1: @hook @hook:搭配任意钩子函数，会在子组件触发相应生命周期钩子函数时回调父组件这个函数 解法2: $emit 这种方式比较蠢，而且是需要劳动力堆积的 mounted () { this.$emit('mounted') } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:36:45 "},"interview/vue/2/1.html":{"url":"interview/vue/2/1.html","title":"$set解决新增属性不能相应的问题","keywords":"","body":" 解答： 是因为Vue在实例化的过程中就需要对data中的数据使用defineProperty方法来定义存取器实现的响应式。而直接新增属性因为仍是值属性，所以是不能实现响应式的 源码实现 const isValidArrayIndex = index => { return index > 0 && Math.floor(index) === index && isFinite(index) } exprt function set (target, key, val) { if (Array.isArray(target) && isValidArrayIndex(key)) { target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } if (key in target && !(key in target.prototype)) { target[key] = val return val } const __ob__ = target.__ob__ if (!__ob__) { target[key] = val return val } else { defineReactive(__ob__.value, key, val) __ob__.dep.notify() return val } } set分为四步骤： 判断是否为数组，以及索引是否合法 Array.isArray判断target是否为数组 索引是否合法：index > 0 && Math.floor(index) === index && isFinite(index) 数组可能不够长，先把数组扩充下：target.length = Math.max(target.length, key) 通过splice往数组中添加：target.splice(key, 1, val) 判断target对象下是否已经该属性key 存在的话就是修改操作，直接target[key] = val，通过setter存取器触发notify target是否已被响应式 否：不管响应式，target[key] = val完事 已设置响应式，defineReactive(ob.value, key, val), ob.dep.notify()触发更新 defineProperty的缺点 从这个问题可以看出：defineProperty实现响应式，需要在vue实例化时对所有属性进行重定义，不然的话就不能实现响应式有点类似事件绑定时，对单个节点 Proxy的使用 let obj = { a: 1, b: 2 } let obj1 = new Proxy(obj, { get (obj, prop) { console.log(`正在获取属性：${prop}，值为：${obj[prop]}`) return obj[prop] } }) obj1.a obj1.b Proxy类似事件委托，把属性访问委托到另一个对象上，可是不具体关心是什么属性，所以在Vue实例化阶段减少了对data下所有属性进行defineProperty定义存取器 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:21:01 "},"interview/js/":{"url":"interview/js/","title":"js","keywords":"","body":"js高频题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-02 15:11:57 "},"interview/js/1/1.html":{"url":"interview/js/1/1.html","title":"写一个深拷贝，考虑 正则，Date这种类型的数据","keywords":"","body":" 解答 方案一：JSON.parse(JSON.stringify(source)) 缺点： undefined, 函数，symbol值，在序列化过程中会被忽略 不能处理Bigint类型的数据和循环引用，会报错 Map，Set，RegExp类型的数据，会引用丢失，变成空值 Date类型的数据会被当作字符串处理 NaN，Infinity，null都会被当作null Map/Set/WeakMap/WeakSet 仅会序列化可枚举的数据 方案二：判断类型为object 判断参数类型为object后，复制键/值到目标对象，否则返回源对象 function deepClone (source) { if (typeof source === 'object') { const result = Array.isArray(source) ? [] : {} for (let key in source) { const prop = source[key] if (typeof prop === 'object') { result[key] = deepClone(prop) } else { result[key] = prop } } return result } return source } 方案三：Reflect代理法 Reflect.ownKeys可以获取不可枚举属性，Object.keys只能列举可枚举属性 function deepClone (obj) { if (typeof obj === 'object') { let cloneObj = Array.isArray(obj) ? [] : {} Reflect.ownKeys(cloneObj).forEach(key => { const prop = obj[key] cloneObj[key] = typeof prop === 'object' ? deepClone(prop) : obj[key] }) return cloneObj } return obj } 方案四：终极方案 方案二和方案三的思想都是遍历属性，然后重新赋值，但是仍然解决不了Map，Set，RegExp，Date之类的问题深拷贝的几个特殊类型： Date Map Set RegExp Function Symbol 日期拷贝 let source = new Date() let copy = new date.constructor(source) Map拷贝 let source = new Map([['name', 'xuqiang'], ['age', 29]]) let copy = new Map() source.forEach((val, key) => { copy.set(key, val) }) Set拷贝 let source = new Set([1, 2, 3, 4, 5]) let copy = new Set() source.forEach(item => { copy.add(item) }) RegExp拷贝 let source = /a/ let copy = new source.constructor(source.source, /\\w*$/.exec(source)) copy.lastIndex = source.lastIndex Symbol拷贝 let source = { [Symbol('name')]: Symbol('xuqiang') } let copy = {} let symbols = Object.getOwnPropertySymbols(source) for (let symbol of symbols) { copy[symbol] = source[symbol] } 函数的拷贝 函数转字符串 function func (name, age) { console.log(name, age) } const funcString = func.toString() 字符串转函数 // 方案一: const func = eval(`(${funcString})`) // 方案二： const func = new Function('return ' + funcString)() 匹配参数和函数体 匹配参数 const paramReg = /(?匹配函数体 const bodyReg = /(?函数拷贝的两种方法 eval const funcString = func.toString() const funcCopy = eval(`(${funcString})`) new Function ``` const paramReg = /(?(?=)\\s[{|=>])/ const bodyReg = /(? const param = paramReg.exec(funcString) const bodyReg = bodyReg.exec(funcString) if (body) { if (param) { const params = param[0].split(',') new Function (...params, body[0]) } else { new Function (body[0]) } } ``` Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-02 20:25:50 "}}