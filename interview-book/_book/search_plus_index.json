{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球 🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-27 10:37:32 "},"interview/webpack/":{"url":"interview/webpack/","title":"webpack","keywords":"","body":"webpack 每日一题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-10 10:49:13 "},"interview/webpack/1/1.html":{"url":"interview/webpack/1/1.html","title":"webpack做过哪些优化？开发效率，打包策略等","keywords":"","body":" 解答 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-10 16:58:14 "},"interview/webpack/2/1.html":{"url":"interview/webpack/2/1.html","title":"HtmlWebpackPlugin 的配置","keywords":"","body":" 解答 filename new HtmlWebpackPlugin({ filename: 'order/index.html' }) title new HtmlWebpackPlugin({ title: 'Hello Webpack' }) template new HtmlWebpackPlugin({ template: 'template.html' }) templateContent inline html templateParameters new HtmlwebpackPlugin({ templateParameters: { __base_style__: ' .app { red } ' } }) inject inject: true | false | head | body true 跟 body 效果一样：在body末尾注入 false：不注入 js head：在 head 中注入 js publicPath 跟 output publicPath，在输出 js 路径加入 publicPath scriptLoading blocking： 正常注入 js defer：注入 js 添加 defer 属性 scriptLoading: blocking | defer favicon 注入 favicon，⚠️ ：需要是本地的，会带上 publicPath 前缀 minify 压缩，true | false hash js css icon 都会带上 ?hash，可有效清楚缓存 chunks 注入哪些 js chunks: ['main'] chunksSortMode // 插入 html 的很多 chunks，如何排序 chunks: ['index', 'main'], chunksSortMode: 'auto | manual' excludeChunks 不包含的 chunks Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-09 15:03:00 "},"interview/webpack/3/1.html":{"url":"interview/webpack/3/1.html","title":"有哪些有用的 webpack 插件","keywords":"","body":" Loader loader 的使用方式 如果不在 webpack.config.js 中配置 loader，那么怎么使用呢？ require('style-loader!css-loader!./index.css') file-loader 处理文件 把原图片拷贝到 dist，文件名也会变 可以处理任意二进制数据 require('file-loader?outputPath=./images!./1.jepg') { test: /.png/, use: { loader: 'file-loader', options: { outputPath: '/images' } } } 全局注入方案二：expose-loader 这样使用，需要手动 import jquery from 'jquery'；当 require 解析到这个 import 时，就会走 expose-loader但是好处是：只会在一个文件中打包 { test: require.resolve('jquery'), use: { loader: 'expose-loader', options: { exposes: { globalName: '$', override: true } } } } babel-loader babel非常慢，优化主要通过以下两点： exclude 或者 include 精确解析 cacheDirectory: true 开启缓存 { test: /.js$/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } } cache-loader { test: /\\.js$/, use: [ 'cache-loader', 'babel-loader' ], include: path.resolve('src') } css-loader css-loader 解释 @import 和 url() Plugins CleanWebpackPlugin 开发时 dist 目录不断产出，文件很多很乱 const CleanWebpackPlugin = require('clean-webpack-plugin') new CleanWebpackPlugin(['dist']) 不带参数的话，会把 output path 作为目标目录 全局注入方案一：ProvidePlugin 缺点：比如 $: jquery，使用到 $ 的模块都会打包jquery，造成重复打包 配置 noParse 也没用 const webpack = require('webpack') new webpack.ProvidePlugin({ $: 'jquery' }) extract-text-webpack-plugin const ExtractTextWebpackPlugin = require('extract-text-webpack-plugin') { test: /\\.css$/, use: ExtractTextWebpackPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } plugins: [ new ExtractTextPlugin('style.css'), ] 多个 css 模块 如何处理？ const lessExtractPlugin = new ExtractTextWebpackPlugin('css/less.css') const cssExtractPlugin = new ExtractTextWebpackPlugin('css/css.css') const sassExtractPlugin = new ExtractTextWebpackPlugin('css/sass.css') // 加载器以此类推 { test: /\\.css$/, use: cssExtractPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } plugins: [ lessExtractPlugin, cssExtractPlugin, sassExtractPlugin, ] CopyWebpackPlugin const CopyWebpackPlugin = require('copy-webpack-plugin') new CopyWebpackPlugin({ from: path.join(__dirname, 'public'), to: path.join(__dirname, 'dist') }) AggressiveSplittingPlugin new webpack.optimize.AggressiveSplittingPlugin({ minSize: 30000, maxSize: 50000, chunkOverhead: 0, }) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-09 19:41:18 "},"interview/webpack/4/1.html":{"url":"interview/webpack/4/1.html","title":"webpack动态导入 import 是如何实现的","keywords":"","body":" 解答 动态导入 import 使用 // index.js document.getElementById('app').addEventListener('click', () => { import('./console.js').then(_console => { _console.log('clicked') }) }) //console.js function log (msg) { console.log(`system log: ${msg}`) } export { log } webpack 打包之后的样子 // main.js { './index.js': function (module, __webpack_exports__, __webpack_require__) { document.getElementById('app').addEventListener('click', () => { __webpack_require__.e(0).then( __webpack_require__.bind(null, './console.js') ).then(_console_ => { _console_.log('clicked') }) }) } } // 0.js window.webpackJsonp = window.webpackJsonp || [] window.webpackJsonp.push([ [0], { './console.js': function (module, __webpack_exports__, __webpack_require__) { Object.defineProperty(__webpack_exports__, 'log', { enumerable: true, get: function () { return log } }) function log (msg) { console.log(msg) } } } ]) webpack_require 的实现 (function (modules) { var installedModules = {}; function __webpack_require__ (moduleId) { if (installedModules[moduleId]) { return installedModules[moduleId] } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} } modules[moduleId].call(module, module, module.exports, __webpack_require__) module.l = true return module.exports } })({ './index.js': function (){} }) webpack_require.e的实现 var installedChunks = {} __webpack_require__.e = function requireEnsuer (chunkId) { var promises = [] var installedChunkData = installedChunks[chunkId] if (installedChunkData !== 0) { if (installedChunkData) { promises.push(installedChunkData[2]) } else { var promise = new Promise((resolve, reject) => { installedChunkData = installedChunks[chunkId] = [resolve, reject] }) promises.push((installedChunkdata[2] = promise)) var script = document.createElement('script') script.src = `${chunkId}.js` document.head.appendChild(script) } } return Promise.all(promises) } window.webpackJsonp 是什么？ window.webpackJsonp 是个数组，但是传统 jsonp 应该是调用回调函数，可是打包之后代码为什么是：window.webpackJsonp.push，如何触发回调呢？ var jsonpArray = window.webpackJsonp = window.webpackJsonp || [] var parentJsonpFunction = jsonpArray.push.bind(jsonArray) jsonpArray.push = webpackJsonpCallback for (let jsonp of jsonpArray) { webpackJsonpCallback(jsonp) } 可以看出 window.webpackJsonp.push，如果在main.js已加载的情况下，其实已经是 webpackJsonpCallback 函数了 webpackJsonpCallback 的实现 function webpackJsonpCallback (data) { const chunkIds = data[0] const moreModules = data[1] vat resolves = [] for (let chunkId of chunkIds) { resolves.push(installedChunks[chunkId][0]) installedChunks[chunkId] = 0 } for (let moduleName in moreModules) { modules[moduleName] = moreModules[moduleName] } if (parentJsonpFunction) parentJsonpFunction(data) while (resolves.length) { resolves.shift()() } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-12 16:06:53 "},"interview/webpack/5/1.html":{"url":"interview/webpack/5/1.html","title":"开发一个loader，把代码中的箭头函数编译为普通函数","keywords":"","body":" 解答 const transformer = require(\"@babel/core\"); const t = require('@babel/types') module.exports = function(content, map, meta) { const ArrowFunctionToFunctionPlugin = { visitor: { ArrowFunctionExpression(path) { const ruturnStatement = t.returnStatement(path.node.body) const blockStatement = t.blockStatement([ruturnStatement]) const funcExpr = t.functionExpression(null, path.node.params, blockStatement) path.replaceWith(funcExpr) } } } const result = transformer.transform(content, { plugins: [ArrowFunctionToFunctionPlugin] }) return result.code } loader的配置 resolveLoader: { modules: [path.resolve(__dirname, 'loaders')], extensions: ['.js'], mainFields: ['loader'] } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-13 15:58:45 "},"interview/webpack/6/1.html":{"url":"interview/webpack/6/1.html","title":"tapable 的使用和原理","keywords":"","body":" 解答 SyncHook const { SyncHook } = require('tapable') const queue = new SyncHook(['n', 'a', 's']) queue.tap('1', function (name, age, sex) { console.log(name, age, sex) }) queue.tap('2', function (name, age) { console.log(name, age) }) queue.tap('3', function (name, age) { console.log(name, age) }) queue.call('1', 'xiur', 29, 'man') 自定义实现: class SyncHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (...args) { for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { plugin.apply(this, args) } } } } module.exports = SyncHook SyncBailHook const { SyncBailHook } = require('tapable') const queue = new SyncBailHook(['n', 'a', 's']) queue.tap('1', function (name, age, sex) { console.log(name, age, sex) return 'Wrong' }) queue.tap('2', function (name, age) { console.log(name, age) }) queue.tap('3', function (name, age) { console.log(name, age) }) queue.call('1', 'xiur', 29, 'man') 自定义实现： class SyncBailHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (...args) { for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { let result = plugin.apply(this, args) if (result) { return result } } } } } module.exports = SyncBailHook SyncWaterfallHook const { SyncWaterfallHook } = require('tapable') const queue = new SyncWaterfallHook(['n', 'a', 's']) queue.tap('1', function (name, age, sex) { console.log(name, age, sex) return name + '1' }) queue.tap('2', function (name, age) { console.log(name, age) return name + '2' }) queue.tap('3', function (name, age) { console.log(name, age) return name + '3' }) queue.call('xiur', 29, 'man') 自定义实现： class SyncWaterfallHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (init, ...args) { let current = init for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { current = plugin.apply(this, [current, ...args]) } } } } module.exports = SyncWaterfallHook SyncLoopHook const { SyncLoopHook } = require('tapable') const queue = new SyncLoopHook(['n', 'a', 's']) let count = 3; queue.tap('1', function (name, age, sex) { console.log(count) if (count > 0) { count--; return count } else { return } }) queue.call('xiur', 29, 'man') 自定义实现： class SyncLoopHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (...args) { for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { let result do { result = plugin.apply(this, args) } while (result !== undefined) } } } } module.exports = SyncLoopHook AsyncParalleHook 异步并行加载 // const { AsyncParallelHook } = require('tapable') const AsyncParallelHook = require('./AsyncParallelHook') const hook = new AsyncParallelHook(['name']); console.time('cost'); hook.tapAsync('a', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb(); }, 2000) }) hook.tapPromise('a', name => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve(); }, 4000) }) }) hook.callAsync('a', () => { console.log('done'); console.timeEnd('cost'); }); 自定义实现： class AsyncParallelHook { constructor () { this._plugins = {}; } tapAsync (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback.call(this, ...args, () => { ++this.i; if (this.i >= this._plugins[name].length) { return cb() } }); }) } tapPromise (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { callback.apply(this, args).then(() => { const cb = args.pop(); ++this.i; if (this.i >= this._plugins[name].length) { return cb() } }) }) } callAsync (...args) { this.i = 0; for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { plugin.apply(this, args) } } } } module.exports = AsyncParallelHook AsyncSeriesHook 异步串行加载 const { AsyncSeriesHook } = require('tapable'); const hook = new AsyncSeriesHook(['name']); console.time('cost'); hook.tapAsync('a', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb(); }, 2000); }); hook.tapPromise('a', (name) => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve(); }, 4000); }); }); hook.callAsync('a', () => { console.log('done'); console.timeEnd('cost'); }); 自定义实现： class AsyncSeriesHook { constructor () { this._plugins = {} this.next = this._next.bind(this) } tapAsync (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args, () => this.next(name, cb, [...args, cb])); }) } tapPromise (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args).then(() => this.next(name, cb, [...args, cb])) }) } _next (name, cb, args) { ++this.i; if (this.i >= this._plugins[name].length) { return cb(); } this._plugins[name][this.i].apply(this, args) } callAsync (...args) { this.i = 0 for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName]; if (plugins) { plugins[0].apply(this, args) } } } } module.exports = AsyncSeriesHook AsyncSeriesBailHook 异步串行熔断加载 const { AsyncSeriesHook } = require('tapable'); const hook = new AsyncSeriesHook(['name']); console.time('cost'); hook.tapAsync('a', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb('yes'); }, 2000); }); hook.tapPromise('a', (name) => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve('yes'); }, 4000); }); }); hook.callAsync('a', () => { console.log('done'); console.timeEnd('cost'); }); class AsyncSeriesBailHook { constructor () { this._plugins = {} this.next = this._next.bind(this) } tapAsync (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args, ret => this.next(name, cb, [...args, cb], ret)); }) } tapPromise (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args).then(ret => this.next(name, cb, [...args, cb], ret)) }) } _next (name, cb, args, ret) { ++this.i; if (this.i >= this._plugins[name].length || ret !== undefined) { return cb(); } this._plugins[name][this.i].apply(this, args) } callAsync (...args) { this.i = 0 for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName]; if (plugins) { plugins[0].apply(this, args) } } } } module.exports = AsyncSeriesBailHook Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-16 16:46:33 "},"interview/webpack/7/1.html":{"url":"interview/webpack/7/1.html","title":"style-loader 的使用及原理","keywords":"","body":" style-loader 的作用 把 css 插入 html 开发阶段模块热更新 style-loader 和 css-loader 的关系 style-loader 和 css-loader 经常一起使用，那么不使用 css-loader，只用 style-loader 加载 css 行不行呢？答案是不行的 🙅‍♂️ style-loader 只是把 css 插入 html，但是并不会解析 css 文件 那么 webpack 是不认识 css 文件的，需要 css-loader 来加载 css文件 css-loader 换成 less-loader 也是成立的，其作用就是加载 css 文件 试想一下 实现 style-loader需要解决什么问题 如何拿到 css-loader 解析之后的源码？ 如何避免 css-loader 的重复执行【死循环】？ 如何支持热更新？ 可以实行的一种方案： 每次热更新，比如更新了 index.css，网页端会收到一个补丁包：./node_modules/css-loader/dist/cjs.js!./index.css，网页端收到补丁包，会去更新这个模块 客户端监听 module.hot.accept('./node_modules/css-loader/dist/cjs.js!./index.css', function () {}) 回调函数中，重新获取这个模块然后进行更新 更新过程中，如何找到最初的那个 style 节点，客户端就需要用一个映射来保存 styleInDom，映射的值为更新函数，键是啥？ 加载 index.css 插入到 html，那么 index.css 这个名称就可以作为 key 从 style-loader 的使用分析原理 style-loader 的应用场景： loader: ['style-loader', 'css-loader'] webpack loader 的执行路径： | - style-loader `pitch` | - css-loader `pitch` | - requested module is picked up as a dependency | - css-loader normal execution | - style-loader normal execution css-loader 返回结果分析 css-loader 加载 css 之后，loader 的 source 如下： // Imports var ___CSS_LOADER_API_IMPORT___ = require(\"../node_modules/css-loader/dist/runtime/api.js\"); var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(function(i){return i[1]}); // Module ___CSS_LOADER_EXPORT___.push([module.id, \"nbody {n background: yellow;n}n\", \"\"]); // Exports module.exports = ___CSS_LOADER_EXPORT___; 从这个结果来看，在 style-loader 中需要对 source 进行 require 模块导入，然后才能拿到其中的 css 在 loader 中 require 导入其他模块不规范 过程很复杂 所以采用 pitch 的方式 pitch pitch 可以拦截 loader，pitch 中 return 会导致后续的 loader 不执行 pitch 的写法 module.exports.pitch = function (remainingRequest, precedingRequest, data) { remainingRequest： 剩下的请求 precedingRequest：已处理的请求 data：数据 } style-loader 首先需要拿到 css-loader 的处理结果： module.exports = function (remainingRequest) { const remainingPath = loaderUtils.stringifyRequest(this, `!!${remainingRequest}`) return ` import content from ${remainingPath} ` } 这样就拿到 css-loader 处理之后的数据了。如下： [ 0: [ 0: \"./node_modules/css-loader/dist/cjs.js!./index.css\" 1: \"body { color: red}\", 2: \"\" ], i: (modules, mediaQuery, dedupe) => {}, length: 1 ] 从这个数据中，可以看出：0 可以作为 id，1 可以作为css 模块热更新的写法 webpack.config.js 中配置 devServer devServer: { hot: true } 每个需要支持热更新的模块声明 module.hot.accept if (module.hot) { module.hot.accept('./index.css', function () { console.log('halo! css changed') }) } 可以看出我们的代码中是没有声明 module.hot.accept 的，可是 css 却支持热更新，说明 loader 中注入了accept accept 注入 accept 中重新获取css if (module.hot) { module.hot.accept(remainingPath, function () { try { const newContent = require(remainingPath); // 拿到新的内容，重新走渲染 injectStyle(newContent); } catch (e) { console.log('热更新发生错误：', e) } }) } 这里用try catch包起来，因为如果这个回调里报错，webpack会走 reload 导致页面刷新 利用闭包 哪些变量用到了闭包呢：styleInDom，updater，style function injectStyle (content) { for (let item of content) { const id = item[0]; const updater = styleInDom[id]; const css = item[1]; // 如果已经渲染过，拿到 updater 方法，该方法中利用闭包缓存了 style 节点，替换 style 中内容即可 if (updater) { updater(css); } else { styleInDom[id] = addStyle(css) } } } function addStyle (css) { const style = ducument.createElement('style'); style.appendChild(document.createTextNode(css)); document.head.appendChild(style); return function updater (css) { if (css) { while (style.firstChild) { style.removeChild(style.firstChild); } style.appendChild(document.createTextNode(css)); } else { style.parentNode.removeChild(style); delete styleInDom[id] } } } 这里不管第一次渲染，还是之后的热更新，每次 injectStyle 就行了，传入 css-loader 转换之后的结果 总结 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-20 10:43:13 "},"interview/webpack/8/1.html":{"url":"interview/webpack/8/1.html","title":"如何获取loader的配置参数","keywords":"","body":"module 的三种配置方法 // 方式 1 | 2 { test: /\\.js$/, use | loader: 'myloader' | ['myloader'] } // 方式 3 { test: /\\.js$/, use: { loader: 'myloader', options: { name: 'xiur' } } } webpack 配置本地 loader 的四种方法 方法一： { test: /\\.js$/, loader: path.resolve(__dirname, './loader/myloader.js'), } 方法二： resolveLoader: { alias: { myLoader: path.resolve(__dirname, './loader/myloader.js'), } } 方法三： resolveLoader: { modules: ['node_modules', path.resolve(__dirname, './loader')], } 目录：两种目录都可以 ｜ - node_modules | - myloader.js | - myloader | - index.js 方法四： 4.1 在 loader 目录下执行 npm link 4.2 回到项目目录下 执行 npm link myloader 4.3 在 webpack 配置文件中直接使用 myloader 即可 loader-utils 的使用 const loaderUtils = require('loader-utils'); getOptions 获取配置的 options 参数 loaderUtils.getOptions(this); parseQuery 获取 query 参数，query 是没办法配置的 使用场景：import content from './index.css?param1=xiur&param2=29' loaderUtils.parseQuery(this.resourceQuery) => { param1: 'xiur', param2: 29 } stringifyRequest 1. 利用 remainingRequest 参数获取 loader 链的剩余部分 2. 利用 ‘!!’ 前缀跳过其他 loader 2.1 ! 跳过 normal loader 2.2 -! 跳过 pre 和 normal loader 2.3 !! 跳过 pre，normal 和 post loader 3. loaderUtils 的 stringifyRequest 方法将模块的绝对路径转为相对路径 loaderUtils.stringifyRequest(this, '!!' + remainingRequest) => !!../node_modules/css-loader/dist/cjs.js!./index.css ! -! !! 阻断 loader 执行 urlToRequest convert that are root-relative URL into a module URl loaderUtils.urlToRequest('path/to/module.js') => './path/to/module.js' 单纯的路径拼接： loaderUtils.urlToRequest(process.cwd(), '/loader/myloader.js') interpolateName const interpolatedName = loaderUtils.interpolateName(this, '[emoji:4].js', { content: source }); this.emitFile(interpolatedName, source); return `module.exports = '${JSON.stringify(interpolatedName)}'`; name 可填参数： [ext] [name] [path] [folder] [query] [emoji] [emoji:] [contenthash] [hash] Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-18 11:20:34 "},"interview/webpack/9/1.html":{"url":"interview/webpack/9/1.html","title":"开发一个捕获函数异常的loader","keywords":"","body":" 解答 基本就是在 https://astexplorer.net/ 写一遍，然后根据类型，参考 https://babeljs.io/docs/en/babel-types 创建类型加入即可 const babel = require('@babel/core') const t = require('@babel/types') const ErrorCapturePlugin = { visitor: { Program (path) { path.node.body = [ t.functionDeclaration( t.identifier('errorCapture'), [ t.identifier('e') ], t.blockStatement([ t.expressionStatement( t.callExpression( t.memberExpression( t.identifier('console'), t.identifier('log') ), [ t.stringLiteral('发生异常：') , t.identifier('e') ] ) ), t.expressionStatement( t.callExpression( t.memberExpression( t.identifier('navigator'), t.identifier('sendBeacon') ), [ t.stringLiteral('/log'), t.callExpression( t.memberExpression( t.identifier('JSON'), t.identifier('stringify') ), [ t.identifier('e'), ] ) ] ) ) ]) ), ...path.node.body ] }, FunctionDeclaration (path) { const node = path.node if (node.id.name !== 'errorCapture') { // 把try catch 指定给函数体 node.body = t.blockStatement([ t.tryStatement( node.body, t.catchClause( t.identifier('e'), t.blockStatement([ t.expressionStatement( t.callExpression( t.identifier('errorCapture'), [ t.identifier('e') ] ) ) ]) ) ) ]) } } } } module.exports = function (source) { const reult = babel.transform(source, { plugins: [ ErrorCapturePlugin ] }) console.log('reult:', reult.code) return reult.code } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-20 17:01:08 "},"interview/webpack/10/1.html":{"url":"interview/webpack/10/1.html","title":"webpack5 tree-shaking能摇掉哪些代码","keywords":"","body":" tree-shaking webpack 的 tree-shaking 主要是基于 es6 的静态结构特性，如 import，export 没有导入和使用 代码不会被执行 或 不可到达 代码执行结果不会被用到 代码中只读不写的变量 没有导入和使用 bb 和 cc 两函数没有导入和使用，所以会被删除 // a.js function aa () { console.log('aa') } function bb () { console.log('bb') } export { aa, bb, } // index.js import { aa } from './a' aa(); function cc () { console.log('cc') } 代码不会被执行 或 不可到达 aa 函数体中代码不可到达，所以会被删除 function aa () { if (false) { console.log('aa') } } 代码执行结果不会被用到 aa 函数返回的结果没有被用到，所以会被删除 // a.js function aa () { return 'aa' } // index.js import { aa } from './a' aa(); 代码中只读不写的变量 以下 AA 会被删除，有点类似 Scope Hoisting const AA = 'hello tree-shaking' console.log(AA) => 打包结果 console.log('hello tree-shaking') 将文件标记为无副作用 比如在 index.js 中 import './index.css'，package 中配置了 sideEffects: false 就会把 css 删除掉 sideEffects 会把模块标记为有副作用或无副作用 // package.json { \"sideEffects\": false, \"sideEffects\": [ \"./src/some-side-effectful-file.js\", \"*.css\" ] } // index.js import './index.css' // index.css body { color: red } sideEffects 的配置方法： 有副作用：\"sideEffects\": true 无副作用：\"sideEffects\": false 正则匹配：\"sideEffects\": ['*/.css'] 具体文件：\"sideEffects\": ['./src/index.js'] 给语句标记为无副作用 通过给语句加 /#PURE/ 使其被 tree-shaking sideEffects 的原理跟 PURE 类似，sideEffects 是作用于模块，而 PURE 是作用于语句 function aa () { console.log('aaaa') } /*#__PURE__*/ aa(); 正常情况下，console.log('aaaa')会被打包进代码，加了 PURE 之后不会打包 scope Hoisting 分析出模块之间的依赖关系，尽可能把打散的模块合并到一个函数中去，用到 es6 模块 只有被引用了一次的模块才能被合并 通过 webpack 内置插件实现：webpack/lib/optimize/ModuleConcatenationPlugin 最佳实践 使用 es6 的 import 和 export 确保编译器不会把 es6 模块语法转换为 CommonJS的 package.json 中添加 sideEffects Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-07 16:31:28 "},"interview/webpack/11/1.html":{"url":"interview/webpack/11/1.html","title":"webpack5 公共代码拆分","keywords":"","body":" 场景 webpack 的默认拆分 默认不配置 splitChunks，出来四个打包文件 - page1.js - page2.js - page3.js - 3.js splitChunks webpack 公共代码拆分主要依赖 SplitChunksPlugin，配置 optimization optimization: { splitChunks: { async：只提取动态 import 代码，initial：提取同步代码（直接引入的模块），all：所有 chunks: 'async | all | initial', 分割出去的代码块的最大最小体积，0表示不限制 minSize: 0, maxSize: 0, 如果此模块被多个入口引用几次会被分割 minChunks: 1, 异步请求和同步请求最多分割出去多少个代码块 maxAsyncRequests: 30, maxInitialRequests: 30, 名称的分割符 vendors~main.js => page1~module1_jsf51c7e26.js automaticNameDelimiter: '~', 缓存组配置 配置如何对模块分组相同分组会分到一个代码块中 cacheGroups: { 第三方模块 defaultVendors: { 如果模块的路径匹配此正则的话 test: /[\\\\/]node_modules[\\\\/]/, 很多缓存组，如果一个模块同属于多个缓存组，应该分到哪个组里，看优先级高 priority: -10, 是否可复用现有的代码块，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了 reuseExistingChunk: true }, default: { 此模块最几个入口引用过，最少2个才取提取 minChunks: 2, priority: -20, reuseExistingChunk: true } } } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-08 19:56:26 "},"interview/webpack/12/1.html":{"url":"interview/webpack/12/1.html","title":"webpack5 有哪些新特性","keywords":"","body":" 新特性 持久化缓存 资源模块 moduleIds chunkIds优化 tree-shaking 模块联邦 持久化缓存 开启持久化缓存，不配置的话默认不开启缓存，试过打包时间都差不多 cache: { type: 'memory | filesystem', cacheDirectory: path.resolve(__dirname, 'node_modules/.cache/webpack') } 资源模块 webpack4 的资源模块加载: file-loader 加载文件，并返回 url url-loader 加载文件，并返回 base64 编码 raw-loader 加载文件，并返回文件字符串内容 { test: /\\.jpg$/, loader: 'file-loader | url-loader | raw-loader' } webpack5 中内置了这些 loader，配置更简单： file-loader { test: /\\.jpg$/, type: 'asset/resource' } url-laoder { test: /\\.jpg$/, type: 'asset/inline' } 自动根据文件大小判断使用 file-loader 还是 url-loader { test: /\\.jpg$/, type: 'asset', parser: { dataUrlCondition: { maxSize: 10 * 1024 } } } raw-loader { test: /\\.txt$/, type: 'asset/source' } moduleIds chunkIds 优化 webpack4 中 moduleIds 使用的是 named 命名方式，即 ./a.js 路径作为 key chunkIds 使用的是 natural 命名方式，即 1.js 之类的引用顺序数字作为 chunkName 这种方式有个问题：webpack4 中非入口模块的命名是按照引用顺序数字命名的，如果某个文件被删除，会导致之后的文件缓存失效，webpack5 中 chunkIds 默认采用 named 的命名方式 natural: 数字顺序命名 named: 文件路径命名方式，module 如 ./a.js，chunk 如 src_c_js.js deterministic: 根据模块名称生成简短的三位 hash 值作为文件名，chunk 数超过 999 会冲突 size: 试过是看文件个数 配置 output: { filename: '[name].[hash:8].js', chunkFilename: '[name].[hash:8].js' }, optimization: { moduleIds: 'deterministic', chunkIds: 'deterministic' } 更强大的 tree-shaking webpack v5 对 tree-shaking 进行了增强 嵌套 tree-shaking commonjs tree-shaking 嵌套 tree-shaking 下面这个例子，v4 会打包 bbbbb，v5不会打包 // inner.js export const aaaaa = 1; export const bbbbb = 1; // module.js import * as inner from './inner' export default { aaaaa } // index.js import module from './module' console.log(module.inner.aaaaa) commonjs tree-shaking v4 的 tree-shaking 是基于 import 的，v5 中增加了 commonjs 支持 // module.js exports.aaaaa = function () { console.log('aaaaa') }; exports.bbbbb = function () { console.log('bbbbb') }; // index.js const aaaaa = require('./module').aaaaa; aaaaa(); development 模式如何查看未使用的export optimization: { usedExports: true } 模块未使用到但是改变了全局变量如何处理 举个例子 document.title = 'tree-shaking' function aaa () { console.log('aaa') } 这个例子中 document.title 会被保留，aaa会被删除通过设置 sideEffects 可以使 document.title 也被删除 // package.json { sideEffects: false } 如果是 import 'index.css' 怎么办，配置了 sideEffects 会导致 css也被删除 // package.json { sideEffects: '*.css' } 告知 webpack 此方法是纯函数，可以被 shaking var Person = /*#__PURE__*/function () { function Person () {}; return Person; } 模块联邦 动机：多个团队一起开发一个或多个应用程序，应用程序被拆分成小部分，可以是 UI 组件，也可以是数据请求，或其他业务组件 优点： 组件热更新，异步组件运行时性能好 分别打包，打包性能好 依赖共享，如 React 等 remote 项目导出组件 const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin'); plugins: [ new ModuleFederationPlugin({ name: 'AddressProject', filename: 'AddressForm.js', exposes: { './AddressForm': './components/AddressForm' } }) ] hosts 项目使用组件 webpack 配置文件声明 const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin'); plugins: [ new ModuleFederationPlugin({ name: 'cartProject', remotes: { addrProj: 'AddressProject@http://localhost:8080/AddressForm.js' } }) ] 组件使用 const AddressForm = React.lazy(() => import('addrProj/AddressForm')); remote component loading}> 跨框架不可行 一个项目 React，一个项目 Vue，是无法共享组件的Vue 中异步组件 components: { Header: () => import('address/AddressForm') } 相比其他的有点 ModuleFederationPlugin 与本地模块，npm 打包，dll，externals相比较参考网址：https://github.com/sokra/slides/blob/master/content/ModuleFederationWebpack5.md Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-29 18:04:38 "},"interview/js/24/1.html":{"url":"interview/js/24/1.html","title":"实现一个AsyncPool异步串行加载","keywords":"","body":" AsyncPool 的使用 定义异步池大小，使异步任务排队执行 const asyncPool = require('tiny-async-pool') const startTime = Date.now() const tasks = [ () => { return new Promise(resolve => { setTimeout(() => { resolve(1000) }, 1000) }) }, () => { return new Promise(resolve => { setTimeout(() => { resolve(1001) }, 1001) }) }, () => { return new Promise(resolve => { setTimeout(() => { resolve(1002) }, 1002) }) }, () => { return new Promise(resolve => { setTimeout(() => { resolve(1003) }, 1003) }) }, () => { return new Promise(resolve => { setTimeout(() => { resolve(1004) }, 1004) }) }, () => { return new Promise(resolve => { setTimeout(() => { resolve(1005) }, 1005) }) }, ] asyncPool(2, tasks, async (task, next) => { const ret = await task(); console.log(ret) return ret }).then((...args) => { console.log(args) const endTime = Date.now(); console.log('总共花费时间：', ( endTime - startTime )) }) asyncPool 自定义实现 function asyncPool (maxPool, tasks, callback) { return new Promise(doneResolve => { let currentPool = 0; const result = []; function next() { while (currentPool 0) { ++currentPool; const task = tasks.shift(); callback(task).then(res => { result.push(res); --currentPool; next(); }) } if (currentPool === 0 && tasks.length === 0) { doneResolve(result) } } next(); }) } 【延伸】ajax axios fetch 的区别 ajax 是基于 XMLHttpRequest 实现的 axios 是使用 ajax 或 http 发起请求，使用 Promise 管理请求，可以避免回调地狱 fetch 是一种新的通信方式，也是基于 promise，fetch 相对而言更友好 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-29 19:27:43 "}}