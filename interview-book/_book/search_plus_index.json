{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"test/":{"url":"test/","title":"每日一题","keywords":"","body":"每日一题 一天一题练习 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:33:17 "},"test/vue/":{"url":"test/vue/","title":"vue","keywords":"","body":"这里是vue专题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:11:09 "},"test/vue/1/1.html":{"url":"test/vue/1/1.html","title":"父组件监听子组件的生命周期","keywords":"","body":" 解法1: @hook @hook:搭配任意钩子函数，会在子组件触发相应生命周期钩子函数时回调父组件这个函数 解法2: $emit 这种方式比较蠢，而且是需要劳动力堆积的 mounted () { this.$emit('mounted') } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:36:45 "},"test/vue/2/1.html":{"url":"test/vue/2/1.html","title":"$set解决新增属性不能相应的问题","keywords":"","body":" 解答： 是因为Vue在实例化的过程中就需要对data中的数据使用defineProperty方法来定义存取器实现的响应式。而直接新增属性因为仍是值属性，所以是不能实现响应式的 源码实现 const isValidArrayIndex = index => { return index > 0 && Math.floor(index) === index && isFinite(index) } exprt function set (target, key, val) { if (Array.isArray(target) && isValidArrayIndex(key)) { target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } if (key in target && !(key in target.prototype)) { target[key] = val return val } const __ob__ = target.__ob__ if (!__ob__) { target[key] = val return val } else { defineReactive(__ob__.value, key, val) __ob__.dep.notify() return val } } set分为四步骤： 判断是否为数组，以及索引是否合法 Array.isArray判断target是否为数组 索引是否合法：index > 0 && Math.floor(index) === index && isFinite(index) 数组可能不够长，先把数组扩充下：target.length = Math.max(target.length, key) 通过splice往数组中添加：target.splice(key, 1, val) 判断target对象下是否已经该属性key 存在的话就是修改操作，直接target[key] = val，通过setter存取器触发notify target是否已被响应式 否：不管响应式，target[key] = val完事 已设置响应式，defineReactive(ob.value, key, val), ob.dep.notify()触发更新 defineProperty的缺点 从这个问题可以看出：defineProperty实现响应式，需要在vue实例化时对所有属性进行重定义，不然的话就不能实现响应式有点类似事件绑定时，对单个节点 Proxy的使用 let obj = { a: 1, b: 2 } let obj1 = new Proxy(obj, { get (obj, prop) { console.log(`正在获取属性：${prop}，值为：${obj[prop]}`) return obj[prop] } }) obj1.a obj1.b Proxy类似事件委托，把属性访问委托到另一个对象上，可是不具体关心是什么属性，所以在Vue实例化阶段减少了对data下所有属性进行defineProperty定义存取器 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:21:01 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:41:25 "},"knowledge/html/":{"url":"knowledge/html/","title":"Html","keywords":"","body":"Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:45:28 "},"knowledge/html/1.html":{"url":"knowledge/html/1.html","title":"Html布局元素的分类有哪些","keywords":"","body":"Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:43:46 "},"knowledge/css/":{"url":"knowledge/css/","title":"Css","keywords":"","body":"Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:45:48 "},"knowledge/css/1/1.html":{"url":"knowledge/css/1/1.html","title":"css伪类与伪元素的区别","keywords":"","body":" 解答 区别： 表示方法 CSS2中伪类和伪元素都是用:声明，CSS2.1中伪类用:，伪元素用:: 浏览器同样接受CSS2时代已存在的单冒号写法，比如:before, :after等 CSS2之后所有新增的伪元素，如::selection 定义不同 伪类即假的类，可以添加类来达到效果 伪元素即假元素，需要通过添加元素才能达到效果 相同点： 同为文档树以外的\"元素\"，在html源文件中是看不到伪类和伪元素的 扩展 伪类的顺序需要遵循什么规则？LVHA：link visited hover active为了避免hover样式失效，需要遵循这样的规则定义伪类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-28 14:00:01 "},"knowledge/css/2/1.html":{"url":"knowledge/css/2/1.html","title":"css盒模型","keywords":"","body":" 解答 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-28 14:00:29 "},"knowledge/css/3/1.html":{"url":"knowledge/css/3/1.html","title":"长度单位","keywords":"","body":" 解答 rem 相对于根元素html的字体 em 相对于父元素的字体 元素的width/height/padding/margin用em相对于自身字体 vw/vh: Viewport Width / Viewport Height 视窗的宽度和高度 100vh 相当于视图全部高度 px：相对屏幕显示器分辨率而言 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-28 14:30:07 "},"knowledge/css/4/1.html":{"url":"knowledge/css/4/1.html","title":"圣杯布局和双飞翼布局","keywords":"","body":" 解答 圣杯： Main Left Left 双飞翼 1 left right Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-28 14:33:11 "},"knowledge/css/5/1.html":{"url":"knowledge/css/5/1.html","title":"BFC","keywords":"","body":"BFC是什么？ 块级格式化上下文，它规定了内部的块级元素如何布局，并且与这个区域外部毫不相干 BFC的生成 根元素 float非none overflow非visible display为inline-block，table-cell，table-caption positon为absolute或fixed 使用场景 避免外边距（margin）塌陷（兄弟节点，父子节点，节点自身） 清楚内部浮动 自适应两栏布局（BFC元素不会与浮动元素重叠） 参考文档：https://github.com/zuopf769/notebook/blob/master/fe/BFC%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/README.md Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-28 15:52:28 "},"knowledge/js/":{"url":"knowledge/js/","title":"Javascript","keywords":"","body":"javascript javascript的知识点 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 19:10:48 "},"knowledge/js/1/1.html":{"url":"knowledge/js/1/1.html","title":"防抖节流原理，区别以及应用","keywords":"","body":" 解答 防抖 原理 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时⌛️ 场景 按钮重复点击：防止多次提交按钮，只执行最后一次提交 搜索框联想：防止联想发送请求，只发送最后一次输入 简易版实现 const debounce = fn => { let _timeout; return function (...args) { const context = this clearTimeout(_timeout) _timeout = setTimeout(() => { fn.apply(context, args) }, 1000) } } 有些时候希望立即执行，然后等到n秒后才可以重新触发 升级版 const debounce = (fn, wait, immediate) => { let timeout return function (...args) { const context = this if (immediate) { timeout = setTimeout(() => { timeout = null }, wait) !timeout && fn.apply(context, args) } else { _timeout = setTimeout(() => { fn.apply(context, args) }, wait) } } } 节流 原理 规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效 使用场景 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动 缩放场景：监控浏览器size 使用时间戳实现 function throttle (func, wait) { let previous = 0 return function (...args) { const now = Date.now() if (now - previous > wait) { func.apply(this, args) previous = now } } } 使用定时器实现 function throttle (func, wait) { let timeout return function (...args) { const context = this if (!timeout) { timeout = setTimeout(() => { timeout = null func.apply(context, args) }, wait) } } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 19:45:00 "},"knowledge/js/2/1.html":{"url":"knowledge/js/2/1.html","title":"闭包的看法，为何用闭包，原理以及应用场景","keywords":"","body":" 解答 什么是闭包？ 函数内部返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包 闭包的原理 函数执行分为两个阶段： 预编译阶段 如果发现内部函数使用了外部函数的变量，会在内存中创建一个闭包对象并保存对应的变量值 执行阶段 执行完后，函数执行上下文会被销毁，函数对闭包对象的引用也会被销毁，但其内部函数还持用该闭包的引用，所以内部函数可以继续使用外部函数中的变量 利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域中，函数执行完毕，其执行作用域销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被销毁后才能被销毁 优点 可以从内部函数访问外部函数作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用 避免变量污染全局 把变量存到独立的作用域，作为私有成员存在 缺点 对内存消耗有负面影响，因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏。可将内层函数对象的变量赋值为null来释放内存 对处理速度具有负面影响，闭包的层级决定了引用的外部变量在查找时经过的作用域链长度 可能获取到意外的值 应用场景 模块封装：自执行函数 在循环中创建闭包，防止取到意外的值 for + var + setTimeout for + onclick等事件 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 20:06:29 "},"knowledge/js/3/1.html":{"url":"knowledge/js/3/1.html","title":"实现lodash的_.get","keywords":"","body":" 解答 const get = (source, path) => { const paths = path.split('.') for (let path of paths) { source = source[path] } return source } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 21:42:58 "},"knowledge/js/4/1.html":{"url":"knowledge/js/4/1.html","title":"跨域是个什么概念","keywords":"","body":" 解答 浏览器将CORS请求分成两类：简单请求，非简单请求 简单请求 简单请求条件 满足两个条件： 请求方式是以下三种： HEAD GET POST HTTP的头信息不超过以下几种： Accept Accept-Language Content-Language Last-Event-ID Content-type: application/x-www-form-urlencoded application/form-data text/plain 这是为了兼容表单，历史上表单一直可以发出跨域请求Ajax的设计就是：只要表单可以发，Ajax就可以直接发 简单请求流程 浏览器直接发出CORS请求，在头信息中增加一个Origin字段Origin：http://api.bob.com:8080 Origin字段用来说明：本次请求来自哪个源（协议+域名+端口） 如果Origin指定的源不在许可范围内服务器会返回一个正常的HTTP响应，浏览器会发现response的头信息没有包含Access-Control-Allow-Origin字段，就知道错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200 如果Origin指定的域名在许可范围内，服务器返回的响应会多出几个头信息字段： Access-Control-Allow-Origin: * => 源数据 Access-Control-Allow-Credentials: true => 是否允许发送Cookie Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 如何获取更多跨域头信息 在Access-Control-Expose-Headers中设置XMLHttpRequest对象的getResponseHeader方法默认只能拿到6个基本字段： Cache-Control Content-Language Content-Type Expires Last-Modified Pragma 跨域如何携带Cookie XMLHttpRequest的xhr.withCredentials = true 服务端设置responseHeader的Access-Control-Allow-Credentials: true 如果要发送Cookie，Access-Control-Allow-Origin不能设置为*，必须指定明确，与请求网页一致的域名 非简单请求 那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或Content-Type为applicetion/json 预检请求 浏览器先询问服务器，当前网页域名在服务器许可名单之中，以及使用哪些HTTP动词和头信息字段，得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错 预检请求特点： 请求方式是OPTIONS 头信息Access-Control-Request-Method: PUT标明HTTP方法 头信息Access-Control-Request-Headers: Foo 逗号分隔的字符串，标明额外发送的头信息字段 与JSONP的比较 CORS功能更强大，支持所有类型HTTP请求，JSONP只支持GET请求 JSONP兼容性更好：JSONP的优势是老式浏览器，以及可以向不支持CORS的网站请求数据 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-21 21:46:30 "},"knowledge/js/7/":{"url":"knowledge/js/7/","title":"模块化","keywords":"","body":"模块化相关知识 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-29 15:25:26 "},"knowledge/js/7/1/1.html":{"url":"knowledge/js/7/1/1.html","title":"ESM的使用和实现","keywords":"","body":" ES6模块基本语法 从其他模块导出 1. export * from './module' 2. export { name1, name2 } from './module' 3. export { v1 as name1, v2 as name2 } from './module' 4. export { default as name } from './module' 导出自己模块的属性 1. export const NAME = 'leo' 2. export { NAME } 3. export { v1 as NAME } 4. export default {} 5. export { v1 as default, v2 } default是个啥？跟export的其他属性什么关系？ default情况webpack打包情况 写一个简单的demo： import m from './2' console.log(m) export default { name: 'leo' } 来看下webpack对这两个文件打包之后变成啥样？👇 var _2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./2.js\"); console.log(_2_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) __webpack_require__.r(__webpack_exports__); __webpack_exports__[\"default\"] = ({ name: 'leo' }); 就这样完事了。一个设置了default，一个拿default来用 属性导出情况webpack打包情况 下面看看导出属性是怎样👇： var _2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./2.js\"); console.log(_2_js__WEBPACK_IMPORTED_MODULE_0__[\"name\"]) __webpack_require__.d( __webpack_exports__, \"name\", function() { return name; } ); const name = 'leo' 可以看出default是赋值到webpack_exports上的，而单个属性是使用defineProperty定义getter的，这么做是为什么？ES6导出的是值引用，default是引用类型，而一般变量是基本类型，所以基本类型用getter这么做因为采用了闭包的原理所以name改变之后，通过getter获取仍是最新值，那么对于default的情况仍然适用吗？ 如果export default { name }, 那么又是如何处理的？ let name = 'leo' export default { name } name = 'hello' let name = 'leo' __webpack_exports__[\"default\"] = ({ name: name }); name = 'hello' 试了下输出leo，而不是hello，说明export default的模式导出的是default引用，而其中属性改变是无法侦测到的。 export的是函数webpack是怎么处理的？ __webpack_require__.d(__webpack_exports__, \"name\", function() { return name; }); __webpack_require__.d(__webpack_exports__, \"changeName\", function() { return changeName; }); let name = 'leo' const changeName = function () { name = 'hello' } 可以看出函数和变量是一样处理的 webpack是如何实现ESM的？ (function (modules) { let _cache = {} function __webpack_require__ (moduleId) { if (_cache[moduleId]) { return _cache[moduleId] } let module = _cache[moduleId] = { id: moduleId, l: false, exports: {} } modules[moduleId](module, module.exports, __webpack_require__) return module.exports } __webpack_require__.d = function (obj, prop, getter) { Object.defineProperty(obj, prop, { get: getter }) } return __webpack_require__('./1.js') })({ './1.js': (function(module, __webpack_exports__, __webpack_require__) { const module_2 = __webpack_require__('./2.js') console.log(module_2['name']) }), './2.js': (function(module, __webpack_exports__, __webpack_require__) { __webpack_require__.d( __webpack_exports__, 'name', function () { return name } ) const name = 'leo111' }) }); 执行IIFE函数时，最后要执行webpack_require('./1.js')，执行入口函数进行启动 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-29 16:38:02 "},"knowledge/js/7/2/1.html":{"url":"knowledge/js/7/2/1.html","title":"CommonJS的使用和实现","keywords":"","body":" CommonJS模块基本语法 module.exports = { name: 'leo' } exports.name = 'leo' exports = { name: leo } ❌ 这是不行的，因为切断了exports和module.exports之间的引用 CommonJS的自定义实现 const fs = require('fs') const vm = require('vm') const path = require('path') const Module = { wrapper: [ '(function (require, module, exports, __filename, __dirname) {', '})' ], _cache: {} } function customRequire (filepath) { const filename = path.resolve(__dirname, filepath) if (Module._cache[filename]) { return Module._cache[filename] } let module = Module._cache[filename] = { id: filename, l: false, exports: {} } const content = fs.readFileSync(filename) const func = new vm.Script(Module.wrapper[0] + content + Module.wrapper[1]).runInThisContext() func(customRequire, module, module.exports, filename, path.dirname(filename)) return module.exports } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-29 17:06:32 "},"knowledge/js/7/3/1.html":{"url":"knowledge/js/7/3/1.html","title":"ESM和CommonJS有什么区别","keywords":"","body":" 解答 ESM导出的是值的引用，CommonJS导出的是值的拷贝 循环引用两者的处理有区别 CommonJS是运行时加载，ESM是编译时输出接口 导出的区别 ESM导出的时候，👇： export const name = 'leo' 👇 会被解析为： __webpack_require__.d( __webpack_exports__, 'name', function () { return name } ) 其实是使用defineProperty的方法把name的getter设置到webpack_exports上面，但是实际取的还是外部的name，这里用了闭包特性 CommonJS导出的时候却是这样实现的👇： const content = fs.readFileSync(filename) new vm.Script(Module.wrapper[0] + content + Module.wrapper[1]).runInThisContext() 从两者的实现可以看出：ESM导出值的引用，而CommonJs导出值的拷贝 循环引用 循环引用指的是：a引用b，b又引用a 先存缓存的重要性 在实现ESM和CommonJS的过程中，都可以发现还未执行模块，就先把模块存入了缓存： let module = Module._cache[filename] = { if: filename, l: false, exports: {} } 这是因为如果不先存入缓存，循环引用会导致内存溢出，先存入缓存之后取直接取缓存返回 输出已执行部分 因为ESM做得比较好，不能重复导出相同属性，所以这里拿CommonJS来实验： exports.name1 = 'leo1' const m2 = require('./2.js') exports.name1 = 'leo11' console.log(m2.name2) const m1 = require('./1.js') console.log(m1.name1) exports.name2 = 'leo2' 这里1.js和2.js循环引用，在导入2.js之前name1为leo1，导入2.js之后name1为leo11。可以发现2.js中输出的name1为leo1CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值 循环引用中使用了未定义的变量，什么反应？ 如果把1.js中的name='leo1'删除，可以发现直接是undefined了，对两个文件稍作加工👇： const m2 = require('./2.js') exports.name1 = function () { return 'leo11' } console.log(m2.name2) const m1 = require('./1.js') console.log(m1.name1()) exports.name2 = 'leo2' CommonJS直接报错：m1.name1 is not a function 换成ESM试下： import { name2 } from './2.js' export function name1 () { return 'leo11' } console.log(name2) import { name1 } from './1.js' console.log(name1()) export const name2 = 'leo2' 发现输出了leo11 leo2，说明可以，因为函数提升 可以想象：函数表达式也是不行的，因为虽然可以变量提升，但是变量仍是undefined Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-29 18:03:10 "},"knowledge/js/7/4/1.html":{"url":"knowledge/js/7/4/1.html","title":"项目中如何共用ESM和CommonJS","keywords":"","body":" 解答 node如何跑ESM模块的代码呢？ node --experimental-modules 1.mjs 两个条件： --experimental-modules mjs后缀 开源模块 module package.json里面的module { type: 'module', module: './1.js' } import { name1 } from 'test' 设置了type: 'module'说明是ESM，没设置说明是CommonJS模块 exports exports只有兼容ESM的Node才支持，版本13.2.0以上 \"exports\": { \".\": { \"require\": \"./main.cjs\", \"default\": \"./main.js\" } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-29 18:09:44 "},"knowledge/js/7/5/1.html":{"url":"knowledge/js/7/5/1.html","title":"UMD是如何实现的","keywords":"","body":" (function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : ( typeof define === 'function' && define.amd ? define(factory) : (global.libName = factory()) ) })(this, function () { 'use strict' }) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-29 18:12:45 "},"knowledge/promise/":{"url":"knowledge/promise/","title":"Promise","keywords":"","body":"Promise Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-10 16:59:16 "},"knowledge/promise/1.html":{"url":"knowledge/promise/1.html","title":"Promise.all有一个请求出错了如何回滚？","keywords":"","body":" 解答 可以使用新api -> allSettled解决，有请求出错仍会进入.then，结果格式如下👇： [ { statue: 'fullfilled', value: 1 }, { statue: 'fullfilled', value: 2 }, { statue: 'rejected', value: 3 }, ] 像vscoder插件Code Runner里面跑Promise，是没有allSettled方法的，那么可以自己实现一个👇： if (!Promise.allSettled) { Promise.allSettled = promises => { let _promises = [] for (let promise of promises) { _promises.push(promise.then(value => { return Promise.resolve({ status: 'fullfilled', value }) }).catch(value => { return Promise.resolve({ status: 'rejected', value }) })) } return Promise.all(_promises) } } Promise.allSettled([ new Promise(resolve => { setTimeout(() => resolve(1), 1000) }), new Promise(resolve => { setTimeout(() => resolve(2), 2000) }), new Promise((resolve, reject) => { setTimeout(() => reject(3), 3000) }) ]).then(res => { console.log('结果：', res) }).catch(e => { console.log('异常：', e) }) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-10 17:20:36 "},"knowledge/vue/":{"url":"knowledge/vue/","title":"Vue","keywords":"","body":"Vue Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-11 14:55:02 "},"knowledge/vue/1.html":{"url":"knowledge/vue/1.html","title":"defineProperty为什么不能对数组做监听？","keywords":"","body":" 解答 回答这个问题之前，先来回顾下defineProperty实现监听的原理：重定义属性的值属性为存取器属性，在存取器中进行访问拦截，从而实现监听 defineProperty可以监听数组吗？ 数组它有键值对，比如下面👇： const arr = [1, 2, 3] arr[0] 键为0，值为1，那么有键值对就能进行监听👇 function walk (obj) { const keys = Object.keys(obj) for (let key of keys) { defineReactive(obj, key, obj[key]) } } function defineReactive (obj, key, val) { Object.defineProperty(obj, key, { configurable: true, enumerable: true, get () { console.log(`getter: ${key}: ${val}`) return val }, set (newVal) { console.log(`setter: ${key}: ${val}: ${newVal}`) val = newVal } }) } const arr = [1, 2, 3] walk(arr) arr[0] arr[0] = 2 console.log(arr[0]) 这段代码执行输出下，可以看到也实现了数组的监听，那么为啥Vue1和2不是这么实现的呢？ defineProperty监听数组的问题 新增属性无法监听 数组的重复存取监听 新增属性无法监听 还是上面的基础代码，再来试试下面几种场景： arr[3] = 4 arr.push(4) 这些场景都无法触发存取器拦截，因为定义的索引为3的属性是属于值属性，并没有重写存取器拦截 其次如果删除了一个索引，然后重新赋值，也是一样 delete arr[1] arr[1] = 4 arr[1] 执行上面代码可以发现，set和get都没有进，很简单：因为arr[1]=4是值属性，之前的存取器属性已被删除，所以已无法拦截 数组的重复存取监听 在前面的基础代码上执行一下unshift： arr.unshift(0) 会发现控制台输出了一坨： getter: 2: 3 getter: 1: 2 setter: 2: 3: 2 getter: 0: 1 setter: 1: 2: 1 setter: 0: 1: 0 可以发现明明只是往数组头部插入了一条，可是触发了整个数组的set和get，这是非常耗费性能的 为何会这样呢？ 因为数组在内存中是连续的内存段插入了第一条的数据，后面的数据就要被往后挤，所以就导致了整个数组的get和set 哪些方法会导致数组被挤被挤有两种情况：往后挤，或者往前挤 unshift，shift，sort，reverse，splice Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-11 15:45:49 "},"knowledge/vue/2.html":{"url":"knowledge/vue/2.html","title":"Vue是如何实现的数组监听？","keywords":"","body":" 解答 鉴于defineProperty直接监听索引的两个问题： 新增属性无法监听 数组元素的重复get和set defineProperty直接监听索引这个方案就被KO了。 Vue2的数组监听实现方式 变异方法：重写数组实例的proto 监听数组中的引用对象 const arrayProto = Array.prototype const arrayMethods = Object.create(arrayProto) const methods = ['unshift', 'shift', 'push', 'pop', 'sort', 'reverse', 'splice'] methods.forEach(method => { const originalMethod = arrayMethods[method] Object.defineProperty(arrayMethods, method, { value: function (...args) { originalMethod.apply(this, args) let inserted; switch (method) { case 'unshift': case 'push': inserted = args break case 'splice': inserted = args.slice(2) break } const __ob__ = this.__ob__ if (__ob__) { if (inserted) observeArray(inserted) this.__ob__.otify() } } }) }) arr.__proto__ = arrayMethods 其次还有observeArray: function observeArray (arr) { for (let item of arr) { observe(item) } } 这种处理方式：需要使用方法去操作数组，如果使用arr[0] = 1这样仍是没用的 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-11 16:02:23 "},"knowledge/react/":{"url":"knowledge/react/","title":"React","keywords":"","body":"React Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 10:51:30 "},"knowledge/react/1/1.html":{"url":"knowledge/react/1/1.html","title":"React中setState后发生了什么？","keywords":"","body":" 解答 调用setState之后，会经历一下几步： React会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程 经过调和过程，React会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个UI界面 在React得到元素树之后，React会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染 在差异计算算法中，React能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染 setState为什么默认是异步 假如所有setState是同步的，意味着没执行一次setSTate时，都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。 setState什么时候是同步 setTimeout 原生事件 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 11:17:01 "},"knowledge/react/2/1.html":{"url":"knowledge/react/2/1.html","title":"Redux中异步的请求如何处理？","keywords":"","body":" 解答 redux-thunk 第一步：配置redux-thunk： import { createStore, applyMiddleware, compose } from 'redux' import thunk from 'redux-thunk' const enhancer = composeEnhancers(applymiddleware(thunk)) const store = createStore(reducer, enhancer) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 15:56:26 "},"knowledge/security/":{"url":"knowledge/security/","title":"Security","keywords":"","body":"安全问题 安全相关问题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 16:36:55 "},"knowledge/security/1/1.html":{"url":"knowledge/security/1/1.html","title":"协议基础知识预备","keywords":"","body":"协议基础预备知识 SSL/TLS协议运行机制 SSL/TLS为了解决什么问题？ 不使用SSL/TLS的http通信，即不加密的通信，有三大风险： 窃听风险：第三方可以获知通信内容 篡改风险：第三方可以修改通信内容 冒充风险：第三方可以冒充他人身份进行通信 SSL/TLS就是为了解决这三大风险而设计的： 所有信息加密传播，第三方无法窃听 具有校验机制，一旦被篡改，通信双方立刻会发现 配备身份证书，防止身份被冒充 TLS和SSL什么关系？ TLS是SSL的升级版：TLS1.0通常被标示为SSL3.1，TLS1.1为SSL3.2，TLS1.2为SSL3.3 基本的运行过程 公钥加密法 客户端向服务端索要公钥 用公钥加密信息 服务端收到密文后，用私钥解密 （1）如何保证公钥不被篡改？把公钥放在数字证书中，只要证书是可信的，公钥就是可信的 （2）公钥加密计算量太大，如何减少耗用的时间？ 每一次对话，客户端和服务端都生成一个对话密钥（session key），用它来加密信息 由于对话密钥是对称加密，所以运算速度非常快 服务器公钥只用于加密对话密钥本身 SSL/TLS的基本过程 客户端向服务端索要并验证公钥 客户端和服务端协商生成对话密钥 双方采用对话密钥进行通信 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-27 15:06:21 "},"knowledge/security/2/1.html":{"url":"knowledge/security/2/1.html","title":"https证书伪造","keywords":"","body":" 解答1 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 16:39:53 "},"knowledge/security/8/1.html":{"url":"knowledge/security/8/1.html","title":"base64编码算加密吗？md5是加密吗","keywords":"","body":" 加密指的是对数据进行转换之后，变成了另一种格式的数据，除了拿到揭秘方法的人，没人能把数据转换回来 Base64 base64是一种数据编码方式，且它的编码方式是公开的，不是加密算法 MD5 MD5是信息摘要算法，它是不可逆的，不可以解密，只能算是单向加密 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-27 15:15:43 "},"knowledge/node/":{"url":"knowledge/node/","title":"Node","keywords":"","body":"node Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 17:27:47 "},"knowledge/node/1/1.html":{"url":"knowledge/node/1/1.html","title":"Node子进程如何使用","keywords":"","body":" Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 17:30:13 "},"knowledge/node/2/1.html":{"url":"knowledge/node/2/1.html","title":"Node8以上有个utils.promisify","keywords":"","body":" 解答 function promisify (func) { return function (...args) { return new Promise((resolve, reject) => { const argsWithCallback = [...args, function (error, content) { error ? reject(error) : resolve(content) }] func.apply(func, argsWithCallback) }) } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-28 14:09:13 "},"knowledge/node/3/1.html":{"url":"knowledge/node/3/1.html","title":"Node如何实现commonjs规范的模块化","keywords":"","body":" 解答 const fs = require('fs') const vm = require('vm') let Module = { wrapper : [ '(function (exports, require, module) {\\n', '\\n})' ], _cache: Object.create(null) } const customRequire = function (moduleId) { if (Module._cache[moduleId]) { return Module._cache[moduleId] } const script = fs.readFileSync(moduleId) const module = { exports: {} } Module._cache[moduleId] = module const func = new vm.Script(Module.wrapper[0] + script + Module.wrapper[1]).runInThisContext() func(module.exports, customRequire, module) return module.exports } module.exports = customRequire Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-28 15:02:27 "},"knowledge/browser/":{"url":"knowledge/browser/","title":"Browser","keywords":"","body":"browser Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 14:18:37 "},"knowledge/browser/1/1.html":{"url":"knowledge/browser/1/1.html","title":"渲染性能","keywords":"","body":"渲染性能 问题： 帧的概念 现在广泛使用的屏幕都有固定的刷新率（最新的一般在60Hz），在两次硬件刷新之间浏览器进行两次重绘是没有意义的只会消耗性能 渲染帧 指浏览器一次完整绘制过程 帧之间的时间间隔是DOM视图更新的最小间隔 是否意味着DOM视图更新最小时间为16ms 主流浏览器屏幕刷新率为60Hz，渲染一帧的时间必须控制在16ms之内才能保证不掉帧 浏览器执行一次渲染主要是做几件事，如下图 浏览器每帧处理流程： input event handlers: 处理事件回调，比如scroll等 requestAnimationFrame: 回调函数在下一次重绘之前执行 Parse HTML: 生成DOM tree Recalc Styles: 级联地生成每个节点地生效样式 Layout: 整合DOM tree和style tree，生成layout tree Update Layer tree: 解析层叠上下文，生成layer tree Paint: 各层分别进行绘制 Composite: 合成各层的渲染结果 掉帧的概念 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 11:57:42 "},"knowledge/browser/2/1.html":{"url":"knowledge/browser/2/1.html","title":"cookie","keywords":"","body":"cookie 为什么需要cookie http是无状态的，每次用户请求到达服务端，服务器都不知道用户是谁，是否登陆过 cookie的构成 author=leo; 键值对 expires=Fri, 31 Dec 9999 23:59:59 GMT; 失效时间 path=/; 控制相对路径下可以访问 domain=.foo.com\"; 控制相对域名可以访问 httpOnly=true; 是否只用于服务端传输，document.cookie不可取 Secure=true; 表示只会发送给https的主机 SameSite=true; 限制跨站携带cookie cookie的安全隐患 cookie是可以被篡改的，curl，nodejs等都可以发起http请求，可以设置任何头字段，容易被其欺骗 cookie的弊端 浏览器的每次请求都会携带cookie数据，会到来额外的性能开销 Cookie明文传输，安全性成问题 Cookie大小限制在4KB左右，复杂的存储需求不够用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 22:03:55 "},"knowledge/deno/":{"url":"knowledge/deno/","title":"Deno","keywords":"","body":"deno Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 17:33:49 "},"knowledge/deno/1/1.html":{"url":"knowledge/deno/1/1.html","title":"deno如何实现文件上传","keywords":"","body":" 解答 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 17:35:46 "},"knowledge/deno/2/1.html":{"url":"knowledge/deno/2/1.html","title":"deno如何解决跨域以及跨域共享cookie","keywords":"","body":" 解答 import { oakCors } from 'https://deno.land/x/cors/mod.ts' app.use(oakCors({ credentials: true, optionsSuccessStatus: 200, origin: true })) 需要配置如下两个字段： credentials: Access-Control-Allow-Credentials origin: Access-Controle-Allow-Origin Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-21 19:42:36 "},"knowledge/deno/3/1.html":{"url":"knowledge/deno/3/1.html","title":"deno与node有何不同","keywords":"","body":" 个人理解：Deno并不是下一代Node，更类似浏览器 Node的问题，作者重写deno的初衷 ES6标准引入了大量新的语法特性：Promise接口，async函数和ES模块，node的模块格式CommonJS与ES模块不兼容，迟迟无法完全支持ES模块 node的模块管理工具npm，逻辑越来越复杂，node_modules极其庞杂 node几乎没有任何安全措施，只要下载了外部模块，就只好听任别人的代码在本地运行，进行各种读写操作 node功能不完整，外部工具层出不穷，让开发者疲劳不堪：webpack，babel等 deno与node的异同 安全性 与Node相反，Deno默认在沙箱中执行代码：运行时无权访问 文件系统：allow-write, allow-read 网络：allow-net 执行其他脚本，环境变量... 模块 通过url导入代码 不需要node_modules 一旦下载无需重新下载，缓存存储在本地磁盘上，直到--reload再重新下载 浏览器兼容性 支持WEB API，尽量跟浏览器保持一致 提供window全局对象 支持fetch，worker等WEB标准 支持onload，onunload，addEventListener等事件操作函数 deno所有的异步操作，一律返回Promise deno只支持ES模块，不支持CommonJS模块（没有require命令） 骚操作： 一直使用url导入很麻烦 方案一： export * from \"https://deno.land/std/testing/mod.ts\"; import { test } from './dep.ts' 方案二： { \"import\": { \"http/\": \"https://deno.land/std/http/\" } } import { server } from \"http/server.ts\" deno run --importmap=import_map.json index.ts Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-24 15:16:47 "},"knowledge/webpack/":{"url":"knowledge/webpack/","title":"Webpack","keywords":"","body":"webpack Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-27 11:22:05 "},"knowledge/webpack/1/1.html":{"url":"knowledge/webpack/1/1.html","title":"公共模块代码如何提取？","keywords":"","body":" 解答 有三种打包方式： commonsChunkPlugin splitChunksPlugin dll commonsChunkPlugin 使用方法： entry设置vendor： entry: { entryA: './a/entryA', entryB: './b/entryB', entryC: './c/entryC', vendor: ['vue', 'vuex', 'axios'] }, plugins: [ new webpack.optimize.CommonsChunkPlugin({ name: 'vendor' }) ] 缺点 公共代码冗余：commonsChunkPlugin把公共包打成一个包，入口A只用了vue，vuex，但下载的公共包中也有axios 异步组件重复打包 spliChunksPlugin 使用方法： optimization: { minimize: true, splitChunks: { chunks: \"all\", minChunks: 1, maxAsyncRequests: 20, maxInitialRequests: 10, name: true, minSize: 30000, } }, 抽离代码是有条件的 抽离代码需要大于30KB【minSize: 3000】 按需加载应用的代码，并行请求的数量不多于5次【maxAsyncRequest: 5】 初始化加载的代码块，并行请求不多于3次【maxInitialRequest: 3】 DLLPlugin 使用方法： webpack.vendor.config.js plugins: [ entry: { vue: ['vue'], vuex: ['vuex'] }, new webpack.DllPlugin({ name: '_dll_[name]', path: path.resolve(__dirname, './dll/[name].manifest.json'), }) ] webpack.app.config.js使用引用 plugins: [ new webpack.DllReferencePlugin({ context: __dirname, manifest: require('./dll/vue.manifest.json'), }) ] 手动配置，新开一个webpack来构建公共包 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-27 16:21:58 "},"knowledge/webpack/2/1.html":{"url":"knowledge/webpack/2/1.html","title":"提高webpack构建速度","keywords":"","body":" 解答 量化工具：speed-measure-webpack-plugin 打包精准匹配： exclude/include resolve module extension module noParse externals IgnorePlugin 避免重复打包 splitChunks DllPlugin 多核打包 happypack thread-loader terser-webpack-plugin 缓存 cache-loader HardSourceWebpackPlugin webpack自身实现的优化 tree shaking speed-measure-webpack-plugin量化 这个插件会统计每个插件和loader所花费的时间 const SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\"); const smp = new SpeedMeasurePlugin(); const webpackConfig = {} module.exports = smp.wrap(webpackConfig) 指定exclude/include 对于loader指定include目录，可以有效避免编译不必要的代码 { module: { rules: [ { test: /\\.js[x]?$/, use: ['babel-loader'], include: [path.resolve(__dirname, 'src')] } ] } } webpack自由配置优化 noParse，resolve，externals { module: { noParse: /jquery|lodash/ }, resolve: { modules: path.resolve(__dirname, 'node_modules'), extensions: ['.js', '.json'] }, externals: { 'jquery': 'jQuery' } } cache-loader 在一些性能开销较大的loader之前加cache-loader，将结果缓存在磁盘中 { module: { rules: [ { test: /\\.js[x]?$/, use: ['cache-loader', 'babel-loader'] } ] } } happypack 多核处理 多个子进程并发执行，子进程处理完后再把结果发给主进程 const Happypack = require('happypack') { module: { rules: [ { test: /\\.js[x]?$/, use: 'Happypack/loader?id=js', include: [path.resolve(__dirname, 'src')] }, { test: /\\.css$/, use: 'Happypack/loader?id=css', include: [ path.resolve(__dirname, 'src'), path.resolve(__dirname, 'node_modules', 'bootstrap', 'dist') ] } ] }, plugins: [ new Happypack({ id: 'js', //和rule中的id=js对应 //将之前 rule 中的 loader 在此配置 use: ['babel-loader'] //必须是数组 }), new Happypack({ id: 'css',//和rule中的id=css对应 use: ['style-loader', 'css-loader','postcss-loader'], }) ] } thread-loader 多核打包 把thread-loader放置在其他loader之前，会开启一个单独的线程运行速度跟happypack差不多，不过优点是配置更简单 { module: { //我的项目中,babel-loader耗时比较长，所以我给它配置 thread-loader rules: [ { test: /\\.jsx?$/, use: ['thread-loader', 'cache-loader', 'babel-loader'] } ] } } terser-webpack-plugin 多核压缩 webpack默认开启了多进程和缓存 const TerserPlugin = require('terser-webpack-plugin'); module.exports = { optimization: { minimize: true, minimizer: [new TerserPlugin()], }, }; HardSourceWebpackPlugin 中间缓存 中间缓存提高非首次构建速度 var HardSourceWebpackPlugin = require('hard-source-webpack-plugin'); module.exports = { plugins: [ new HardSourceWebpackPlugin() ] } IgnorePlugin避免本地化文件和核心文件一起打包 有些项目比如moment，会把本地化文件和核心文件一起打包 module.exports = { plugins: [ new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) ] } // 使用到本地化的 地方 import moment from 'moment'; import 'moment/locale/zh-cn'; DllPlugin 抽离公共代码 见上一篇【公共模块代码如何提取？】 splitChunks 见下一篇【webpack v3到v4主要区别】 webpack自身优化 tree shaking tree shaking只是为了优化代码，不能使代码报错使用了es6的import，生产环境会自动移除没有使用到的代码 DCE：Dead Code elimination（无用代码删除） DCE消除：靠的是uglify压缩 为什么tree shaking删不掉代码 只处理函数和顶层的import/export变量，不能把没用到的类的方法消除掉 js动态语言的特性使得静态分析变的困难 Side Effect广泛存在 比如下面的👇，静态代码是无法分析的： function Menu() { } Menu.prototype.show = function() { } var a = 'Arr' + 'ay' var b if(a == 'Array') { b = Array } else { b = Menu } b.prototype.unique = function() { // 将 array 中的重复元素去除 } export default Menu; babel编译class时是通过_createClass方法，类属性时通过Object.defineProperty赋值的 为什么这样实现？=> 类内部声明的方法，是不可枚举的，而通过原型链声明的方法是可以枚举的，babel为了符合es6真正的语义 babel宽松模式 { \"presets\": [[\"env\", { \"loose\": false }]] } babel的宽松模式，类属性方法将会编译成直接在原型链上声明方法。 tree shaking上能够尽力的事 尽量不写带有副作用的代码，比如编写了自执行函数，又在函数里使用了外部变量 可以开启babel的loose（宽松）模式 如果是开发JavaScript库，请使用rollup 如果是js库，难以避免副作用代码，可以将功能函数或者组件打包成单独的文件或目录 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-27 22:15:54 "},"knowledge/webpack/3/1.html":{"url":"knowledge/webpack/3/1.html","title":"webpack v3到v4主要区别","keywords":"","body":" 解答 自动设置process.env.NODE_EVN：-mode development UglifyJsPlugin。直接配置{ optimization: { minimize: true } } CommonsChunkPlugin废弃，SplitChunksPlugin取而代之 splitChunks chunks：表示哪些代码需要优化 initial（初始块） async（按需加载块） all（全部） minSize：压缩前的最小模块大小，默认30KB minChunks：引用次数。默认为1 maxAsyncRequests：按需加载时候最大的并行加载请求数，默认为5 maxInitialRequests: 一个入口最大的并行请求数，默认为3 name：拆分出来块的名字 cacheGroups：缓存组 test：正则匹配哪些模块 priority：缓存组打包的先后优先级 reuseExstingChunk：当前代码块已有，就不再产生一个新的代码块 使用splitChunks实现CommonsChunkPlugin的功能 只打包react： optimization: { splitChunks: { chunks: 'all', cacheGroups: { vendors: { test: /react/, name: 'vendors' } } } } 打包vendor入口包括的依赖： { entry: { vendor: ['react', 'react-dom'], } optimization: { splitChunks: { chunks: 'all', cacheGroups: { vendors: { name: 'vendors', chunk: 'initial' } } } } } splitChunks缺点 第一次打包vue，vuex，后面增加了lodash，浏览器中的vendor会失效 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-27 22:03:39 "},"questions/":{"url":"questions/","title":"每日三省","keywords":"","body":"每日三省 🤔 记录每天思考的问题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 19:32:21 "},"questions/20200715.html":{"url":"questions/20200715.html","title":"2020.07.15","keywords":"","body":"20200715思考 防抖的原理是什么？ 防抖的场景有哪些？ 防抖的简易版如何实现？ 防抖的立即执行版如何实现？ 节流的原理是什么？ 节流的场景有哪些？ 节流的时间戳方式如何实现？ 节流的定时器方式如何实现？ Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 19:45:36 "},"questions/20200727.html":{"url":"questions/20200727.html","title":"2020.07.27","keywords":"","body":"20200715思考 webpack如何处理公共模块，webpack3和webpack4分别如何处理？ webpack如何优化打包速度？ webpack3到webpack4主要区别？ Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-27 22:11:37 "},"knowledge/webpack/4/1.html":{"url":"knowledge/webpack/4/1.html","title":"对 tree-shaking 的了解","keywords":"","body":" 解答 1.webpack生产模式下默认开启tree-shaking 2.由于babel把class等封装成IIFE，存在副作用导致tree-shaking失效 3.手动设置无副作用： 3.1module下的rule.sideEffects: false 3.2package.json下的sideEffects: false 4.依赖于es6 import的静态分析，函数可以被shaking 5.tree shaking的过程发生在压缩阶段 webpack由于uglify的缘故，导致babel宽松模式下的class也无法被shaking uglify可以设置pure_getters来避免获取对象属性的副作用 副作用： 一个函数会，或者可能会对函数外部变量产生影响的行为 获取对象的属性也会产生副作用 babel编译一个class class Person { constructor(name){ this.name = name; } getName () { return this.name } } 编译之后👇： var _createClass = function (constructor, protoProps) { for (let descriptor of protoProps) { descriptor.enumerable = descriptor.enumerable || !1 descriptor.configurable = !0 Object.defineProperty(constructor.prototype, descriptor.key, descriptor) } } var Person = function () { function Person (name) { this.name = name; } _createClass(Person, [{ key: 'getName', value: function getName() { return this.name; } }]); return Person; }() babel为什么这样做，要用defineProperty来赋属性，而不是定义一个function Person, Person.prototype = { getName }：因为ES6的【类内部声明的方法，是不可枚举的，而通过原型链声明的方法是可以枚举的】 babel有一种宽松模式： { \"presets\": [[\"env\", { \"loose\": false }]] } 宽松模式下class会被编译为原型链的方式，这时用rollup打包class可以被shaking掉 tree-shaking的最佳实践 将每一个组件或者功能函数，都打包成单独的文件或目录，比如Button单独打包，单独导出：babel-import-plugin 尽量不要写带有副作用的代码，比如编写了IIFE，函数里又使用了外部变量 对ES6语义不是特别严格的，可以开启babel的loose模式，rollup shaking能力提高很多 uglify有pure_getter: true的配置，不过不建议使用 React的hooks有利于tree shaking，因为tree shaking对函数的效果更好 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-29 20:00:58 "}}