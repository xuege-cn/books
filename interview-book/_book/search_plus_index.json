{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"test/":{"url":"test/","title":"每日一题","keywords":"","body":"每日一题 一天一题练习 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:33:17 "},"test/vue/":{"url":"test/vue/","title":"vue","keywords":"","body":"这里是vue专题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:11:09 "},"test/vue/1/1.html":{"url":"test/vue/1/1.html","title":"父组件监听子组件的生命周期","keywords":"","body":" 解法1: @hook @hook:搭配任意钩子函数，会在子组件触发相应生命周期钩子函数时回调父组件这个函数 解法2: $emit 这种方式比较蠢，而且是需要劳动力堆积的 mounted () { this.$emit('mounted') } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:36:45 "},"test/vue/2/1.html":{"url":"test/vue/2/1.html","title":"$set解决新增属性不能相应的问题","keywords":"","body":" 解答： 是因为Vue在实例化的过程中就需要对data中的数据使用defineProperty方法来定义存取器实现的响应式。而直接新增属性因为仍是值属性，所以是不能实现响应式的 源码实现 const isValidArrayIndex = index => { return index > 0 && Math.floor(index) === index && isFinite(index) } exprt function set (target, key, val) { if (Array.isArray(target) && isValidArrayIndex(key)) { target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } if (key in target && !(key in target.prototype)) { target[key] = val return val } const __ob__ = target.__ob__ if (!__ob__) { target[key] = val return val } else { defineReactive(__ob__.value, key, val) __ob__.dep.notify() return val } } set分为四步骤： 判断是否为数组，以及索引是否合法 Array.isArray判断target是否为数组 索引是否合法：index > 0 && Math.floor(index) === index && isFinite(index) 数组可能不够长，先把数组扩充下：target.length = Math.max(target.length, key) 通过splice往数组中添加：target.splice(key, 1, val) 判断target对象下是否已经该属性key 存在的话就是修改操作，直接target[key] = val，通过setter存取器触发notify target是否已被响应式 否：不管响应式，target[key] = val完事 已设置响应式，defineReactive(ob.value, key, val), ob.dep.notify()触发更新 defineProperty的缺点 从这个问题可以看出：defineProperty实现响应式，需要在vue实例化时对所有属性进行重定义，不然的话就不能实现响应式有点类似事件绑定时，对单个节点 Proxy的使用 let obj = { a: 1, b: 2 } let obj1 = new Proxy(obj, { get (obj, prop) { console.log(`正在获取属性：${prop}，值为：${obj[prop]}`) return obj[prop] } }) obj1.a obj1.b Proxy类似事件委托，把属性访问委托到另一个对象上，可是不具体关心是什么属性，所以在Vue实例化阶段减少了对data下所有属性进行defineProperty定义存取器 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:21:01 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:41:25 "},"knowledge/html/":{"url":"knowledge/html/","title":"Html","keywords":"","body":"Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:45:28 "},"knowledge/html/1.html":{"url":"knowledge/html/1.html","title":"Html布局元素的分类有哪些","keywords":"","body":"Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:43:46 "},"knowledge/css/":{"url":"knowledge/css/","title":"css","keywords":"","body":"Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:45:48 "},"knowledge/css/1.html":{"url":"knowledge/css/1.html","title":"css伪类与伪元素的区别","keywords":"","body":" 解答 区别： 表示方法 CSS2中伪类和伪元素都是用:声明，CSS2.1中伪类用:，伪元素用:: 浏览器同样接受CSS2时代已存在的单冒号写法，比如:before, :after等 CSS2之后所有新增的伪元素，如::selection 定义不同 伪类即假的类，可以添加类来达到效果 伪元素即假元素，需要通过添加元素才能达到效果 相同点： 同为文档树以外的\"元素\"，在html源文件中是看不到伪类和伪元素的 扩展 伪类的顺序需要遵循什么规则？LVHA：link visited hover active为了避免hover样式失效，需要遵循这样的规则定义伪类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 20:15:00 "},"knowledge/css/2.html":{"url":"knowledge/css/2.html","title":"css盒模型","keywords":"","body":" 解答 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 20:21:02 "},"knowledge/js/":{"url":"knowledge/js/","title":"javascript","keywords":"","body":"javascript javascript的知识点 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 19:10:48 "},"knowledge/js/1/1.html":{"url":"knowledge/js/1/1.html","title":"防抖节流原理，区别以及应用","keywords":"","body":" 解答 防抖 原理 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时⌛️ 场景 按钮重复点击：防止多次提交按钮，只执行最后一次提交 搜索框联想：防止联想发送请求，只发送最后一次输入 简易版实现 const debounce = fn => { let _timeout; return function (...args) { const context = this clearTimeout(_timeout) _timeout = setTimeout(() => { fn.apply(context, args) }, 1000) } } 有些时候希望立即执行，然后等到n秒后才可以重新触发 升级版 const debounce = (fn, wait, immediate) => { let timeout return function (...args) { const context = this if (immediate) { timeout = setTimeout(() => { timeout = null }, wait) !timeout && fn.apply(context, args) } else { _timeout = setTimeout(() => { fn.apply(context, args) }, wait) } } } 节流 原理 规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效 使用场景 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动 缩放场景：监控浏览器size 使用时间戳实现 function throttle (func, wait) { let previous = 0 return function (...args) { const now = Date.now() if (now - previous > wait) { func.apply(this, args) previous = now } } } 使用定时器实现 function throttle (func, wait) { let timeout return function (...args) { const context = this if (!timeout) { timeout = setTimeout(() => { timeout = null func.apply(context, args) }, wait) } } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 19:45:00 "},"knowledge/js/2/1.html":{"url":"knowledge/js/2/1.html","title":"闭包的看法，为何用闭包，原理以及应用场景","keywords":"","body":" 解答 什么是闭包？ 函数内部返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包 闭包的原理 函数执行分为两个阶段： 预编译阶段 如果发现内部函数使用了外部函数的变量，会在内存中创建一个闭包对象并保存对应的变量值 执行阶段 执行完后，函数执行上下文会被销毁，函数对闭包对象的引用也会被销毁，但其内部函数还持用该闭包的引用，所以内部函数可以继续使用外部函数中的变量 利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域中，函数执行完毕，其执行作用域销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被销毁后才能被销毁 优点 可以从内部函数访问外部函数作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用 避免变量污染全局 把变量存到独立的作用域，作为私有成员存在 缺点 对内存消耗有负面影响，因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏。可将内层函数对象的变量赋值为null来释放内存 对处理速度具有负面影响，闭包的层级决定了引用的外部变量在查找时经过的作用域链长度 可能获取到意外的值 应用场景 模块封装：自执行函数 在循环中创建闭包，防止取到意外的值 for + var + setTimeout for + onclick等事件 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 20:06:29 "},"knowledge/js/3/1.html":{"url":"knowledge/js/3/1.html","title":"实现lodash的_.get","keywords":"","body":" 解答 const get = (source, path) => { const paths = path.split('.') for (let path of paths) { source = source[path] } return source } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 21:42:58 "},"knowledge/js/4/1.html":{"url":"knowledge/js/4/1.html","title":"跨域是个什么概念","keywords":"","body":" 解答 浏览器将CORS请求分成两类：简单请求，非简单请求 简单请求 简单请求条件 满足两个条件： 请求方式是以下三种： HEAD GET POST HTTP的头信息不超过以下几种： Accept Accept-Language Content-Language Last-Event-ID Content-type: application/x-www-form-urlencoded application/form-data text/plain 这是为了兼容表单，历史上表单一直可以发出跨域请求Ajax的设计就是：只要表单可以发，Ajax就可以直接发 简单请求流程 浏览器直接发出CORS请求，在头信息中增加一个Origin字段Origin：http://api.bob.com:8080 Origin字段用来说明：本次请求来自哪个源（协议+域名+端口） 如果Origin指定的源不在许可范围内服务器会返回一个正常的HTTP响应，浏览器会发现response的头信息没有包含Access-Control-Allow-Origin字段，就知道错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200 如果Origin指定的域名在许可范围内，服务器返回的响应会多出几个头信息字段： Access-Control-Allow-Origin: * => 源数据 Access-Control-Allow-Credentials: true => 是否允许发送Cookie Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 如何获取更多跨域头信息 在Access-Control-Expose-Headers中设置XMLHttpRequest对象的getResponseHeader方法默认只能拿到6个基本字段： Cache-Control Content-Language Content-Type Expires Last-Modified Pragma 跨域如何携带Cookie XMLHttpRequest的xhr.withCredentials = true 服务端设置responseHeader的Access-Control-Allow-Credentials: true 如果要发送Cookie，Access-Control-Allow-Origin不能设置为*，必须指定明确，与请求网页一致的域名 非简单请求 那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或Content-Type为applicetion/json 预检请求 浏览器先询问服务器，当前网页域名在服务器许可名单之中，以及使用哪些HTTP动词和头信息字段，得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错 预检请求特点： 请求方式是OPTIONS 头信息Access-Control-Request-Method: PUT标明HTTP方法 头信息Access-Control-Request-Headers: Foo 逗号分隔的字符串，标明额外发送的头信息字段 与JSONP的比较 CORS功能更强大，支持所有类型HTTP请求，JSONP只支持GET请求 JSONP兼容性更好：JSONP的优势是老式浏览器，以及可以向不支持CORS的网站请求数据 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-21 21:46:30 "},"knowledge/promise/":{"url":"knowledge/promise/","title":"Promise","keywords":"","body":"Promise Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-10 16:59:16 "},"knowledge/promise/1.html":{"url":"knowledge/promise/1.html","title":"Promise.all有一个请求出错了如何回滚？","keywords":"","body":" 解答 可以使用新api -> allSettled解决，有请求出错仍会进入.then，结果格式如下👇： [ { statue: 'fullfilled', value: 1 }, { statue: 'fullfilled', value: 2 }, { statue: 'rejected', value: 3 }, ] 像vscoder插件Code Runner里面跑Promise，是没有allSettled方法的，那么可以自己实现一个👇： if (!Promise.allSettled) { Promise.allSettled = promises => { let _promises = [] for (let promise of promises) { _promises.push(promise.then(value => { return Promise.resolve({ status: 'fullfilled', value }) }).catch(value => { return Promise.resolve({ status: 'rejected', value }) })) } return Promise.all(_promises) } } Promise.allSettled([ new Promise(resolve => { setTimeout(() => resolve(1), 1000) }), new Promise(resolve => { setTimeout(() => resolve(2), 2000) }), new Promise((resolve, reject) => { setTimeout(() => reject(3), 3000) }) ]).then(res => { console.log('结果：', res) }).catch(e => { console.log('异常：', e) }) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-10 17:20:36 "},"knowledge/vue/":{"url":"knowledge/vue/","title":"Vue","keywords":"","body":"Vue Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-11 14:55:02 "},"knowledge/vue/1.html":{"url":"knowledge/vue/1.html","title":"defineProperty为什么不能对数组做监听？","keywords":"","body":" 解答 回答这个问题之前，先来回顾下defineProperty实现监听的原理：重定义属性的值属性为存取器属性，在存取器中进行访问拦截，从而实现监听 defineProperty可以监听数组吗？ 数组它有键值对，比如下面👇： const arr = [1, 2, 3] arr[0] 键为0，值为1，那么有键值对就能进行监听👇 function walk (obj) { const keys = Object.keys(obj) for (let key of keys) { defineReactive(obj, key, obj[key]) } } function defineReactive (obj, key, val) { Object.defineProperty(obj, key, { configurable: true, enumerable: true, get () { console.log(`getter: ${key}: ${val}`) return val }, set (newVal) { console.log(`setter: ${key}: ${val}: ${newVal}`) val = newVal } }) } const arr = [1, 2, 3] walk(arr) arr[0] arr[0] = 2 console.log(arr[0]) 这段代码执行输出下，可以看到也实现了数组的监听，那么为啥Vue1和2不是这么实现的呢？ defineProperty监听数组的问题 新增属性无法监听 数组的重复存取监听 新增属性无法监听 还是上面的基础代码，再来试试下面几种场景： arr[3] = 4 arr.push(4) 这些场景都无法触发存取器拦截，因为定义的索引为3的属性是属于值属性，并没有重写存取器拦截 其次如果删除了一个索引，然后重新赋值，也是一样 delete arr[1] arr[1] = 4 arr[1] 执行上面代码可以发现，set和get都没有进，很简单：因为arr[1]=4是值属性，之前的存取器属性已被删除，所以已无法拦截 数组的重复存取监听 在前面的基础代码上执行一下unshift： arr.unshift(0) 会发现控制台输出了一坨： getter: 2: 3 getter: 1: 2 setter: 2: 3: 2 getter: 0: 1 setter: 1: 2: 1 setter: 0: 1: 0 可以发现明明只是往数组头部插入了一条，可是触发了整个数组的set和get，这是非常耗费性能的 为何会这样呢？ 因为数组在内存中是连续的内存段插入了第一条的数据，后面的数据就要被往后挤，所以就导致了整个数组的get和set 哪些方法会导致数组被挤被挤有两种情况：往后挤，或者往前挤 unshift，shift，sort，reverse，splice Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-11 15:45:49 "},"knowledge/vue/2.html":{"url":"knowledge/vue/2.html","title":"Vue是如何实现的数组监听？","keywords":"","body":" 解答 鉴于defineProperty直接监听索引的两个问题： 新增属性无法监听 数组元素的重复get和set defineProperty直接监听索引这个方案就被KO了。 Vue2的数组监听实现方式 变异方法：重写数组实例的proto 监听数组中的引用对象 const arrayProto = Array.prototype const arrayMethods = Object.create(arrayProto) const methods = ['unshift', 'shift', 'push', 'pop', 'sort', 'reverse', 'splice'] methods.forEach(method => { const originalMethod = arrayMethods[method] Object.defineProperty(arrayMethods, method, { value: function (...args) { originalMethod.apply(this, args) let inserted; switch (method) { case 'unshift': case 'push': inserted = args break case 'splice': inserted = args.slice(2) break } const __ob__ = this.__ob__ if (__ob__) { if (inserted) observeArray(inserted) this.__ob__.otify() } } }) }) arr.__proto__ = arrayMethods 其次还有observeArray: function observeArray (arr) { for (let item of arr) { observe(item) } } 这种处理方式：需要使用方法去操作数组，如果使用arr[0] = 1这样仍是没用的 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-11 16:02:23 "},"knowledge/react/":{"url":"knowledge/react/","title":"React","keywords":"","body":"React Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 10:51:30 "},"knowledge/react/1/1.html":{"url":"knowledge/react/1/1.html","title":"React中setState后发生了什么？","keywords":"","body":" 解答 调用setState之后，会经历一下几步： React会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程 经过调和过程，React会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个UI界面 在React得到元素树之后，React会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染 在差异计算算法中，React能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染 setState为什么默认是异步 假如所有setState是同步的，意味着没执行一次setSTate时，都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。 setState什么时候是同步 setTimeout 原生事件 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 11:17:01 "},"knowledge/react/2/1.html":{"url":"knowledge/react/2/1.html","title":"Redux中异步的请求如何处理？","keywords":"","body":" 解答 redux-thunk 第一步：配置redux-thunk： import { createStore, applyMiddleware, compose } from 'redux' import thunk from 'redux-thunk' const enhancer = composeEnhancers(applymiddleware(thunk)) const store = createStore(reducer, enhancer) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 15:56:26 "},"knowledge/security/":{"url":"knowledge/security/","title":"Security","keywords":"","body":"安全问题 安全相关问题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 16:36:55 "},"knowledge/security/1.html":{"url":"knowledge/security/1.html","title":"协议基础知识预备","keywords":"","body":"协议基础预备知识 SSL/TLS协议运行机制 SSL/TLS为了解决什么问题？ 不使用SSL/TLS的http通信，即不加密的通信，有三大风险： 窃听风险：第三方可以获知通信内容 篡改风险：第三方可以修改通信内容 冒充风险：第三方可以冒充他人身份进行通信 SSL/TLS就是为了解决这三大风险而设计的： 所有信息加密传播，第三方无法窃听 具有校验机制，一旦被篡改，通信双方立刻会发现 配备身份证书，防止身份被冒充 TLS和SSL什么关系？ TLS是SSL的升级版：TLS1.0通常被标示为SSL3.1，TLS1.1为SSL3.2，TLS1.2为SSL3.3 基本的运行过程 公钥加密法 客户端向服务端索要公钥 用公钥加密信息 服务端收到密文后，用私钥解密 （1）如何保证公钥不被篡改？把公钥放在数字证书中，只要证书是可信的，公钥就是可信的 （2）公钥加密计算量太大，如何减少耗用的时间？ 每一次对话，客户端和服务端都生成一个对话密钥（session key），用它来加密信息 由于对话密钥是对称加密，所以运算速度非常快 服务器公钥只用于加密对话密钥本身 SSL/TLS的基本过程 客户端向服务端索要并验证公钥 客户端和服务端协商生成对话密钥 双方采用对话密钥进行通信 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 17:27:39 "},"knowledge/security/1/1.html":{"url":"knowledge/security/1/1.html","title":"https证书伪造","keywords":"","body":" 解答1 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 16:39:53 "},"knowledge/node/":{"url":"knowledge/node/","title":"node","keywords":"","body":"node Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 17:27:47 "},"knowledge/node/1/1.html":{"url":"knowledge/node/1/1.html","title":"node子进程如何使用","keywords":"","body":" Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 17:30:13 "},"knowledge/browser/":{"url":"knowledge/browser/","title":"browser","keywords":"","body":"browser Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 14:18:37 "},"knowledge/browser/1/1.html":{"url":"knowledge/browser/1/1.html","title":"渲染性能","keywords":"","body":"渲染性能 问题： 帧的概念 现在广泛使用的屏幕都有固定的刷新率（最新的一般在60Hz），在两次硬件刷新之间浏览器进行两次重绘是没有意义的只会消耗性能 渲染帧 指浏览器一次完整绘制过程 帧之间的时间间隔是DOM视图更新的最小间隔 是否意味着DOM视图更新最小时间为16ms 主流浏览器屏幕刷新率为60Hz，渲染一帧的时间必须控制在16ms之内才能保证不掉帧 浏览器执行一次渲染主要是做几件事，如下图 浏览器每帧处理流程： input event handlers: 处理事件回调，比如scroll等 requestAnimationFrame: 回调函数在下一次重绘之前执行 Parse HTML: 生成DOM tree Recalc Styles: 级联地生成每个节点地生效样式 Layout: 整合DOM tree和style tree，生成layout tree Update Layer tree: 解析层叠上下文，生成layer tree Paint: 各层分别进行绘制 Composite: 合成各层的渲染结果 掉帧的概念 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 11:57:42 "},"knowledge/deno/":{"url":"knowledge/deno/","title":"deno","keywords":"","body":"deno Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 17:33:49 "},"knowledge/deno/1/1.html":{"url":"knowledge/deno/1/1.html","title":"deno如何实现文件上传","keywords":"","body":" 解答 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-20 17:35:46 "},"knowledge/deno/2/1.html":{"url":"knowledge/deno/2/1.html","title":"deno如何解决跨域以及跨域共享cookie","keywords":"","body":" 解答 import { oakCors } from 'https://deno.land/x/cors/mod.ts' app.use(oakCors({ credentials: true, optionsSuccessStatus: 200, origin: true })) 需要配置如下两个字段： credentials: Access-Control-Allow-Credentials origin: Access-Controle-Allow-Origin Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-21 19:42:36 "},"questions/":{"url":"questions/","title":"每日三省","keywords":"","body":"每日三省 🤔 记录每天思考的问题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 19:32:21 "},"questions/20200715.html":{"url":"questions/20200715.html","title":"2020.07.15","keywords":"","body":"20200715思考 防抖的原理是什么？ 防抖的场景有哪些？ 防抖的简易版如何实现？ 防抖的立即执行版如何实现？ 节流的原理是什么？ 节流的场景有哪些？ 节流的时间戳方式如何实现？ 节流的定时器方式如何实现？ Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-15 19:45:36 "}}