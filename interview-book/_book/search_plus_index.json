{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:41:25 "},"knowledge/browser/":{"url":"knowledge/browser/","title":"Browser","keywords":"","body":"browser Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 14:18:37 "},"knowledge/browser/1/1.html":{"url":"knowledge/browser/1/1.html","title":"渲染性能","keywords":"","body":"渲染性能 问题： 帧的概念 现在广泛使用的屏幕都有固定的刷新率（最新的一般在60Hz），在两次硬件刷新之间浏览器进行两次重绘是没有意义的只会消耗性能 渲染帧 指浏览器一次完整绘制过程 帧之间的时间间隔是DOM视图更新的最小间隔 是否意味着DOM视图更新最小时间为16ms 主流浏览器屏幕刷新率为60Hz，渲染一帧的时间必须控制在16ms之内才能保证不掉帧 浏览器执行一次渲染主要是做几件事，如下图 浏览器每帧处理流程： input event handlers: 处理事件回调，比如scroll等 requestAnimationFrame: 回调函数在下一次重绘之前执行 Parse HTML: 生成DOM tree Recalc Styles: 级联地生成每个节点地生效样式 Layout: 整合DOM tree和style tree，生成layout tree Update Layer tree: 解析层叠上下文，生成layer tree Paint: 各层分别进行绘制 Composite: 合成各层的渲染结果 掉帧的概念 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 11:57:42 "},"knowledge/browser/2/1.html":{"url":"knowledge/browser/2/1.html","title":"cookie","keywords":"","body":"cookie 为什么需要cookie http是无状态的，每次用户请求到达服务端，服务器都不知道用户是谁，是否登陆过 cookie的构成 author=leo; 键值对 expires=Fri, 31 Dec 9999 23:59:59 GMT; 失效时间 path=/; 控制相对路径下可以访问 domain=.foo.com\"; 控制相对域名可以访问 httpOnly=true; 是否只用于服务端传输，document.cookie不可取 Secure=true; 表示只会发送给https的主机 SameSite=true; 限制跨站携带cookie cookie的安全隐患 cookie是可以被篡改的，curl，nodejs等都可以发起http请求，可以设置任何头字段，容易被其欺骗 cookie的弊端 浏览器的每次请求都会携带cookie数据，会到来额外的性能开销 Cookie明文传输，安全性成问题 Cookie大小限制在4KB左右，复杂的存储需求不够用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-22 22:03:55 "},"knowledge/browser/3/1.html":{"url":"knowledge/browser/3/1.html","title":"DOMContentLoaded全面解析","keywords":"","body":" DOMContentLoaded 初始HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发 什么时候算是文档加载完？ 同步javascript会暂停DOM的解析 document.addEventListener('DOMContentLoaded', function () { console.log('DOMContentLoaded:', (Date.now() - domStart)) }) const start = Date.now() while (true) { const end = Date.now() if (end - start > 5000) { break } } console.log('script loaded!') 可以发现当时间是5000时，DOMContentLoaded的时间为5048，而while的时间为1000时，DOMContentLoaded的时间为1048所以：同步的JS文档阻塞了DOM的解析 async 和 defer对于DOMContentLoaded的影响 document.addEventListener('DOMContentLoaded', function () { console.log('DOMContentLoaded:', (Date.now() - domStart)) }) const start = Date.now() while (true) { const end = Date.now() if (end - start > 5000) { break } } console.log('script loaded!') 出现了两种不同情况： async async是异步加载，加载完成便执行 document.addEventListener('DOMContentLoaded', ...)在前面，DOMContentLoaded 马上执行 在前面，就看js的下载速度了，在执行DOMContentLoaded之前下载完成，DOMContentLoaded的时间就是5048 defer 该属性用来通知浏览器该脚本将在文档完成解析后，触发DOMContentLoaded事件前执行 所以这里DOMContentLoaded时间是5048 readyState readyState是一个只读属性readyState的三种状态： loading interactive complete readyState改变的事件：document.onreadystatechange readyState跟DOMContentLoaded的关联 DOMContentLoaded事件必须是在document.readyState为loading时绑定才有效 const script = document.createElement('script') script.src=\"./test.js\" document.body.appendChild(script) console.log('test.js load') document.addEventListener('DOMContentLoaded', function () { console.log('DOMContentLoaded') }) 这个🌰 可以看到：DOMContentLoaded事件未被执行 readyState和DOMContentLoaded执行顺序： readyState: loading ↓ readyState: interctive ↓ DOMContentLoaded事件 ↓ readyState: complete ↓ load事件 js代码放在文档最后 此时js是不需要像下面这样写的 $(document).ready(function() { // 少年的你，代码写在这里... }); 其实js在文档最后，文档已经解析好了，所以只需要像下面这样写就行了： (function() { // 这里代码... })(); 优点是：执行时机更快 readyState现在还有啥锤子用？ 判断时机为loading，绑定DOMContentLoaded事件 if (document.readyState != 'loading') { init(); } else { window.addEventListener(\"DOMContentLoaded\", function () { init(); }); } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-08-31 16:47:34 "},"knowledge/browser/4/1.html":{"url":"knowledge/browser/4/1.html","title":"web通信","keywords":"","body":" web通信方式 跨文档通信：window.postMessage 通道通信：MessageChannel postMessage跨文档通信 三个参数： message：将要发送的数据 targetOrigin：目标源 transfer：Transfer对象（ArrayBuffer ｜ MessagePort ｜ ImageBitmap） // 父html // 1.html document.forms.addEventListener('submit', () => { const message = document.querySeletor('input[type=\"text\"]').value window.parent.frames[1].postMessage(message) }) window.addEventListener('message', msg => { alert('接收到消息：' + msg.data) }) otherWindow.postMessage(message, targetOrigin, [transfer]) otherWindow： iframe的contentWindow属性 window.open返回的窗口对象 window.frames targetOrigin: 同源（协议，域名，端口）或者 * 跨文档通信 + 通道通信 通过postMessage来传输channel.port // 1.html const mc = new MessageChannel() mc.port2.onmessage = data => { console.log('channel resceive message: ', data) } window.parent.postMessage('来自1.html的消息', '*', [mc.port1]) // test.html window.onmessage = msg => { window.frames[1].postMessage('来自test.html的消息', '*', msg.ports) } // 2.html window.onmessage = msg => { msg.ports[0].postMessage('hello from 2.html') } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-01 17:32:33 "}}