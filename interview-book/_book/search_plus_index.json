{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球 🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-27 10:37:32 "},"interview/vue/":{"url":"interview/vue/","title":"vue","keywords":"","body":"这里是vue专题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:11:09 "},"interview/vue/1/1.html":{"url":"interview/vue/1/1.html","title":"父组件监听子组件的生命周期","keywords":"","body":" 解法1: @hook @hook:搭配任意钩子函数，会在子组件触发相应生命周期钩子函数时回调父组件这个函数 解法2: $emit 这种方式比较蠢，而且是需要劳动力堆积的 mounted () { this.$emit('mounted') } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:36:45 "},"interview/vue/2/1.html":{"url":"interview/vue/2/1.html","title":"$set解决新增属性不能相应的问题","keywords":"","body":" 解答： 是因为Vue在实例化的过程中就需要对data中的数据使用defineProperty方法来定义存取器实现的响应式。而直接新增属性因为仍是值属性，所以是不能实现响应式的 源码实现 const isValidArrayIndex = index => { return index > 0 && Math.floor(index) === index && isFinite(index) } exprt function set (target, key, val) { if (Array.isArray(target) && isValidArrayIndex(key)) { target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } if (key in target && !(key in target.prototype)) { target[key] = val return val } const __ob__ = target.__ob__ if (!__ob__) { target[key] = val return val } else { defineReactive(__ob__.value, key, val) __ob__.dep.notify() return val } } set分为四步骤： 判断是否为数组，以及索引是否合法 Array.isArray判断target是否为数组 索引是否合法：index > 0 && Math.floor(index) === index && isFinite(index) 数组可能不够长，先把数组扩充下：target.length = Math.max(target.length, key) 通过splice往数组中添加：target.splice(key, 1, val) 判断target对象下是否已经该属性key 存在的话就是修改操作，直接target[key] = val，通过setter存取器触发notify target是否已被响应式 否：不管响应式，target[key] = val完事 已设置响应式，defineReactive(ob.value, key, val), ob.dep.notify()触发更新 defineProperty的缺点 从这个问题可以看出：defineProperty实现响应式，需要在vue实例化时对所有属性进行重定义，不然的话就不能实现响应式有点类似事件绑定时，对单个节点 Proxy的使用 let obj = { a: 1, b: 2 } let obj1 = new Proxy(obj, { get (obj, prop) { console.log(`正在获取属性：${prop}，值为：${obj[prop]}`) return obj[prop] } }) obj1.a obj1.b Proxy类似事件委托，把属性访问委托到另一个对象上，可是不具体关心是什么属性，所以在Vue实例化阶段减少了对data下所有属性进行defineProperty定义存取器 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:21:01 "},"interview/vue/3/1.html":{"url":"interview/vue/3/1.html","title":"自定义指令实现图片懒加载","keywords":"","body":" 图片懒加载的三种实现方式 scroll事件 + getBoundingClientRect const imgs = document.getElementsByTagName('img') const body = document.body function imgLoad () { for (let img of imgs) { const clientRect = img.getBoundingClientRect() if (clientRect.bottom { timer = null func.apply(this, args) }, wait) } } } document.addEventListener('scroll', throttle(imgLoad, 0)) imgLoad() InsectionObserver const imgs = document.getElementsByTagName('img') const intersectionObserver = new IntersectionObserver(function(entries) { for (let entry of entries) { if (entry.intersectionRatio > 0) { const target = entry.target target.style.height = 'auto' target.src = target.getAttribute('data-src') intersectionObserver.unobserve(target) } } }) for (let img of imgs) { intersectionObserver.observe(img) } 浏览器原生支持loading=\"lazy\" Vue自定义指令 + 图片懒加载 模版： const intersectionObserver = new IntersectionObserver(function(entries) { for (let entry of entries) { if (entry.intersectionRatio > 0) { const target = entry.target target.style.height = 'auto' target.src = target.getAttribute('data-src') intersectionObserver.unobserve(target) } } }) directives: { lazy: { inserted: function (el) { intersectionObserver.observe(el) } } } directive的钩子函数 bind：指令第一次绑定到元素时调用 inserted：元素插入父节点时调用 update：所在组件VNode更新时调用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-03 15:50:13 "},"interview/vue/4/1.html":{"url":"interview/vue/4/1.html","title":"keep-alive","keywords":"","body":"keep-alive如何实现组件缓存 keep-alive 介绍 keep-alive 是 vue 的一个内置组件，主要接收三个参数，include，exclude 和 max，include 和 exclude 可以接收 String，RegExp， Array 三种类型数据，用以匹配组件 Name，max 表示最多保存实例个数，若超过这个数字，已缓存组件中最久没有被访问的实例会被销毁掉 keep-alive的使用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 14:29:40 "},"interview/vue/5/1.html":{"url":"interview/vue/5/1.html","title":"next-tick","keywords":"","body":"next-tick next-tick的作用 next-tick 就是丢一个任务进去，在空闲的时候去执行 next-tick的自定义实现 let timerFunc; let callbacks = []; function nextTick (cb, ctx) { const callback = () => { cb.call(ctx); } callbacks.push(callback); timerFunc(); } if (typeof Promise !== 'undefined') { const p = Promise.resolve(); timerFunc = () => { p.then(flushCallbacks); } } else if (typeof MutationObserver !== 'undefined') { let count = 1; const mo = new MutationObserver(flushCallbacks); const textNode = document.createTextNode(); mo.observe(textNode, { characterData: true }); timerFunc = () => { count = 1 - count; textNode.data = String(count); } } else if (typeof setImmediate === 'function') { timerFunc = setImmediate(flushCallbacks); } else if (typeof setTimeout === 'function') { timerFunc = setTimeout(flushCallbacks, 0); } function flushCallbacks () { let cbs = callbacks.slice(0); for (let cb of cbs) { cb(); } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-15 15:33:52 "},"interview/vue/6/1.html":{"url":"interview/vue/6/1.html","title":"vue如何做编译时优化AOT？","keywords":"","body":" JIT 即时编译：just-in-time compile React 的模版中允许写 js 代码，然而 vue 的模版中不允许写 js 代码 React 是即时编译，会在执行时把 jsx 编译为 js 代码 Vue 是即时编译兼运行前编译，就看 $options.render 是否存在，存在为运行前编译，反之即时编译 AOT 运行前编译：Ahead-of-time compile Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-22 16:57:59 "},"interview/vue/7/1.html":{"url":"interview/vue/7/1.html","title":"如何给Vue定义全局方法","keywords":"","body":" 解答 Vue.prototype Vue.prototype.call = () => console.log('call') mixin 方式 const mixin = { methods: { call () { console.log('call') } } } Vue.mixin(mixin) Plugin 方式 const plugin = { install (Vue) { Vue.prototype.$call = () => { console.log('call') } } } Vue.use(plugin) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 18:30:17 "},"interview/vue/8/1.html":{"url":"interview/vue/8/1.html","title":"响应式与cteated，$mount，mounted","keywords":"","body":" 以上代码模版中渲染的是什么值？ 解答 模版中显示为1 vue实例化的顺序是： initState：observe(options.data) callHook(vm, 'created') vm.$mount callHook(vm, 'mounted') 原因： 最先执行observe，所以在 created 和 mounted 添加的属性，都不是响应式属性 created 在 $mount 之前执行，$mount 挂载时值已经是1，所以渲染时为1 mounted 时把 b 改为了2，可是属性没有被 observe，且并没有重新渲染，所以还是1 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-04 16:12:47 "},"interview/vue/9/1.html":{"url":"interview/vue/9/1.html","title":"vue-router 使用","keywords":"","body":"vue-router 使用 动态路由匹配 /user/:id 匹配 /user/foo, /user/bar, this.$router.params.id 获取参数 响应路由参数变化 从 /user/foo 到 /user/bar，User 组件会被复用，因为是同一组件，复用比销毁重建更高效，但是组件的生命周期钩子不会再被调用如果想对路由参数变化作出响应，如下👇： 方案一： watch: { $route (to, from) { // 监听路由参数变化 } } 方案二：导航守卫 beforeRouteUpdate (to, from, next) { next() } 匹配任意路由 { path: '*', path: 'user-*' } 匹配优先级 谁在前面谁的优先级高 编程式导航 - this.$router - push - replace - go 命名路由 User router.push({ name: 'user', params: { userId: 123 }}) 路由组件传参解耦 在组件中使用 $router.params.id 是很不优雅的，使得组件和特定路由产生了耦合 { path: '/user', component: User, props: true } User组件 User {{id}} 通过设置 props 参数，把路由参数映射到组件的 props 中 HTML5 history模式 hash 模式： 丑，兼容性好，是 vue 的默认模式history 模式：兼容性差，后端需要配置：http://oursite.com/user/id 会找不到页面 nginx: location / { try_files $uri $uri/ /index.html; } 导航守卫 beforeEach beforeResolve afterEach 路由配置独享 { path: '/user', beforeEnter (to, from, next) {} } 组件内的守卫 beforeRouteEnter beforeRouteUpdate beforeRouteLeave 路由元信息 { path: '/user', meta: { requiresAuth: true } } 从 $route.matched[0].meta 路由过渡动效 slide fade slide-right slide-left 路由与数据获取 路由守卫 beforeRouterUpdate watch: { '$route': 'fetchData' } 滚动行为 new VueRouter({ scrollBehavior (to, from, savedPosition){ return { x: 0, y: 0 } return savedPosition } }) 路由懒加载 将多个同名称的异步块组合到一起 const Bar = () => import(/* webpackChunkName: \"bar\" */ './Bar.vue') const Baz = () => import(/* webpackChunkName: \"bar\" */ './Baz.vue') Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-14 19:20:20 "},"interview/vue/10/1.html":{"url":"interview/vue/10/1.html","title":"vue-router完全解析","keywords":"","body":" 思考下 VueRouter 实现根本 popstate 或 hashchange 监听路由变化 获取到新的路由，从路由配置中获取对应组件 路由可能有好几层，所以需要匹配到多个组件 matched 获取到新的路由，需要刷新 UI，使用 Vue.util.defineReactive(this, '_route', this.router.history.current) 通过改变 current 中的 path 和 matched 使 UI 刷新 Link 组件主要是替换为 a，然后在点击使 preventDefault，然后调用 history.push(this.to) 跳转新路由 调用 history.push 改变路由，会使 hash 等监听到变化，调用 transitionTo 获取新的 current View 组件主要是去获取 history.current, 然后通过 createElement 创建路由对应的 UI 多层路由的情况，需要维护 depth 记录层级，每当实例化 View 时，把当前组件在 $vnode.data.routerView 标记为 true，遍历父组件，每当遇到 routerView: true，depth+1, 从而实现多层级路由 vue-router如何使用 routes声明 每个路由主要是四个属性：name，path，component，children const routes = [ { name: 'Home', path: '/home', component: Home, children: [ { name: 'Tel', path: 'tel', component: Tel, }, { name: 'About', path: 'about', component: About, }, ], }, { name: 'Foo', path: '/foo', component: Foo, }, { name: 'Bar', path: '/bar', component: Bar, } ] 通过 routes 实例化 router import VueRouter from 'vue-router' const router = new VueRouter({ mode: 'hash | history', routes }) Vue 使用 router Vue.use(VueRouter) new Vue({ router, render: h => h(App) }).$mount('#app') 实现分析 从 VueRouter 使用分析实现 Vue.use(VueRouter) new VueRouter({ mode: 'hash', routes }) VueRouter 是个类 VueRouter 有个静态方法 install 从组件实例属性分析 - Root - _route - path: /home/tel - matched: [{ path: '/home', component:... }, { path: '/home/tel', component:... },] - _router - app - history - current: { path: '/home/tel', matched:[...] } - listeners: - router - matcher - addRoutes - match - beforeHooks - afterHooks - _routerRoot - Home - $vnode - data - routerView: true - _routerRoot _routerRoot 是根组件，可以发现每个组件上都维护了 _routerRoot _router 是 VueRouter 实例，只有根组件维护 _route 也只有根组件维护，是个匹配器匹配到的结果 什么时候来混入 _routerRoot 和 _router 呢？使用原型 Vue.prototype 过于暴力，可以使用 Vue.mixin Vue.mixin 混入 _routerRoot 和 _router VueRouter.install = function (Vue) { Vue.mixin({ beforeCreate () { if (this.$options.router) { this._routerRoot = this this._router = this.$options.router this._router.init(this) Vue.util.defineReactive(this, '_router', this.router.history.current) } else { this._routerRoot = this.$parent && this.$parent._routerRoot } } }) } VueRouter 实现 import RouterLink from './components/link' import RouterView from './components/view' import HashHistory from './history/HashHistory' import BrowserHistory from './history/BrowserHistory' import createMatcher from './matcher/create-matcher' class VueRouter { constructor (options) { this.mode = options.mode; this.matcher = createMatcher(options.routes); switch (this.mode) { case 'hash': this.history = new HashHistory(this); break; case 'history': this.history = new BrowserHistory(this); break; } } init (app) { this.app = app; const history = this.history; history.transitionTo( history.getCurrentLocation(), history.setupListener.bind(history) ); } addRoutes (routes) { this.matcher.addRoutes(routes); } push (location) { this.history.push(location) } } VueRouter.install = function (Vue) { Vue.mixin({ beforeCreate () { if (this.$options.router) { this._routerRoot = this; this._router = this.$options.router this._router.init(this) Vue.util.defineReactive(this, '_route', this._router.history.current) } else { this._routerRoot = this.$parent && this.$parent._routerRoot } } }) Vue.component('router-link', RouterLink); Vue.component('router-view', RouterView); } export default VueRouter 路由拍平 function createMatcher (routes) { let { pathMap } = createPathMap(routes); function addRoutes (routes) { createPathMap(routes, pathMap); console.log('【匹配器】路由拍平：', pathMap) } function match (path, _route) { let matched = [] let record = pathMap[path] if (record) { matched.push(record) while(record.parent) { matched.unshift(record.parent) record = record.parent } } _route.path = path _route.matched = matched return _route; } console.log('【匹配器】路由拍平：', pathMap) return { addRoutes, match } } function createPathMap (routes, oldPathMap, parent) { let pathMap = oldPathMap || {}; for (let router of routes) { const children = router.children const path = parent ? `${parent.path}/${router.path}` : router.path pathMap[path] = { ...router, path, parent }; children && createPathMap(children, pathMap, router); } return { pathMap } } export default createMatcher history 实现 // Base.js class Base { constructor (router) { this.router = router this.current = {}; } transitionTo (path, handler) { this.current = this.router.matcher.match(path, this.current) handler && handler(); } } export default Base; // BrowserHistory.js import Base from './Base' class BrowserHistory extends Base { constructor (router) { super(router) } getCurrentLocation () { return window.location.pathname } setupListener () { window.addEventListener('popstate', () => { this.transitionTo( this.getCurrentLocation() ) }) } push (location) { history.pushState({}, '', location) } } export default BrowserHistory; // HashHistory.js import Base from './Base' function ensureSlash () { if (window.location.hash) { return; } window.location.hash = '/' } class HashHistory extends Base { constructor (router) { super(router) ensureSlash() } getCurrentLocation () { return window.location.hash.slice(1) } setupListener () { window.addEventListener('hashchange', () => { this.transitionTo( this.getCurrentLocation() ) }) } push (location) { window.location.hash = location; } } export default HashHistory; RouterLink RouterView 组件实现 // RouterLink.js const Link = { props: { to: String, }, render (h) { return h( 'a', { attrs: { href: this.to }, on: { click: this.clickEvt } }, [ this.$slots.default ] ) }, methods: { clickEvt (e) { e.preventDefault(); this._routerRoot._router.push(this.to); } } } export default Link; // RouterView.js const View = { functional: true, render (createElement, context) { let depth = 0; let comp = context.parent const matched = comp._routerRoot._router.history.current.matched; let parent = comp.$parent while (parent) { const vnode = parent.$vnode if (vnode && vnode.data.routerView) { depth++ } parent = parent.$parent } if (Array.isArray(matched)) { const router = matched[depth] comp.$vnode.data.routerView = true if (router) { return createElement(router.component) } } } } export default View; 路由守卫 // 添加守卫 router.beforeHook((to, from, next) => { console.log('路由：', to, from) setTimeout(() => { console.log(1); next(); }, 1000) }) router.beforeHook((to, from, next) => { console.log('路由：', to, from) setTimeout(() => { console.log(2); next(); }, 1000) }) // 在跳转之前，执行守卫，最后再跳转 transitionTo (path, handler) { const updateRouter = () => { this.current = this.router.matcher.match(path, this.current || {}) handler && handler(); } const runHooks = () => { const from = this.current.path const beforeHooks = this.router.beforeHooks if (beforeHooks && beforeHooks.length) { beforeHooks.reduce((prev, current, idx) => { let next = current if (idx === (beforeHooks.length - 1)) { next = () => current(path, from, updateRouter) } return prev ? prev(path, from, next) : current; }) } } (this.current ? runHooks : updateRouter)() } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-12-14 17:20:20 "}}