{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-06 19:41:25 "},"knowledge/typescript/":{"url":"knowledge/typescript/","title":"typescript","keywords":"","body":"Typescript Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-18 16:43:34 "},"knowledge/typescript/1/1.html":{"url":"knowledge/typescript/1/1.html","title":"编译上下文","keywords":"","body":"编译上下文 告诉Typescript哪些文件有效，哪些是无效的 基础 项目根目录下创建tsconfig.json {} 此目录和子目录下的所有.ts文件会被作为编译上下文的一部分 编译 运行tsc，会在当前目录或者父级目录寻找tsconfig.json tsc -p ./path-to-project-directory tsc -w 观测模式 显示指定编译哪些文件 具体指定某个文件 { files: [ \"./some/file.ts\" ] } 指定include和exclude文件或文件夹 { include: [ \"./folder\" ], exclude: [ \"./folder/someFolder\", \"./folder/index.ts\" ] } 其他的配置项 { \"compilerOptions\": { /* 基本选项 */ \"target\": \"es5\", // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' \"lib\": [], // 指定要包含在编译中的库文件 \"allowJs\": true, // 允许编译 javascript 文件 \"checkJs\": true, // 报告 javascript 文件中的错误 \"jsx\": \"preserve\", // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react' \"declaration\": true, // 生成相应的 '.d.ts' 文件 \"sourceMap\": true, // 生成相应的 '.map' 文件 \"outFile\": \"./\", // 将输出文件合并为一个文件 \"outDir\": \"./\", // 指定输出目录 \"rootDir\": \"./\", // 用来控制输出目录结构 --outDir. \"removeComments\": true, // 删除编译后的所有的注释 \"noEmit\": true, // 不生成输出文件 \"importHelpers\": true, // 从 tslib 导入辅助工具函数 \"isolatedModules\": true, // 将每个文件作为单独的模块 （与 'ts.transpileModule' 类似）. /* 严格的类型检查选项 */ \"strict\": true, // 启用所有严格类型检查选项 \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错 \"strictNullChecks\": true, // 启用严格的 null 检查 \"noImplicitThis\": true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \"alwaysStrict\": true, // 以严格模式检查每个模块，并在每个文件里加入 'use strict' /* 额外的检查 */ \"noUnusedLocals\": true, // 有未使用的变量时，抛出错误 \"noUnusedParameters\": true, // 有未使用的参数时，抛出错误 \"noImplicitReturns\": true, // 并不是所有函数里的代码都有返回值时，抛出错误 \"noFallthroughCasesInSwitch\": true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ \"moduleResolution\": \"node\", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6) \"baseUrl\": \"./\", // 用于解析非相对模块名称的基目录 \"paths\": {}, // 模块名到基于 baseUrl 的路径映射的列表 \"rootDirs\": [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \"typeRoots\": [], // 包含类型声明的文件列表 \"types\": [], // 需要包含的类型声明文件名列表 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \"sourceRoot\": \"./\", // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 \"mapRoot\": \"./\", // 指定调试器应该找到映射文件而不是生成文件的位置 \"inlineSourceMap\": true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \"inlineSources\": true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ \"experimentalDecorators\": true, // 启用装饰器 \"emitDecoratorMetadata\": true // 为装饰器提供元数据的支持 } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-18 16:58:11 "},"knowledge/typescript/2/1.html":{"url":"knowledge/typescript/2/1.html","title":"配置项","keywords":"","body":"配置项 target { \"target\": \"ES6\" } 比如 const tag = Symbol('tag') target配置为ES6时可以正常编译，配置为ES5及以下时，tsc编译会报错 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-22 16:49:21 "},"knowledge/typescript/3/1.html":{"url":"knowledge/typescript/3/1.html","title":"声明空间","keywords":"","body":"声明空间 ts中存在两种声明空间： 类型声明空间 变量声明空间 类型声明空间 class Foo {} interface Bar {} type Bas = {} // 可以作为类型注解使用： let foo: Foo let bar: Bar let bas: Bas // 但不能作为变量使用： const bar = Bar ❌ 变量声明空间 class Foo {} const someVar = Foo // 一些用var声明的变量，只能在变量声明空间使用。不能用作类型注解 const foo = 123; let bar: foo ❌ 一些如interface定义的内容不能当作变量使用 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-22 17:12:36 "},"knowledge/typescript/4/1.html":{"url":"knowledge/typescript/4/1.html","title":"模块","keywords":"","body":"模块 全局模块 在相同的项目不同文件，ts类型系统允许使用变量 // 1.ts const a = '123' // 2.ts const a = '123' ❌ 将会报错，a已被声明 文件模块 在ts文件根级别位置含有import或export，那么会在文件中创建一个本地的作用域 export const a = '123' 这就会转为文件模块了，变量a不会与其他文件中的变量a冲突 模块路径 相对模块路径 import foo from '../foo' 动态查找 import foo from 'foo' ./node_module/foo ../node_module/foo 后缀搜索规则 import foo from './foo' foo是个文件：foo.ts foo是个文件夹 foo/index.ts foo/package.json 重写类型动态查找 // 重写类型动态查找 declare module 'foo' { export var bar: number } import * as foo from 'foo' 配置项 module typescript的模块编译：commonjs，amd，system，umd，es2015这几种方式打包出来的效果： // commonjs exports.__esModule = true; exports.arr = void 0; exports.arr = [1, 2, 3]; // amd define([\"require\", \"exports\"], function (require, exports) { \"use strict\"; exports.__esModule = true; exports.arr = void 0; exports.arr = [1, 2, 3]; }); // system System.register([], function (exports_1, context_1) { \"use strict\"; var arr; var __moduleName = context_1 && context_1.id; return { setters: [], execute: function () { exports_1(\"arr\", arr = [1, 2, 3]); } }; }); // umd (function (factory) { if (typeof module === \"object\" && typeof module.exports === \"object\") { var v = factory(require, exports); if (v !== undefined) module.exports = v; } else if (typeof define === \"function\" && define.amd) { define([\"require\", \"exports\"], factory); } })(function (require, exports) { \"use strict\"; exports.__esModule = true; exports.arr = void 0; exports.arr = [1, 2, 3]; }); // es2015 export var arr = [1, 2, 3] Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-22 17:54:55 "},"knowledge/typescript/5/1.html":{"url":"knowledge/typescript/5/1.html","title":"命名空间","keywords":"","body":"命名空间 namespace Utility { export function log () {} export function error () {} } Utility.log('Call me') Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-22 18:56:58 "},"knowledge/typescript/6/1.html":{"url":"knowledge/typescript/6/1.html","title":"动态导入表达式","keywords":"","body":"动态导入表达式 使用module: esnext选项：ts保留import()语句，用于webpack Code Splitting import('moment').then(moment => { const time = moment().format() }) // tsconfig.json配置 { \"compilerOptions\": { \"module\": \"esnext\" } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-22 19:02:12 "},"knowledge/typescript/7/1.html":{"url":"knowledge/typescript/7/1.html","title":"类型注解","keywords":"","body":"类型注解 原始类型：string，number，boolean 数组：boolean[] 接口： interface name = { firstName: string; lastName: string; } 内联类型注解： let name: { firstName: string; lastName: string; } 特殊类型： undefined, null, any, void 泛型： function reverse(items: T[]): T[] {} interface Array { reverse(): T[]; } 联合类型： let conmand: string[] | string Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-22 19:26:07 "},"knowledge/webpack/5/1.html":{"url":"knowledge/webpack/5/1.html","title":"HMR原理","keywords":"","body":" webpack热更新自定义实现 服务端要做三件事： compiler 相关四件事 compiler 增加 done 钩子函数，编译完成记录 hash 值，并 socket 广播 更新 compiler.options.entry 注入 webpack-dev-server/client.js 和 webpack/hot/dev-server.js 调用 compiler.hooks.entryOption.call(config.context, config.entry) 更新 entry compiler 以 watch 模式启动 compiler 文件系统使用 memory-fs 启动服务器配置路由 express 方式启动服务器 配置路由中间件 文件系统使用 memory-fs 启动 socket 服务 以 server 为基础启动socket.io 监听连接，保存 socket，广播 hash 和 ok 客户端要做的三件事： 注入的 webpack-dev-server/client/index.js 建立 socket 连接，监听 hot，hash，ok 事件 hash 事件保存 hash 值 hot 事件改变 hot 变量 ok 事件中发布 webpackHotUpdate 事件 注入的 webpack/hot/dev-server.js 订阅 webpackHotUpdate 事件，回调中执行 module.hot.check，传入 hash 值 webpack 打包代码 在 module 对象上增加三个属性 hot: { accept, check } parents children hotCreateRequire 封装 webpack_require，维护 parents 和 children 属性 hotCheck 发起 xhr 请求 ${hash}.hot-update.json，返回{ hash, c: { main: true } } 创建 script 发起文件补丁 jsonp 请求 ${chunkName}.${hash}.hot-update.js jsonp 加载进入 webpackHotUpdate，返回数据(chunkId, { chunkName: function () { 新代码 } }) 更新 modules 中的老代码 从缓存中获取各个 chunk 的老 module 删除缓存上的老 module 从老 module 的父 module 上找到 accept 回调并执行 具体代码实现：我的示例tips： 补丁文件是通过 webpack.HotModuleReplacementPlugin 插件生成的 webpack热更新的使用 主文件: // index.js const input = document.createElement('input') document.body.append(input) const div = document.createElement('div') document.body.append(div) function render () { const data = require('./mock.js') div.innerHTML = data } render() if (module.hot) { module.hot.accept(['./mock.js'], render) } // mock.js module.exports = 'hello world' webpack配置文件： devServer: { hot: true } 依靠module.hot以及devServer.hot就可以实现webpack热更新了 webpack热更新服务端的实现 服务端也即webpack-dev-server，服务端做了哪些事呢？ setupApp，创建express实例 updateCompiler，会往前端js中注入另外两个js setupHooks，监听hooks编译完成事件，编译完成需要干什么呢？ 存储hash值 广播所有socket hash值，以及ok setupDevMiddleware watch方式启动compiler 返回路由中间件 routes，app.use传入路由中间件，进行路由 createServer，通过express实例app创建server createSocketServer，通过server实例创建socket.io服务 下面来实现下： webpack-dev-server启动文件 const Server = require('./server') const webpack = require('webpack') const config = require('webpack.config.js') const compiler = webpack(config) const server = new Server(compiler) server.listen(9090, () => { console.log('服务器在端口9090启动了') }) setupApp 创建express实例 const express = require('express') setupApp () { this.app = express() } updateCompiler 往客户端注入js const path = require('path') function updateCompiler (compiler) { const config = compiler.options config.entry = { main: [ path.resolve(__dirname, './client/index.js'), path.resolve(__dirname, './hot/dev-server.js'), config.entry ] } } setupHooks 挂载compiler.hooks.done钩子函数，打包完成执行： 存储hash值 向各个socket广播两个事件：hash，oksetupHooks () { const { compiler } = this compiler.hooks.done.tap(stats => { this.currentHash = stats.hash this.clientSocketList.forEach(socket => { socket.emit('hash', stats.hash) socket.emit('ok') }) }) } setupDevMiddleware 两个作用： 以watch方式启动compiler 路由 把webpack的文件输入系统改为memory-fs，相同路由读取也从memory-fs读取 this.middleware = this.setupDevMiddleware() const mime = require('mime') const path = require('path') const MemoryFs = require('memory-fs') setupDevMiddleware () { const { compiler } = this const staticDir = compiler.options.output.path compiler.watch({}, () => { console.log('compiler监听模式启动') }) const fs = new MemoryFs() this.fs = compiler.outputFileSystem = fs return (req, res, next) => { let { url } = req if (url === '/favicon.ico') { res.senStatus(404) } url === '/' ? url = '/index.html' : null const filePath = path.resolve(staticDir, url) try { let statObj = this.fs.statSync(filePath) if (statObj.isFile()) { const content = this.fs.readFileSync(filePath) res.setHeader('Content-Type', mime.getType(filePath)) res.send(content) } else { res.senStatus(404) } } catch (e) { res.sendStatus(404) } } } routes 设置路由 routes () { const { app, middleware } = this app.use(middleware) } createServer createServer () { const { app } = this this.server = http.createServer(app) } createSocketServer createSocketServer () { const { server } = this const io = socketIO(server) io.on('connection', socket => { socket.emit('hash', this.currentHash) socket.emit('ok') this.clientSocketList.push(socket) io.on('disconnect', () => { const index = this.clientSocket.indexOf(socket) this.clientSocketList.spilce(index, 1) }) }) } Server构造函数 constructor () { this.setupApp(); updateCompiler(); this.clientSocketList = []; this.setupHooks(); this.setupDevMiddleware(); this.routes(); this.createServer(); this.createSocketServer(); } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-23 17:38:11 "}}