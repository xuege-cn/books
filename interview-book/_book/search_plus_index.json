{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球 🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-27 10:37:32 "},"knowledge/webpack/":{"url":"knowledge/webpack/","title":"Webpack","keywords":"","body":"webpack Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-27 11:22:05 "},"knowledge/webpack/1/1.html":{"url":"knowledge/webpack/1/1.html","title":"公共模块代码如何提取？","keywords":"","body":" 解答 有三种打包方式： commonsChunkPlugin splitChunksPlugin dll commonsChunkPlugin 使用方法： entry设置vendor： entry: { entryA: './a/entryA', entryB: './b/entryB', entryC: './c/entryC', vendor: ['vue', 'vuex', 'axios'] }, plugins: [ new webpack.optimize.CommonsChunkPlugin({ name: 'vendor' }) ] 缺点 公共代码冗余：commonsChunkPlugin把公共包打成一个包，入口A只用了vue，vuex，但下载的公共包中也有axios 异步组件重复打包 spliChunksPlugin 使用方法： optimization: { minimize: true, splitChunks: { chunks: \"all\", minChunks: 1, maxAsyncRequests: 20, maxInitialRequests: 10, name: true, minSize: 30000, } }, 抽离代码是有条件的 抽离代码需要大于30KB【minSize: 3000】 按需加载应用的代码，并行请求的数量不多于5次【maxAsyncRequest: 5】 初始化加载的代码块，并行请求不多于3次【maxInitialRequest: 3】 DLLPlugin 使用方法： webpack.vendor.config.js plugins: [ entry: { vue: ['vue'], vuex: ['vuex'] }, new webpack.DllPlugin({ name: '_dll_[name]', path: path.resolve(__dirname, './dll/[name].manifest.json'), }) ] webpack.app.config.js使用引用 plugins: [ new webpack.DllReferencePlugin({ context: __dirname, manifest: require('./dll/vue.manifest.json'), }) ] 手动配置，新开一个webpack来构建公共包 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-27 16:21:58 "},"knowledge/webpack/2/1.html":{"url":"knowledge/webpack/2/1.html","title":"提高webpack构建速度","keywords":"","body":" 解答 量化工具：speed-measure-webpack-plugin 打包精准匹配： exclude/include resolve module extension module noParse externals IgnorePlugin 避免重复打包 splitChunks DllPlugin 多核打包 happypack thread-loader terser-webpack-plugin 缓存 cache-loader HardSourceWebpackPlugin webpack自身实现的优化 tree shaking speed-measure-webpack-plugin量化 这个插件会统计每个插件和loader所花费的时间 const SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\"); const smp = new SpeedMeasurePlugin(); const webpackConfig = {} module.exports = smp.wrap(webpackConfig) 指定exclude/include 对于loader指定include目录，可以有效避免编译不必要的代码 { module: { rules: [ { test: /\\.js[x]?$/, use: ['babel-loader'], include: [path.resolve(__dirname, 'src')] } ] } } webpack自由配置优化 noParse，resolve，externals { module: { noParse: /jquery|lodash/ }, resolve: { modules: path.resolve(__dirname, 'node_modules'), extensions: ['.js', '.json'] }, externals: { 'jquery': 'jQuery' } } cache-loader 在一些性能开销较大的loader之前加cache-loader，将结果缓存在磁盘中 { module: { rules: [ { test: /\\.js[x]?$/, use: ['cache-loader', 'babel-loader'] } ] } } happypack 多核处理 多个子进程并发执行，子进程处理完后再把结果发给主进程 const Happypack = require('happypack') { module: { rules: [ { test: /\\.js[x]?$/, use: 'Happypack/loader?id=js', include: [path.resolve(__dirname, 'src')] }, { test: /\\.css$/, use: 'Happypack/loader?id=css', include: [ path.resolve(__dirname, 'src'), path.resolve(__dirname, 'node_modules', 'bootstrap', 'dist') ] } ] }, plugins: [ new Happypack({ id: 'js', //和rule中的id=js对应 //将之前 rule 中的 loader 在此配置 use: ['babel-loader'] //必须是数组 }), new Happypack({ id: 'css',//和rule中的id=css对应 use: ['style-loader', 'css-loader','postcss-loader'], }) ] } thread-loader 多核打包 把thread-loader放置在其他loader之前，会开启一个单独的线程运行速度跟happypack差不多，不过优点是配置更简单 { module: { //我的项目中,babel-loader耗时比较长，所以我给它配置 thread-loader rules: [ { test: /\\.jsx?$/, use: ['thread-loader', 'cache-loader', 'babel-loader'] } ] } } terser-webpack-plugin 多核压缩 webpack默认开启了多进程和缓存 const TerserPlugin = require('terser-webpack-plugin'); module.exports = { optimization: { minimize: true, minimizer: [new TerserPlugin()], }, }; HardSourceWebpackPlugin 中间缓存 中间缓存提高非首次构建速度 var HardSourceWebpackPlugin = require('hard-source-webpack-plugin'); module.exports = { plugins: [ new HardSourceWebpackPlugin() ] } IgnorePlugin避免本地化文件和核心文件一起打包 有些项目比如moment，会把本地化文件和核心文件一起打包 module.exports = { plugins: [ new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) ] } // 使用到本地化的 地方 import moment from 'moment'; import 'moment/locale/zh-cn'; DllPlugin 抽离公共代码 见上一篇【公共模块代码如何提取？】 splitChunks 见下一篇【webpack v3到v4主要区别】 webpack自身优化 tree shaking tree shaking只是为了优化代码，不能使代码报错使用了es6的import，生产环境会自动移除没有使用到的代码 DCE：Dead Code elimination（无用代码删除） DCE消除：靠的是uglify压缩 为什么tree shaking删不掉代码 只处理函数和顶层的import/export变量，不能把没用到的类的方法消除掉 js动态语言的特性使得静态分析变的困难 Side Effect广泛存在 比如下面的👇，静态代码是无法分析的： function Menu() { } Menu.prototype.show = function() { } var a = 'Arr' + 'ay' var b if(a == 'Array') { b = Array } else { b = Menu } b.prototype.unique = function() { // 将 array 中的重复元素去除 } export default Menu; babel编译class时是通过_createClass方法，类属性时通过Object.defineProperty赋值的 为什么这样实现？=> 类内部声明的方法，是不可枚举的，而通过原型链声明的方法是可以枚举的，babel为了符合es6真正的语义 babel宽松模式 { \"presets\": [[\"env\", { \"loose\": false }]] } babel的宽松模式，类属性方法将会编译成直接在原型链上声明方法。 tree shaking上能够尽力的事 尽量不写带有副作用的代码，比如编写了自执行函数，又在函数里使用了外部变量 可以开启babel的loose（宽松）模式 如果是开发JavaScript库，请使用rollup 如果是js库，难以避免副作用代码，可以将功能函数或者组件打包成单独的文件或目录 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-27 22:15:54 "},"knowledge/webpack/3/1.html":{"url":"knowledge/webpack/3/1.html","title":"webpack v3到v4主要区别","keywords":"","body":" 解答 自动设置process.env.NODE_EVN：-mode development UglifyJsPlugin。直接配置{ optimization: { minimize: true } } CommonsChunkPlugin废弃，SplitChunksPlugin取而代之 splitChunks chunks：表示哪些代码需要优化 initial（初始块） async（按需加载块） all（全部） minSize：压缩前的最小模块大小，默认30KB minChunks：引用次数。默认为1 maxAsyncRequests：按需加载时候最大的并行加载请求数，默认为5 maxInitialRequests: 一个入口最大的并行请求数，默认为3 name：拆分出来块的名字 cacheGroups：缓存组 test：正则匹配哪些模块 priority：缓存组打包的先后优先级 reuseExstingChunk：当前代码块已有，就不再产生一个新的代码块 使用splitChunks实现CommonsChunkPlugin的功能 只打包react： optimization: { splitChunks: { chunks: 'all', cacheGroups: { vendors: { test: /react/, name: 'vendors' } } } } 打包vendor入口包括的依赖： { entry: { vendor: ['react', 'react-dom'], } optimization: { splitChunks: { chunks: 'all', cacheGroups: { vendors: { name: 'vendors', chunk: 'initial' } } } } } splitChunks缺点 第一次打包vue，vuex，后面增加了lodash，浏览器中的vendor会失效 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-27 22:03:39 "},"knowledge/webpack/4/1.html":{"url":"knowledge/webpack/4/1.html","title":"对 tree-shaking 的了解","keywords":"","body":" 解答 1.webpack生产模式下默认开启tree-shaking 2.由于babel把class等封装成IIFE，存在副作用导致tree-shaking失效 3.手动设置无副作用： 3.1module下的rule.sideEffects: false 3.2package.json下的sideEffects: false 4.依赖于es6 import的静态分析，函数可以被shaking 5.tree shaking的过程发生在压缩阶段 webpack由于uglify的缘故，导致babel宽松模式下的class也无法被shaking uglify可以设置pure_getters来避免获取对象属性的副作用 副作用： 一个函数会，或者可能会对函数外部变量产生影响的行为 获取对象的属性也会产生副作用 babel编译一个class class Person { constructor(name){ this.name = name; } getName () { return this.name } } 编译之后👇： var _createClass = function (constructor, protoProps) { for (let descriptor of protoProps) { descriptor.enumerable = descriptor.enumerable || !1 descriptor.configurable = !0 Object.defineProperty(constructor.prototype, descriptor.key, descriptor) } } var Person = function () { function Person (name) { this.name = name; } _createClass(Person, [{ key: 'getName', value: function getName() { return this.name; } }]); return Person; }() babel为什么这样做，要用defineProperty来赋属性，而不是定义一个function Person, Person.prototype = { getName }：因为ES6的【类内部声明的方法，是不可枚举的，而通过原型链声明的方法是可以枚举的】 babel有一种宽松模式： { \"presets\": [[\"env\", { \"loose\": false }]] } 宽松模式下class会被编译为原型链的方式，这时用rollup打包class可以被shaking掉 tree-shaking的最佳实践 将每一个组件或者功能函数，都打包成单独的文件或目录，比如Button单独打包，单独导出：babel-import-plugin 尽量不要写带有副作用的代码，比如编写了IIFE，函数里又使用了外部变量 对ES6语义不是特别严格的，可以开启babel的loose模式，rollup shaking能力提高很多 uglify有pure_getter: true的配置，不过不建议使用 React的hooks有利于tree shaking，因为tree shaking对函数的效果更好 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-29 20:00:58 "},"knowledge/webpack/5/1.html":{"url":"knowledge/webpack/5/1.html","title":"HMR原理","keywords":"","body":" webpack热更新自定义实现 服务端要做三件事： compiler 相关四件事 compiler 增加 done 钩子函数，编译完成记录 hash 值，并 socket 广播 更新 compiler.options.entry 注入 webpack-dev-server/client.js 和 webpack/hot/dev-server.js 调用 compiler.hooks.entryOption.call(config.context, config.entry) 更新 entry compiler 以 watch 模式启动 compiler 文件系统使用 memory-fs 启动服务器配置路由 express 方式启动服务器 配置路由中间件 文件系统使用 memory-fs 启动 socket 服务 以 server 为基础启动socket.io 监听连接，保存 socket，广播 hash 和 ok 客户端要做的三件事： 注入的 webpack-dev-server/client/index.js 建立 socket 连接，监听 hot，hash，ok 事件 hash 事件保存 hash 值 hot 事件改变 hot 变量 ok 事件中发布 webpackHotUpdate 事件 注入的 webpack/hot/dev-server.js 订阅 webpackHotUpdate 事件，回调中执行 module.hot.check，传入 hash 值 webpack 打包代码 在 module 对象上增加三个属性 hot: { accept, check } parents children hotCreateRequire 封装 webpack_require，维护 parents 和 children 属性 hotCheck 发起 xhr 请求 ${hash}.hot-update.json，返回{ hash, c: { main: true } } 创建 script 发起文件补丁 jsonp 请求 ${chunkName}.${hash}.hot-update.js jsonp 加载进入 webpackHotUpdate，返回数据(chunkId, { chunkName: function () { 新代码 } }) 更新 modules 中的老代码 从缓存中获取各个 chunk 的老 module 删除缓存上的老 module 从老 module 的父 module 上找到 accept 回调并执行 具体代码实现：我的示例tips： 补丁文件是通过 webpack.HotModuleReplacementPlugin 插件生成的 webpack热更新的使用 主文件: // index.js const input = document.createElement('input') document.body.append(input) const div = document.createElement('div') document.body.append(div) function render () { const data = require('./mock.js') div.innerHTML = data } render() if (module.hot) { module.hot.accept(['./mock.js'], render) } // mock.js module.exports = 'hello world' webpack配置文件： devServer: { hot: true } 依靠module.hot以及devServer.hot就可以实现webpack热更新了 webpack热更新服务端的实现 服务端也即webpack-dev-server，服务端做了哪些事呢？ setupApp，创建express实例 updateCompiler，会往前端js中注入另外两个js setupHooks，监听hooks编译完成事件，编译完成需要干什么呢？ 存储hash值 广播所有socket hash值，以及ok setupDevMiddleware watch方式启动compiler 返回路由中间件 routes，app.use传入路由中间件，进行路由 createServer，通过express实例app创建server createSocketServer，通过server实例创建socket.io服务 下面来实现下： webpack-dev-server启动文件 const Server = require('./server') const webpack = require('webpack') const config = require('webpack.config.js') const compiler = webpack(config) const server = new Server(compiler) server.listen(9090, () => { console.log('服务器在端口9090启动了') }) setupApp 创建express实例 const express = require('express') setupApp () { this.app = express() } updateCompiler 往客户端注入js const path = require('path') function updateCompiler (compiler) { const config = compiler.options config.entry = { main: [ path.resolve(__dirname, './client/index.js'), path.resolve(__dirname, './hot/dev-server.js'), config.entry ] } } setupHooks 挂载compiler.hooks.done钩子函数，打包完成执行： 存储hash值 向各个socket广播两个事件：hash，oksetupHooks () { const { compiler } = this compiler.hooks.done.tap(stats => { this.currentHash = stats.hash this.clientSocketList.forEach(socket => { socket.emit('hash', stats.hash) socket.emit('ok') }) }) } setupDevMiddleware 两个作用： 以watch方式启动compiler 路由 把webpack的文件输入系统改为memory-fs，相同路由读取也从memory-fs读取 this.middleware = this.setupDevMiddleware() const mime = require('mime') const path = require('path') const MemoryFs = require('memory-fs') setupDevMiddleware () { const { compiler } = this const staticDir = compiler.options.output.path compiler.watch({}, () => { console.log('compiler监听模式启动') }) const fs = new MemoryFs() this.fs = compiler.outputFileSystem = fs return (req, res, next) => { let { url } = req if (url === '/favicon.ico') { res.senStatus(404) } url === '/' ? url = '/index.html' : null const filePath = path.resolve(staticDir, url) try { let statObj = this.fs.statSync(filePath) if (statObj.isFile()) { const content = this.fs.readFileSync(filePath) res.setHeader('Content-Type', mime.getType(filePath)) res.send(content) } else { res.senStatus(404) } } catch (e) { res.sendStatus(404) } } } routes 设置路由 routes () { const { app, middleware } = this app.use(middleware) } createServer createServer () { const { app } = this this.server = http.createServer(app) } createSocketServer createSocketServer () { const { server } = this const io = socketIO(server) io.on('connection', socket => { socket.emit('hash', this.currentHash) socket.emit('ok') this.clientSocketList.push(socket) io.on('disconnect', () => { const index = this.clientSocket.indexOf(socket) this.clientSocketList.spilce(index, 1) }) }) } Server构造函数 constructor () { this.setupApp(); updateCompiler(); this.clientSocketList = []; this.setupHooks(); this.setupDevMiddleware(); this.routes(); this.createServer(); this.createSocketServer(); } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-23 17:38:11 "},"knowledge/webpack/6/1.html":{"url":"knowledge/webpack/6/1.html","title":"配置文件完全解析","keywords":"","body":"配置文件完全解析 webpack启动文件配置 // 默认 webpack.config.js 文件，使用--config指定其他文件 webpack --config example.config.js 以 json 格式输出 webpack 运行结果 webpack --json > stats.json context 入口文件所处目录绝对路径的字符串 context: path.resolve(__dirname, 'app') entry 三种方式：字符串，数组，对象 // 字符串 entry: 'index.js' // 数组 entry: ['index.js', 'main.js'] // 对象 entry: { pageOne: 'pageOne/index.js', pageTwo: 'pageTwo/index.js' } // 动态入口 // 函数 entry: () => './index.js' // promise entry: () => new Promise((resolve) => resolve(['./index.js', './main.js'])) webpack 5 中的改动: Entry descriptor // Entry descriptor { entry: { main: { import: 'index.js', filename: 'pages/[name].js', chunkLoading: 'jsonp | import-scripts ｜ require ｜ async-mode' } } } chunkLoading jsonp 打包出来的代码：匿名自执行函数 (() => { eval(\"console.log('index');\\n\\n//# sourceURL=webpack://webpack/./index.js?\"); })(); require | async-node output filename：[id].[name].[hash].[chunkhash].js path：绝对路径或相对路径 publicPath：'http://cdn.example.com/[hash]/' chunkFilename chunkLoadTimeout: import 的 chunk 过期时间 crossOriginLoading: false | 'anonymous' | 'use-credentials' jsonpScriptType: 'text/javascript' | 'module' hotUpdateChunkFilename: '[id].[hash].hot-update.js' library: 'webpackNumbers' 手动 script 引入 js，可以使用 webpackNumbers 访问里面的方法 output.auxiliaryComment auxiliaryComment 配合 libraryTarget 一起使用 auxiliaryComment 为字符串时，是所有模式模块都会导出 auxiliaryComment 为 json，细分各个模式模块配置注释 字符串： output: { libraryTarget: 'umd', auxiliaryComment: 'Test Comment' } json格式： output: { libraryTarget: 'umd', auxiliaryComment: { root: 'Root Comment', commonjs: 'Commonjs Comment', commonjs2: 'Commonjs2 Comment', amd: 'AMD Comment' } } mode 有两个值：production，development 会将 definePlugin 中 process.env.NODE_ENV 值设为 production 或 development 启用不同的 plugin 模块 chunk loader 向 webpack 描述了如何处理非原生模块 使用 enhanced-resolve 解析文件路径 target Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-13 17:58:52 "},"interview/webpack/":{"url":"interview/webpack/","title":"webpack","keywords":"","body":"webpack 每日一题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-10 10:49:13 "},"interview/webpack/1/1.html":{"url":"interview/webpack/1/1.html","title":"webpack做过哪些优化？开发效率，打包策略等","keywords":"","body":" 解答 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-10 16:58:14 "},"interview/webpack/2/1.html":{"url":"interview/webpack/2/1.html","title":"HtmlWebpackPlugin 的配置","keywords":"","body":" 解答 filename new HtmlWebpackPlugin({ filename: 'order/index.html' }) title new HtmlWebpackPlugin({ title: 'Hello Webpack' }) template new HtmlWebpackPlugin({ template: 'template.html' }) templateContent inline html templateParameters new HtmlwebpackPlugin({ templateParameters: { __base_style__: ' .app { red } ' } }) inject inject: true | false | head | body true 跟 body 效果一样：在body末尾注入 false：不注入 js head：在 head 中注入 js publicPath 跟 output publicPath，在输出 js 路径加入 publicPath scriptLoading blocking： 正常注入 js defer：注入 js 添加 defer 属性 scriptLoading: blocking | defer favicon 注入 favicon，⚠️ ：需要是本地的，会带上 publicPath 前缀 minify 压缩，true | false hash js css icon 都会带上 ?hash，可有效清楚缓存 chunks 注入哪些 js chunks: ['main'] chunksSortMode // 插入 html 的很多 chunks，如何排序 chunks: ['index', 'main'], chunksSortMode: 'auto | manual' excludeChunks 不包含的 chunks Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-09 15:03:00 "},"interview/webpack/3/1.html":{"url":"interview/webpack/3/1.html","title":"有哪些有用的 webpack 插件","keywords":"","body":" Loader loader 的使用方式 如果不在 webpack.config.js 中配置 loader，那么怎么使用呢？ require('style-loader!css-loader!./index.css') file-loader 处理文件 把原图片拷贝到 dist，文件名也会变 可以处理任意二进制数据 require('file-loader?outputPath=./images!./1.jepg') { test: /.png/, use: { loader: 'file-loader', options: { outputPath: '/images' } } } 全局注入方案二：expose-loader 这样使用，需要手动 import jquery from 'jquery'；当 require 解析到这个 import 时，就会走 expose-loader但是好处是：只会在一个文件中打包 { test: require.resolve('jquery'), use: { loader: 'expose-loader', options: { exposes: { globalName: '$', override: true } } } } babel-loader babel非常慢，优化主要通过以下两点： exclude 或者 include 精确解析 cacheDirectory: true 开启缓存 { test: /.js$/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } } cache-loader { test: /\\.js$/, use: [ 'cache-loader', 'babel-loader' ], include: path.resolve('src') } css-loader css-loader 解释 @import 和 url() Plugins CleanWebpackPlugin 开发时 dist 目录不断产出，文件很多很乱 const CleanWebpackPlugin = require('clean-webpack-plugin') new CleanWebpackPlugin(['dist']) 不带参数的话，会把 output path 作为目标目录 全局注入方案一：ProvidePlugin 缺点：比如 $: jquery，使用到 $ 的模块都会打包jquery，造成重复打包 配置 noParse 也没用 const webpack = require('webpack') new webpack.ProvidePlugin({ $: 'jquery' }) extract-text-webpack-plugin const ExtractTextWebpackPlugin = require('extract-text-webpack-plugin') { test: /\\.css$/, use: ExtractTextWebpackPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } plugins: [ new ExtractTextPlugin('style.css'), ] 多个 css 模块 如何处理？ const lessExtractPlugin = new ExtractTextWebpackPlugin('css/less.css') const cssExtractPlugin = new ExtractTextWebpackPlugin('css/css.css') const sassExtractPlugin = new ExtractTextWebpackPlugin('css/sass.css') // 加载器以此类推 { test: /\\.css$/, use: cssExtractPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } plugins: [ lessExtractPlugin, cssExtractPlugin, sassExtractPlugin, ] CopyWebpackPlugin const CopyWebpackPlugin = require('copy-webpack-plugin') new CopyWebpackPlugin({ from: path.join(__dirname, 'public'), to: path.join(__dirname, 'dist') }) AggressiveSplittingPlugin new webpack.optimize.AggressiveSplittingPlugin({ minSize: 30000, maxSize: 50000, chunkOverhead: 0, }) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-09 19:41:18 "},"interview/webpack/4/1.html":{"url":"interview/webpack/4/1.html","title":"webpack动态导入 import 是如何实现的","keywords":"","body":" 解答 动态导入 import 使用 // index.js document.getElementById('app').addEventListener('click', () => { import('./console.js').then(_console => { _console.log('clicked') }) }) //console.js function log (msg) { console.log(`system log: ${msg}`) } export { log } webpack 打包之后的样子 // main.js { './index.js': function (module, __webpack_exports__, __webpack_require__) { document.getElementById('app').addEventListener('click', () => { __webpack_require__.e(0).then( __webpack_require__.bind(null, './console.js') ).then(_console_ => { _console_.log('clicked') }) }) } } // 0.js window.webpackJsonp = window.webpackJsonp || [] window.webpackJsonp.push([ [0], { './console.js': function (module, __webpack_exports__, __webpack_require__) { Object.defineProperty(__webpack_exports__, 'log', { enumerable: true, get: function () { return log } }) function log (msg) { console.log(msg) } } } ]) webpack_require 的实现 (function (modules) { var installedModules = {}; function __webpack_require__ (moduleId) { if (installedModules[moduleId]) { return installedModules[moduleId] } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} } modules[moduleId].call(module, module, module.exports, __webpack_require__) module.l = true return module.exports } })({ './index.js': function (){} }) webpack_require.e的实现 var installedChunks = {} __webpack_require__.e = function requireEnsuer (chunkId) { var promises = [] var installedChunkData = installedChunks[chunkId] if (installedChunkData !== 0) { if (installedChunkData) { promises.push(installedChunkData[2]) } else { var promise = new Promise((resolve, reject) => { installedChunkData = installedChunks[chunkId] = [resolve, reject] }) promises.push((installedChunkdata[2] = promise)) var script = document.createElement('script') script.src = `${chunkId}.js` document.head.appendChild(script) } } return Promise.all(promises) } window.webpackJsonp 是什么？ window.webpackJsonp 是个数组，但是传统 jsonp 应该是调用回调函数，可是打包之后代码为什么是：window.webpackJsonp.push，如何触发回调呢？ var jsonpArray = window.webpackJsonp = window.webpackJsonp || [] var parentJsonpFunction = jsonpArray.push.bind(jsonArray) jsonpArray.push = webpackJsonpCallback for (let jsonp of jsonpArray) { webpackJsonpCallback(jsonp) } 可以看出 window.webpackJsonp.push，如果在main.js已加载的情况下，其实已经是 webpackJsonpCallback 函数了 webpackJsonpCallback 的实现 function webpackJsonpCallback (data) { const chunkIds = data[0] const moreModules = data[1] vat resolves = [] for (let chunkId of chunkIds) { resolves.push(installedChunks[chunkId][0]) installedChunks[chunkId] = 0 } for (let moduleName in moreModules) { modules[moduleName] = moreModules[moduleName] } if (parentJsonpFunction) parentJsonpFunction(data) while (resolves.length) { resolves.shift()() } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-12 16:06:53 "},"interview/webpack/5/1.html":{"url":"interview/webpack/5/1.html","title":"开发一个loader，把代码中的箭头函数编译为普通函数","keywords":"","body":" 解答 const transformer = require(\"@babel/core\"); const t = require('@babel/types') module.exports = function(content, map, meta) { const ArrowFunctionToFunctionPlugin = { visitor: { ArrowFunctionExpression(path) { const ruturnStatement = t.returnStatement(path.node.body) const blockStatement = t.blockStatement([ruturnStatement]) const funcExpr = t.functionExpression(null, path.node.params, blockStatement) path.replaceWith(funcExpr) } } } const result = transformer.transform(content, { plugins: [ArrowFunctionToFunctionPlugin] }) return result.code } loader的配置 resolveLoader: { modules: [path.resolve(__dirname, 'loaders')], extensions: ['.js'], mainFields: ['loader'] } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-13 15:58:45 "},"interview/webpack/6/1.html":{"url":"interview/webpack/6/1.html","title":"tapable 的使用和原理","keywords":"","body":" 解答 SyncHook const { SyncHook } = require('tapable') const queue = new SyncHook(['n', 'a', 's']) queue.tap('1', function (name, age, sex) { console.log(name, age, sex) }) queue.tap('2', function (name, age) { console.log(name, age) }) queue.tap('3', function (name, age) { console.log(name, age) }) queue.call('1', 'xiur', 29, 'man') 自定义实现: class SyncHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (...args) { for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { plugin.apply(this, args) } } } } module.exports = SyncHook SyncBailHook const { SyncBailHook } = require('tapable') const queue = new SyncBailHook(['n', 'a', 's']) queue.tap('1', function (name, age, sex) { console.log(name, age, sex) return 'Wrong' }) queue.tap('2', function (name, age) { console.log(name, age) }) queue.tap('3', function (name, age) { console.log(name, age) }) queue.call('1', 'xiur', 29, 'man') 自定义实现： class SyncBailHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (...args) { for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { let result = plugin.apply(this, args) if (result) { return result } } } } } module.exports = SyncBailHook SyncWaterfallHook const { SyncWaterfallHook } = require('tapable') const queue = new SyncWaterfallHook(['n', 'a', 's']) queue.tap('1', function (name, age, sex) { console.log(name, age, sex) return name + '1' }) queue.tap('2', function (name, age) { console.log(name, age) return name + '2' }) queue.tap('3', function (name, age) { console.log(name, age) return name + '3' }) queue.call('xiur', 29, 'man') 自定义实现： class SyncWaterfallHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (init, ...args) { let current = init for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { current = plugin.apply(this, [current, ...args]) } } } } module.exports = SyncWaterfallHook SyncLoopHook const { SyncLoopHook } = require('tapable') const queue = new SyncLoopHook(['n', 'a', 's']) let count = 3; queue.tap('1', function (name, age, sex) { console.log(count) if (count > 0) { count--; return count } else { return } }) queue.call('xiur', 29, 'man') 自定义实现： class SyncLoopHook { constructor () { this._plugins = {} } tap (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(callback) } call (...args) { for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { let result do { result = plugin.apply(this, args) } while (result !== undefined) } } } } module.exports = SyncLoopHook AsyncParalleHook 异步并行加载 // const { AsyncParallelHook } = require('tapable') const AsyncParallelHook = require('./AsyncParallelHook') const hook = new AsyncParallelHook(['name']); console.time('cost'); hook.tapAsync('a', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb(); }, 2000) }) hook.tapPromise('a', name => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve(); }, 4000) }) }) hook.callAsync('a', () => { console.log('done'); console.timeEnd('cost'); }); 自定义实现： class AsyncParallelHook { constructor () { this._plugins = {}; } tapAsync (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback.call(this, ...args, () => { ++this.i; if (this.i >= this._plugins[name].length) { return cb() } }); }) } tapPromise (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { callback.apply(this, args).then(() => { const cb = args.pop(); ++this.i; if (this.i >= this._plugins[name].length) { return cb() } }) }) } callAsync (...args) { this.i = 0; for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName] for (let plugin of plugins) { plugin.apply(this, args) } } } } module.exports = AsyncParallelHook AsyncSeriesHook 异步串行加载 const { AsyncSeriesHook } = require('tapable'); const hook = new AsyncSeriesHook(['name']); console.time('cost'); hook.tapAsync('a', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb(); }, 2000); }); hook.tapPromise('a', (name) => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve(); }, 4000); }); }); hook.callAsync('a', () => { console.log('done'); console.timeEnd('cost'); }); 自定义实现： class AsyncSeriesHook { constructor () { this._plugins = {} this.next = this._next.bind(this) } tapAsync (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args, () => this.next(name, cb, [...args, cb])); }) } tapPromise (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args).then(() => this.next(name, cb, [...args, cb])) }) } _next (name, cb, args) { ++this.i; if (this.i >= this._plugins[name].length) { return cb(); } this._plugins[name][this.i].apply(this, args) } callAsync (...args) { this.i = 0 for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName]; if (plugins) { plugins[0].apply(this, args) } } } } module.exports = AsyncSeriesHook AsyncSeriesBailHook 异步串行熔断加载 const { AsyncSeriesHook } = require('tapable'); const hook = new AsyncSeriesHook(['name']); console.time('cost'); hook.tapAsync('a', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb('yes'); }, 2000); }); hook.tapPromise('a', (name) => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve('yes'); }, 4000); }); }); hook.callAsync('a', () => { console.log('done'); console.timeEnd('cost'); }); class AsyncSeriesBailHook { constructor () { this._plugins = {} this.next = this._next.bind(this) } tapAsync (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args, ret => this.next(name, cb, [...args, cb], ret)); }) } tapPromise (name, callback) { (this._plugins[name] || (this._plugins[name] = [])).push(function (...args) { const cb = args.pop(); callback(...args).then(ret => this.next(name, cb, [...args, cb], ret)) }) } _next (name, cb, args, ret) { ++this.i; if (this.i >= this._plugins[name].length || ret !== undefined) { return cb(); } this._plugins[name][this.i].apply(this, args) } callAsync (...args) { this.i = 0 for (let pluginName in this._plugins) { let plugins = this._plugins[pluginName]; if (plugins) { plugins[0].apply(this, args) } } } } module.exports = AsyncSeriesBailHook Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-16 16:46:27 "}}