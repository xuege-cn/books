{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 16:08:07 "},"knowledge/":{"url":"knowledge/","title":"知识星球","keywords":"","body":"知识星球 🌍 这里记录了各种知识分类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-09-27 10:37:32 "},"interview/react/":{"url":"interview/react/","title":"react","keywords":"","body":"React 每日一题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-09 19:16:37 "},"interview/react/1/1.html":{"url":"interview/react/1/1.html","title":"React Context的理解","keywords":"","body":" 解答 React Context 主要是解决跨层级组件数据传递，可以当作是特定一个组件树内共享的store 过时的Context class Grand extends PureComponent { static childContextTypes = { text: PropTypes.string } getChildContext () { return { text: 'halo! old context' } } } class Child extends React.Component { static contextTypes = { text: PropTypes.string } render () { return {this.context.text} } } 新Context const TextContext = React.createContext(); class Grand extends React.Component { render () { return } } class Child extends React.Component { static contextType = TextContext render () { return {this.context.text} } } 函数组件如何使用 Context function Child () { return { value => {value} } } 实现自定义上下文 function createContext () { function Provider (props) { Provider.value = props.value; return props.children } function Consumer (props) { return props.children(Provider.value); } return { Provider, Consumer } } class Child extends React.Component { static contextType = TextContent; constructor () { this.context = Child.contextType.Provider.value } } 优缺点 优点：不同层级的组件需要访问同样一些数据 缺点：组件的复用性变差 组件复用是一种更好的方式 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-30 11:21:58 "},"interview/react/2/1.html":{"url":"interview/react/2/1.html","title":"React fiber是什么？怎么用","keywords":"","body":" 为什么需要 React fiber react v16 之前是通过 树形结构 保存 virtual dom，这种结构有两个问题： 更新任务是不可中止的：比如当前更新到了某个节点，如果任务停止了，那么需要重新进行更新 任务执行时长过长导致丢帧：由于更新任务是不可中止的，时间就很难掌控，当一个 dom tree 节点很多时，执行时间就会很长，比如一帧的时间更长。就可能导致丢帧 fiber 是什么 可以理解为 fiber 是一种数据结构，virtual dom 从 树形结构 变成 fiber tree 链表结构 如何实现 fiber 链接结构 树形结构是通过 children 来关联各个节点，通过深度优先遍历的方式进行 diff链表结构是通过 child，sibling return 来关联各个节点，通过深度优先遍历的方式以及 firstEffect，nextEffect，effectTag 的配合进行 diff 更新 React 原生 fiber 获取渲染的 fiber root document.getElementById('app')._reactRootContainer._internalRoot; fiber root 结构 FiberRootNode { - containerInfo: div#app - current: FiberNode - child: - child: - return: FiberRootNode - sibling: null - firstEffect: null - lastEffect: null - nextEffect: null - stateNode: ul.list - return: null - sibling: null - firstEffect: ul - lastEffect: ul - nextEffect: null - stateNode: div#app - hydrat: false } 如何实现一个简版 React fiber React fiber是一个链表结构，所以遍历链表 workLoop function workLoop () { while (nextUnitOfWork) { nextUnitOfWork = performUnitOfWork(nextUnitOfWork) } // 提交放到最后一起提交，避免部分节点渲染了，部分节点未渲染 commitRoot() } performUnitOfWork 两个作用： 开始当前 workInProgress 的工作 返回链表下一个节点: 有儿子返回儿子，没儿子返回叔叔，没叔叔往上走 当一个节点没儿子时，执行 compeleteUnitOfWork function performUnitOfWork (workInProgress) { beginWork(workInProgress) if (workInProgress.child) { return workInProgress.child } while (workInProgress) { completeUnitOfWork(workInProgress) if (workInProgress.sibling) { return workInProgress.sibling } workInProgress = workInProgress.return } } beginWork 两个作用： 创建 stateNode 维护 child，return，sibling，effectTag function beginWork (workInProgress) { if (!workInProgress.stateNode) { workInProgress.stateNode = document.createElement(workInProgress.type) } let prevFiber workInProgress.props.children.forEach((child, index) => { if (typeof child === 'string') { const childEl = document.createElement(child) workInProgress.stateNode.appendChild(childEl) } else { child = { ...child, return: workInProgress, child: null, sibling: null, effectTag: 'PLACEMENT', firstEffect: null, lastEffect: null, nextEffect: null } if (index === 0) { workInProgress.child = child } else { prevFiber.sibling = child } prevFiber = child } }) } completeUnitOfWork 维护firstEffect，lastEffect, nextEffect function completeUnitOfWork (workInProgress) { const returnFiber = workInProgress.return if (!returnFiber.firstEffect) { returnFiber.firstEffect = workInProgress.firstEffect } if (workInProgress.lastEffect) { if (returnFiber.lastEffect) { returnEffect.lastEffect.nextEffect = workInProgress.lastEffect } returnEffect.lastEffect = workInProgress.lastEffect } if (workInProgress.effectTag) { if (returnFiber.lastEffect) { returnFiber.lastEffect.nextEffect = workInprogress } else { returnFiber.firstEffect = workInProgress } returnFiber.lastEffect = workInProgress } } commitRoot 更新UI function commitRoot () { const nextEffect = workInProgressRoot.firstEffect while (nextEffect) { nextEffect.return.stateNode.appendChild(nextEffect.stateNode) nextEffect = nectEffect.return } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-10-29 14:39:49 "},"interview/react/3/1.html":{"url":"interview/react/3/1.html","title":"antd4 rc-field-form如何实现的","keywords":"","body":" 学习 rc-field-form 的几个知识点 实现Form组件的数据上下文高阶组件 实现Form组件中的数据托管 实现Form组件中的双向数据绑定 实现Form组件中的强制更新 实现Form组件中的异步表单校验 rc-field-form 的使用 import Form, { Field } from 'rc-field-form' const validateUniqueName = (name, value) => { return new Promise(resolve => { setTimeout(() => { resolve(value === 'xiur' ? `${name} is not unique` : '') }, 3000) }) } { console.log('成功：', values) }} onFinishFailed={(error) => { console.log('失败：', error) }} > 实现逻辑 Form 组件 实例化 formInstance 初始化 store 设置 callbacks 使用 context Field 组件 获取 context 克隆 children 重写 props 注册 Field 声明 onStateChange，store 改变 forceUpdate useForm useForm 返回 formInstance FormStore 数据托管 async-validate 数据校验 Form 实现 如何实现初始值只设置一次？场景：比如外部的父组件更新，会造成 Form 组件的更新，此时会重新设置 initialValue，可是此时已经不是初始化了使用 React.useRef 单例解决这个问题 const FieldContext = React.createContext() const Form = ({ initialValues, onFinish, onFinishFailed, children }) => { const [ formInstance ] = useForm() const mountRef = React.useRef(null) if(!mountRef.current) { formInstance.setInitialValues(initialValues) formInstance.setCallbacks({ onFinish, onFinishFailed }) mountRef.current = true } return {children} } useForm 实现 class FormStore { constructor (forceRootUpdate) { this.forceRootUpdate = forceRootUpdate this.store = {} this.callbacks = {} this.fieldEntities = [] } setCallbacks = callbacks => { this.callbacks = {...callbacks} } setInitialValues = store => { this.store = {...store} } setFieldValue = (name, value) => { this.store[name] = value this.notify() } getFieldValue = name => { return this.store[name] } registerField = (fieldEntity) => { this.fieldEntities.push(fieldEntity) } notify = () => { for (let fieldEntity of this.fieldEntities) { fieldEntity.onStateChange() } } submit = () => { const descriptor = {} this.fieldEntities.forEach(fieldEntity => { const { name, rules } = fieldEntity.props if (rules) { const ruleInfo = {} rules.forEach(rule => { const ruleKeys = Object.keys(rule) ruleKeys.forEach(ruleKey => { ruleInfo[ruleKey] = rule[ruleKey] }) }) descriptor[name] = ruleInfo } }) new Schema(descriptor).validate(this.store) .then(values => { this.callbacks.onFinish(values) }) .catch(error => { this.callbacks.onFinishFailed(error) }) } getForm = () => { return { setInitialValues: this.setInitialValues, setCallbacks: this.setCallbacks, setFieldValue: this.setFieldValue, getFieldValue: this.getFieldValue, registerField: this.registerField, submit: this.submit, } } } function useForm () { const formRef = React.useRef(null) const [, forceUpdate] = React.useState() if (!formRef.current) { const formStore = new FormStore(forceUpdate) const formInstance = formStore.getForm() formRef.current = formInstance } return [formRef.current] } async-validate 实现 class Schema { constructor (descriptor) { this.descriptor = descriptor } validate () { return new Promise(async (resolve, reject) => { let errorInfo = [] const fieldNames = Object.keys(this.descriptor) for (let i = 0; i filedRules[fieldRuleName]) { errors.push(`${fieldName} 最大为${filedRules[fieldRuleName]}位字符`) } break case 'validate': const validateFn = filedRules[fieldRuleName] const result = await validateFn(fieldName, values[fieldName]) if (result.length > 0) { errors.push(result) } } } errors.length > 0 ? errorInfo.push({ name: fieldName, errors }) : void(0) } errorInfo.length > 0 ? reject({ errorInfo, values }) : resolve(values) }) } } Field 实现 这里主要实现 双向数据绑定 和 强制刷新 input 的 value 的获取 从 this.context 通过 getFiledValue 获取 当 onChange 触发通过 setFieldValue 改变 store 时，需要更新UI，就通过 store 的 notify 调用各个 Field 的 onStateChange 实现 class Field extends React.Component { static contextType = FieldContext componentDidMount () { const formInstance = this.context formInstance.registerField(this) } onStateChange = () => { this.forceUpdate } getControlled = () => { const formInstance = this.context const { name, children } = this.props return React.cloneElement(children, { ...children.props, value: formInstance.getFieldValue(name), onChange: (e) => { formInstance.setFieldValue(name, e.target.value) } }) } render () { return this.getControlled() } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-04 15:16:15 "},"interview/react/4/1.html":{"url":"interview/react/4/1.html","title":"从createElement，render，Functional Component, Class Component角度开发一个React","keywords":"","body":" 解答 jsx是什么？ javascript + xml，用来描述页面上元素和结构，那么 jsx 会被转换成什么？ babel ast 编译：https://babeljs.io/repl 普通元素的编译 时钟： {new Date().toLocalString()} React.createElement( \"div\", null, React.createElement(\"span\", null, \"\\u65F6\\u949F\\uFF1A\"), React.createElement(\"span\", null, new Date().toLocalString()) ) 组件的编译 React.createElement(Clock, { name: '时钟' }) 总结 可以看到 jsx 会被编译为 React.createElement，这也是为什么用到 jsx 的文件都要手动 import react jsx 是 javascript + xml 用来描述页面结构的一种语法 jsx 会被 babel-loader 编译成 React.createElement 方法执行生成 virtual dom 简单实现一个react，满足创建虚拟 dom 和渲染的目标 jsx 文件编译之后如下： const ClockJsx = React.createElement('div', { className: 'jsx' }, '时钟1：', new Date().toLocalString()); const Clock1 = ({ name }) => return React.createElement('div', { className: 'functional' }, name, new Date().toLocalString()); class Clock2 extends React.Component { render () { return React.createElement('div', { className: 'class' }, name, new Date().toLocalString()); } } ReactDOM.render(React.createElement( 'div', null, ClockJsx, Clock1, Clock2, ), document.getElementById('root')) createElement 接收三个参数： type: string props: object | null children ?: string | Array 作用：构建 virtual dom // react.js function createElement (type, props, ...children) { const childrenLength = children.length; if (childrenLength === 1) { props.children = children[0]; } else if (childrenLength > 1) { props.children = children } return ReactElement(type, props); } function ReactElement (type, props) { return { type, props } } export default { createElement, } render render 会把 createElement 的结果渲染到页面，拿 class 组件举例 createElement 的结果如下 { type: 'div', props: { className: 'class', children: [ name, new Date().toLocalString() ] } } 第一版 render 实现： function render (VNode, parentNode) { if (typeof VNode === 'string') { return parentNode.appendChild(document.createTextNode(VNode)); } let { type, props } = VNode; const currentEl = document.createElement(type); for (let prop in props) { switch (prop) { case 'className': currentEl.className = props.className; break; case 'style': Object.keys(props.style).forEach(styleName => { currentEl.style[styleName] = props.style[styleName] }); break; case 'value': if (['input', 'textarea'].includes(type)) { currentEl.value = value; } else { currentEl.setAttribute('value', props.value); } break; case 'children': if (Array.isArray(props.children)) { props.children.forEach(child => render(child, currentEl)); } else { render(prosp.children, currentEl); } break; default: currentEl.setAttribute(prop, props.prop); break; } } parentNode.appendChild(currentEl); } 函数组件和类组件的 render 支持 函数组件和类组件与普通 JSX 的区别在于 type，type 一般为节点名称，可是函数组件 type 为函数名，类组件 type 为类名 在获取 type 之后，判断是函数组件 或 类组件，分别获取其JSX，然后走普通JSX的逻辑 let { type, props } = VNode; if (typeof type === 'function') { const functionalJsx = type(props); type = functionalJsx.type; props = functionalJsx.props; } if (type.isReactComponent) { const classJsx = new type(props).render(); type = classJsx.type; props = classJsx.props; } 类组件还需要实现一个基类 React.Component React.Component class Component { static isReactComponent = true; constructor (props) { this.props = props; } } export default { createElement, Component, } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-27 16:03:50 "},"interview/react/5/1.html":{"url":"interview/react/5/1.html","title":"React Ref的使用","keywords":"","body":" 解答 最新版本 ref 使用 this.inputRef = React.createRef() ref 引用值 如何 ref={this.inputRef} 加载普通元素上，那么 ref 是 dom 节点 如果它加在子组件上，ref 是子组件实例 createRef 实现 function createRef () { return { current: null } } 函数组件如何使用 Ref const FunctionalComponent = React.forwardRef((props, ref) => { return {props.label} }) this.btnRef = React.createRef(); forwardRef 自定义实现 function forwardRef (FuncComponent) { return (props) => { const ref = props.ref return FuncComponent(props, ref); } } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-30 11:47:48 "},"interview/react/6/1.html":{"url":"interview/react/6/1.html","title":"有哪些生命周期","keywords":"","body":" 解答 老的生命周期 初始化：constructor 装载：componentWillMount，render，componentDidMount 更新：componentWillReceiveProps，shouldComponentUpdate，componentWillUpdate，render，componentDidUpdate 卸载：componentWillUnmount 新的生命周期 初始化：constructor 装载：getDerivedStateFromProps，render 更新：getDerivedStateFromProps，shouldComponent，render，getSnapshotBeforeUpdate，componentDidUpdate componentWillmount 生命周期改动 废除了三个 will 系生命周期：componentWillMount，componentWillReceiveProps，componentWillUpdate 增加了两个生命周期：getDerivedStateFromProps，getSnapshotBeforeUpdate getDerivedStateFromProps 当初始化和更新时，组件会在 constructor 之后先走 getDerivedStateFromProps，可以在这个生命周期中返回一个json，映射为当前的state class Child extends React.Component { constructor (props) { super(props); this.state = { time: '' } } static getDerivedStateFromProps (nextProps) { return { time: nextProps.time } } } getSnapshotBeforeUpdate 在更新之前返回一个快照 snapshot，可以在 componentDidUpdate 中第三个参数获取 getSnapshotBeforeUpdate () { return {} } componentDidUpdate (prevProps, prevState, snapshot) { } 使用场景：比如往网页头部插入元素，会导致网页往下移，此时可以用 getSnapshotBeforeUpdate 先记录更新前的 scrollTop Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-30 14:48:48 "},"interview/react/7/1.html":{"url":"interview/react/7/1.html","title":"如何开发一个 redux","keywords":"","body":" Redux 的基础应用 基础的四个方法：createStore，getState，subscribe，dispatch function reducer (state, action) { switch (action.type) { case 'ADD': return ++state; case 'MINUS': return --state; default: return state; } } const store = createStore(reducer, initialState); const unsubscribe = store.subscribe(() => { console.log('state发生变化了', store.getState()); }) store.dispatch({ type: 'ADD' }); unsubscribe(); 基础架构实现 需要注意的点： 如何防止 unsubscribe 多次调用 如何判断是否是个纯对象 function createStore (reducer, initialState) { let currentState = initialState; let currentReducer = reducer; let currentListeners = []; function getState () { return currentState; } function subscribe (listener) { if (typeof listener !== 'function') { throw new Error('订阅参数必须为函数') } let idx = currentListeners.push(listener); let isSubscribed = true; function unsubscribe () { if (!isSubscribe) { return } currentListeners.splice(idx - 1, 1); isSubscribe = false } } function dispatch (action) { if (!isPlainObject(action)) { throw new Error('action 必须是个纯对象') } if (!action || action.type) { throw new Error('action 必须要有一个type属性') } currentState = currentReducer(currentState, action); for (let listener of currentListeners) { listener(); } } return { getState, dispatch, subscribe, } } 纯对象 对象的原型是 Object.prototype function isPlainObject (obj) { if (typeof obj !== 'object' || obj === null) { return false; } return Object.getPrototypeOf(obj) === Object.prototype } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-11-30 19:27:21 "}}