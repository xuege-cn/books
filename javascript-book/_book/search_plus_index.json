{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 这本电子书主要是收集了部分js的生僻知识点，做下记录 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-06-30 15:44:38 "},"ts.html":{"url":"ts.html","title":"一文讲解ts","keywords":"","body":"Typescript 类型系统 Number let num: number = 666 String let str: string = 'leo' Boolean let isTure: boolean = true Array let arr: number[] = [1, 2, 3] let arr: Array = [1, 2, 3] Object let obj: Object = {} Any let coco: any = 666 Enum方法一： enum Animal { CAT = 'cat', DOG = 'dog', PIG = 'pig', } // Animal.CAT // Animal['CAT'] 方法二： enum Animal { CAT, DOG, PIG } Unknown let value: unknown; Tuple固定长度，固定类型 let tup: [number, string] = [27, 'jianan'] void function foo (): void {} 断言 类型断言 as let value: any = 'this is a value' let len: number = (value as string).length let len2: number = (value).length 非空断言 function foo(name: string | undefined) { let sname: string = name! } name!表示确定其有值，不会null或undefined 类型判断 typeof类型演算 const a: number = 1 const b: typeof a = 3 instanceof 推断类型 const str: string = 'this is a value' str instanceof String 类型别名和接口 类型别名 type people = { name: string, age: string } const someone: people = { name: 'leo', age: 29 } 接口 interface people = { name: string, age: string } 来自别名和接口的约束 约束类 interface ClockInterface { cTime: Date, setTime(d: Date): string } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 18:03:09 "},"scope/":{"url":"scope/","title":"作用域","keywords":"","body":"作用域 编程语言最基本功能之一：储存变量当中的值，并且能在之后对这个值进行访问和修改 状态：储存和访问变量的值的能力 需要一套规则来维护状态，即储存变量，且能方便地找到这些变量，这套规则称为【作用域】. js引擎不会有大量的时间来进行优化，因为js大部分情况下编译发生在代码执行前的几微秒时间内 查找规则 为何会区分LHS查询和RHS查询呢？ 因为RHS失败会抛出一个referenceError异常，而LHS查询失败，在非严格模式下，会创建一个全局作用域中具有该名称的变量，并将其返还给引擎 LHS查找 指代赋值语句左侧查找，比如👇： var a = 1 这里引擎会为变量a进行LHS查询 RHS查找 指代非左侧查询，比如下面两个例子都是RHS查询 var a = b console.log(b) 这里执行了两次b的RHS查询 小结 LHS和RHS的根本 LHS查询：Left Hand Side 对变量进行赋值RHS查询：Right Hand Side 获取变量的值 LHS和RHS的共同点和不同点 LHS和RHS都是从当前作用域开始查找，直到全局作用域。全局作用域也没有的话，RHS查询会抛出referenceError错误，LHS会隐式在全局作用域中创建一个变量 代码解析过程 var a = 2 上面代码会经历如下几个步骤： var a在其作用域中声明新变量 a = 2进行LHS查询变量a并对其进行赋值 作用域的原理 一套用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找的规则 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-06-28 19:44:31 "},"scope/tokenScope.html":{"url":"scope/tokenScope.html","title":"词法作用域","keywords":"","body":"词法作用域 词法作用域是由你在写代码时将变量和块级作用域写在哪决定的 动态作用域 js中的作用域就是词法作用域，不具备动态作用域 词法作用域： 在写代码或者定义时确定动态作用域： 在运行时确定 欺骗词法作用域 欺骗词法作用域有两种方法： eval eval会把字符串当作代码块执行 eval的副作用 影响原作用域 eval执行的代码类似本插入在此的代码，其中的声明和操作会影响当前作用域，比如👇： function foo (code) { eval(code) console.log(b) } var b = 2; foo('var b = 3;') 这段代码会输出3，说明eval在foo的词法作用域中声明了变量b为3 如何解决？1.严格模式 function foo (code) { \"use strict\" eval(code) console.log(b) } var b = 2; foo('var b = 3;') 2.new Function代替eval function foo (code) { new Function(code) console.log(b) } var b = 2; foo('var b = 3;') 其他执行字符串的函数 setTimeout setInterval 这些功能已经过时，不要使用它们！！！ with with可以把一个对象处理为词法作用域 变量泄漏 在with中定义的变量，会泄漏到父级作用域中 function foo () { var obj = { name: 'hahaha' } with (obj) { console.log(name); var b = 11 } console.log(b) } foo() b会输出11。说明with中定义的变量泄漏到了foo作用域中 小结 eval和with会在运行修改或创建新的作用域 js引擎会在编译时根据代码的词法进行静态分析，预先确定变量和函数的定义位置，才能在执行过程中快速定位标识符 因为无法在词法分析阶段明确知道eval会接收到什么代码，这些代码会如何对作用域进行修改，也无法确定with用来创建词法作用域的对象的内容到底是什么，所以会导致js引擎无法做优化 如果代码中大量使用eval和with，会导致运行速度非常慢 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-06-29 19:08:52 "},"scope/funcScopeAndBlockScope.html":{"url":"scope/funcScopeAndBlockScope.html","title":"函数作用域和块作用域","keywords":"","body":"函数作用域 最小暴露原则 在软件设计中，应该最小限度地暴露必要内容，而将其他内容都隐藏起来 控制访问权限 规避冲突，如命名冲突 匿名函数 匿名函数地缺点： 在栈追踪中不会显示出有意义地函数名，使得调试困难 函数无法引用自身，只能通过arguments.callee 一个描述性地名称可以让代码不言自明，可读性变差 始终给函数表达式命名是一个最佳实践 IIFE 自执行函数 (function IIFE() {})() => 很多人更下面的形式👇 (function IIFE() {}()) IIFE解决undefined的问题 undefined有什么问题？ => undefined并不是一个关键字，可能会被覆盖，就像下面这样👇 undefined = true 解决方案： 使用void(0)作为undefined 使用IIFE (function IIFE(undefined){})() Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-06-29 15:20:16 "},"scope/raise.html":{"url":"scope/raise.html","title":"提升","keywords":"","body":"提升 函数声明会提升，函数表达式不会提升 foo() // 这里会报typeError，因为foo提升是undefined，并不是个函数 var foo = function () { // ... } 换个具名来看看 foo(); // TypeError bar(); // ReferenceError var foo = function bar() { // ... }; foo，bar都会报错，是因为这段代码提升之后变成了下面这样👇： var foo; foo(); // TypeError bar(); // ReferenceError foo = function() { var bar = ...self... // ... } 函数优先 意指：函数首先被提升，然后才是变量=> 重复声明会被忽略 foo(); // 1 var foo; function foo() { console.log( 1 ); } foo = function() { console.log( 2 ); }; => 重复的函数声明会被覆盖 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-06-29 15:28:24 "},"scope/closure.html":{"url":"scope/closure.html","title":"闭包","keywords":"","body":"闭包 函数嵌套，js引擎变量查找的规则引起的一种现象 函数能记住并访问所在的词法作用域 即使函数是在当前词法作用域之外执行 现象 内部函数可以访问外部作用域的变量 外部作用域的变量会一直存在内存中 应用 函数柯理化 块级作用域变量泄漏 function foo (context) { return function (...args) { return Array.prototype.push.apply(context, args) } } for (var i = 0; i { console.log(i) }, i * 1000) })(i) } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-06-29 17:08:33 "},"scope/this.html":{"url":"scope/this.html","title":"this","keywords":"","body":"this this是在运行时进行绑定的，取决于函数的调用方式 箭头函数 => 用一个例子来说明下除了书写方便之外，之前的function声明有何问题？ var obj = { name: 'leo', call: function () { console.log(this.name) } } let name = 'global' obj.call() setTimeout(obj.call, 0) leo global setTimeout那里的obj.call丢失了同this之间的绑定 词法作用域作为this 把上面的demo，function修改成箭头函数 =>，发现this都变成了global 箭头函数是把当前的词法作用域作为this 绑定规则 默认绑定 独立函数调用，最常用的函数调用类型如果函数是严格模式下，那么默认绑定不会绑到全局对象 function foo () { \"use strict\"; console.log(this.name) } var a = 2; foo(); // TypeError: this is undefined 隐式绑定 场景 函数调用时：用obj上下文来引用函数 obj.foo() 隐式丢失 var baz = obj.foo; haz(); 显式绑定 call，apply，bind 这些函数如果传入的是null，那么还是按照默认规则执行 new绑定 自定义bind function foo () { console.log(this.name) } var name = 'i am global' var obj = { name: 'i am foo' } Function.prototype._bind = function (context) { let fn = this return function (...args) { fn.apply(context, args) } } foo._bind(obj)() if (!Function.prototype.bind) { Function.prototype.bind = function(oThis) { if (typeof this !== \"function\") { // 与 ECMAScript 5 最接近的 // 内部 IsCallable 函数 throw new TypeError( \"Function.prototype.bind - what is trying \" + \"to be bound is not callable\" bar(3) 并没有像我们预计的那样把 obj1.a this全面解析 | 93 ); } var aArgs = Array.prototype.slice.call( arguments, 1 ), fToBind = this, fNOP = function(){}, fBound = function(){ return fToBind.apply( ( this instanceof fNOP && oThis ? this : oThis ), aArgs.concat( Array.prototype.slice.call( arguments ) ); } ; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; }; } DMZ对象 DMZ：非军事区 var ø = Object.create(null) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-06-29 20:18:24 "},"api/":{"url":"api/","title":"内置标准对象","keywords":"","body":"本章介绍和说明了 JavaScript 中所有的标准的内置对象、以及它们的方法和属性。 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-06-30 15:45:53 "},"api/object.html":{"url":"api/object.html","title":"Object","keywords":"","body":"Object { [ nameValuePair1[, nameValuePair2[, ...nameValuePairN] ] ] } new Object({ name: 'leo', age: 19 }) new Object([value]) 普通类型： new Object(1) new Object('1') new Object(true) null和undefined： new Object(null) new Object(undefined) 传入是构造函数： new Object(function () {}) new Object(Object) new Object(Symbol) 小结 这么看下来，Object略显累赘，远不如对象字面量来的方便 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-01 11:29:40 "},"api/object/assign.html":{"url":"api/object/assign.html","title":"assign","keywords":"","body":"assign Object.assign(target, ...sources) target：目标对象，sources：源对象，返回值：目标对象 说明target会被改变 assign方法只会拷贝源对象自身的并且可枚举的属性到目标对象 Polyfill MDN官方Polyfill if (typeof Object.assign !== 'function') { Object.defineProperty(Object, 'assign', { value: function assign(target, varArgs) { 'use strict'; if (target === null || target === undefined) { throw new Error('Cannot convert undefined or null to object'); } var to = Object(target); for (var index = 1; index 自定义Polyfill if (typeof Object.assign !== 'function') { Object.defineProperty(Object, 'assign', { value: (target, ...sources) => { if (target === null || target === undefined) { throw new Error('Cannot convert null or undefined to object'); } const to = Object(target) if (sources && sources.length) { for (let source of sources) { for (let key in source) { if (Object.prototype.hasOwnProperty(source, key)) { to[key] = source[key] } } } } return to }, writable: true, configurable: true }) } 深拷贝问题 assign复杂对象，复制的是引用值 let obj = { a: 0, b: { c: 0 } } let obj1 = Object.assign(obj) obj.b.c = 1; console.log(obj1.b.c) 这里的obj和obj1共享{ c: 0 } 注意点 继承属性和不可枚举属性不能拷贝 原始类型会被包装为对象 2.1 只有字符串的对象，才可能有自身可枚举属性 拷贝访问器 //TODO 先看下reduce Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-01 14:06:57 "},"api/object/create.html":{"url":"api/object/create.html","title":"create","keywords":"","body":"create Object.create(proto[, propertiesObject]) Object.create方法创建一个新对象，使用现在的对象来提供新创建的对象的ptoto propertiesObject let obj = { name: 'xuqiang' } let obj1 = Object.create(obj, { age: { writable: false, configurable: false, enumerable: false, value: 29 } }) Polyfill if (typeof Object._create !== 'function') { Object.defineProperty(Object, '_create', { value: (proto, propertiesObject) => { if (typeof proto !== 'object' && typeof proto !== 'function') { throw new Error('Object prototype may only be an Object or null:' + proto) } defineProperties(proto, propertiesObject) function F () {} F.prototype = proto return new F() } }) } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-01 14:57:41 "},"api/object/defineProperties.html":{"url":"api/object/defineProperties.html","title":"defineProperties","keywords":"","body":"defineProperties Object.defineProperties(obj, props) Object.definePrpperties(obj, { name: { value: 'leo', writable: true, configurable: true, enumerable: true, get () {}, set () {} } }) Polyfill function defineProperties(obj, properties) { function convertToDescriptor (desc) { const hasProperty = (obj, prop) => Object.prototype.hasOwnProperty(obj, prop); const isCallable = v => typeof v === 'function'; if (typeof desc !== 'object' || desc === null) { throw new TypeError('bad desc'); } const d = {} hasProperty(desc, 'configurable') && (d.configurable = !!desc.configurable) hasProperty(desc, 'enumerable') && (d.enumerable = !!desc.enumerable) hasProperty(desc, 'writable') && (d.writable = !!desc.writable) hasProperty(desc, 'value') && (d.value = !!desc.value) if (hasProperty(desc, 'get')) { const g = desc.get if (!isCallable(g) && typeof g !== 'undefined') { throw new TypeError('bad get'); } d.get = g } if (hasProperty(desc, 'set')) { const s = desc.set if (!isCallable(s) && typeof s !== 'undefined') { throw new TypeError('bad set'); } d.set = s } if (('get' in d || 'set' in d) && ('value' in d || 'writable' in d)) { throw new TypeError('identity-confused descriptor'); } return d; } if (typeof obj !== 'object' || obj === null) { throw new TypeError('bad obj') } const keys = Object.keys(properties) for (let key of keys) { const desc = convertToDescriptor(properties[key]) Object.defineProperty(obj, key, desc) } return obj } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-01 15:24:23 "},"api/object/defineProperty.html":{"url":"api/object/defineProperty.html","title":"defineProperty","keywords":"","body":"defineProperty Object.defineProperty(obj, prop, descriptor) 可枚举属性会被枚举到：for...in 或 Object.keys 属性描述符有两种主要形式，可为其一，不能同时是两者： 数据描述符：具有值的属性 存取描述符：由getter函数和setter函数所描述的属性 描述符： configurable：表示是否可删除 enumerable：for...in，Object.keys是否可被枚举 writable：是否可写，不能与存取描述符共存 value：值或函数，不能与存取描述符共存 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-01 16:05:16 "},"api/object/entries.html":{"url":"api/object/entries.html","title":"entries","keywords":"","body":"entries Object.entries(obj) Polyfill if (typeof Object.entries !== 'function') { Object.defineProperty(Object, 'entries', { value: obj => { const keys = Object.keys(obj) let resArray = new Array(i) for (let key of keys) { resArray.push([key, obj[key]]) } return resArray } }) } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-01 16:14:15 "},"api/object/fromEntries.html":{"url":"api/object/fromEntries.html","title":"fromEntries","keywords":"","body":"fromEntries Object.fromEntries(iterable) Object.fromEntries可以把map转为object 把键值对列表转换为一个对象 const entries = new Map([ ['foo', 'bar'], ['baz', 42] ]) Object.fromEntries(entries) entries entries出来的是个二维数组 let obj = { name: 'leo', age: 29 } Object.entries(obj) => [ ['name', 'xq'], ['age', 29] ] 二维数组可以转换为Map👇： new Map([ ['name', 'xq'], ['age', 29] ]) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 17:46:42 "},"api/object/getOwnPropertyDescriptor.html":{"url":"api/object/getOwnPropertyDescriptor.html","title":"getOwnPropertyDescriptor","keywords":"","body":"getOwnPropertyDescriptor Object.getOwnPropertyDescriptor(obj, prop) getOwnPropertyDescriptor可以获取属性描述符👇： let obj = { name: 'leo' } Object.getOwnPropertyDescriptor(obj, 'name') => { value: 'leo', enumerable: true, writable: true, configurable: true } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 17:53:11 "},"api/object/getOwnPropertyDescriptors.html":{"url":"api/object/getOwnPropertyDescriptors.html","title":"getOwnPropertyDescriptors","keywords":"","body":"getOwnPropertyDescriptors Object.getOwnPropertyDescriptors(obj) var obj = { name: 'leo' } Object.getOwnPropertyDescriptors(obj) => { name: { value: 'leo', enumerable: true, writable: true, configurable: true } } getOwnPropertyDescriptors和create结合 Object.create({ name: 'leo' }, Object.getOwnPropertyDescriptors({ name: 'leo1', age: 29 })) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 18:54:47 "},"api/object/getOwnPropertyNames.html":{"url":"api/object/getOwnPropertyNames.html","title":"getOwnPropertyNames","keywords":"","body":"getOwnPropertyNames Object.getOwnPropertyNames(obj) 这个方法会把可枚举和不可枚举的属性全部都查询出来相比keys，keys只能查询可枚举的，for...in亦是遍历可枚举属性 获取不可枚举属性 function getUnEnumerProps (obj) { const allKeys = Object.getOwnPropertyNames(obj) const keys = Object.keys(obj) const ret = [] for (let key of allKeys) { if (~keys.indexOf(key)) { ret.push(key) } } return ret } Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 19:01:35 "},"api/object/getOwnPropertySymbols.html":{"url":"api/object/getOwnPropertySymbols.html","title":"getOwnPropertySymbols","keywords":"","body":"getOwnPropertySymbols Object.getOwnPropertySymbols(obj) getOwnPropertyNames不能获取Symbol属性，只包含字符串属性 获取数组的iterator和unscopables属性 Object.getOwnPropertySymbols(Array.prototype) => [Symbol(Symbol.iterator), Symbol(Symbol.unscopables)] Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 19:11:21 "},"api/object/getPrototypeOf.html":{"url":"api/object/getPrototypeOf.html","title":"getPrototypeOf","keywords":"","body":"getPrototypeOf Object.getPrototypeOf(object) 获取隐藏属性proto Object的prototype Object.getPrototypeOf(Object) => f () { [native code] } Object的prototype是一个函数，Function的实例 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 19:19:26 "},"api/object/keys.html":{"url":"api/object/keys.html","title":"keys","keywords":"","body":"keys Object.keys(obj) 获取的属性会按照属性名的排列顺序，只能获取可枚举属性 Polyfill var obj = {} Object.defineProperties(obj, { name: { value: 'leo', enumerable: true }, age: { value: 29, enumerable: false }, wife: { value: 'xixi', enumerable: true } }) if (!Object._keys) { Object._keys = obj => { let ret = [] for (let prop in obj) { console.log('prop:', prop) ret.push(prop) } return ret } } console.log(Object._keys(obj)) 输出👇： ['wife', 'name'] polyfill正常，再来试试其它方式的polyfill getOwnPropertyNames和getOwnPropertyDescriptor var obj = {} Object.defineProperties(obj, { name: { value: 'leo', enumerable: true }, age: { value: 29, enumerable: false }, wife: { value: 'xixi', enumerable: true } }) if (!Object._keys) { Object._keys = obj => { let ret = [] const keys = Object.getOwnPropertyNames(obj) for (let key of keys) { const descriptor = Object.getOwnPropertyDescriptor(obj, key) if (descriptor.ennumerable) { ret.push(key) } } return ret } } var keys = Object._keys(obj) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 19:55:10 "},"api/object/unusually.html":{"url":"api/object/unusually.html","title":"不常用的方法","keywords":"","body":"不常用的方法 setPrototypeOf 为目标对象设置原型 Object.setPrototypeOf(obj, prototype) values Object.values(obj) 获取值数组 freeze Object.freeze(obj) 一个被冻结的对象，再也不能被修改👇： var obj = { name: 'leo' }; Object.freeze(obj); obj.name = '123'; console.log(obj) // 输出还是leo，不抛错，可是没更改 isFrozen Object.isFrozen(obj) 判断一个对象是否被冻结 var obj = { name: 'leo' }; Object.freeze(obj); Object.isFrozen(obj) seal 封闭对象 Object.seal(obj) 阻止添加新属性，原有属性是可写的仍可改变 isSealed 判断一个对象是否是密封的 判断一个对象是否可扩展 isExtensible Object.isExtensible(obj) seal和freeze的对象都是不可扩展的 阻止扩展 preventExtensions Object.preventExtensions(obj) 永远不能添加新的属性 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 20:21:44 "},"api/object/constructor.html":{"url":"api/object/constructor.html","title":"Object构造函数","keywords":"","body":"关于Object构造函数 f Object () { [native Code] } Object.prototype { constructor, hasOwnProperty, isPrototypeOf, propertyIsEnumerable, toLocalString, toString, valueOf } Object.prototype.proto null Object.getPrototype与prototype 为何 Object.getPrototype(Object) 和 Object.prototype的结果不同呢？ Object.getPrototype获取的是Object的proto属性 Object.prototype获取的是Object的prototype 说明Object的proto跟prototype是不同的 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 20:33:50 "},"api/array.html":{"url":"api/array.html","title":"数组","keywords":"","body":"数组 Array new Array(element0, element1, ...elementN) | new Array(arrayLength) 静态方法 Array.from Array.from(arrayLike[, mapFn[, thisArg]]) var obj = { x: 3 }; var ret = Array.from([1, 2, 3], function (item) { return item * this.x; }, obj); console.log(ret) Array.length 操作length会直接改变数组，比如length = 0; 就把数组给置空了 Array.isArray Array.isArray(obj) 判断是否是个数组 Array.prototype[@@unscopables] 属性名为Symbol.unscopables[][Symbol.unscopables]可以看到Array unscopables的属性👇： { copyWithin: true, entries: true, fill: true, find: true, findIndex: true, flat: true, flatMap: true, includes: true, keys: true, values: true } unscopables的作用 防止某些数组方法被添加到with语句的作用域中 let keys = [] with (Array.prototype) { keys.push('something') } 在es6中keys是function，push会报错，而unscopables正是为了解决这个问题 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-06-30 16:40:01 "},"api/array/forEach.html":{"url":"api/array/forEach.html","title":"forEach","keywords":"","body":"Array forEach arr.forEach(callback(currentValue, index, array), thisArg) 普通使用 [1, 2, 3].forEach(function (item, index, array) { console.log(this, item, index, array) }) 当没有显式声明thisArg时，this指向window 可以显示声明回调的上下文👇： var obj = {name: 'leo'}; [1, 2, 3].forEach(function (item, index, array) { console.log(this, item, index, array) }, obj) 可以发现上下文this变成了obj，可是如果是箭头函数会怎么样呢？ var obj = {name: 'leo'}; [1, 2, 3].forEach((item, index, array) => { console.log(this, item, index, array) }, obj) 发现this又变成了window，箭头函数把当前的词法作用域作为this，优先级比forEach的thisArg高 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-06-30 15:35:37 "},"api/Function.html":{"url":"api/Function.html","title":"Function","keywords":"","body":"Function 每个javascript函数实际上都是一个Function对象，下面代码可以证明👇： (function () {}).constructor === Function 所以诸如Object，Array，Date等获取其proto，都是函数实例： Object.getPrototypeOf(Object) => f () { [native code] } Object，Array等都是继承自Function Polyfill function F () { function O () { } O.prototype = Object.prototype return O; } var O = new F() console.log(O) console.log(O.constructor) console.log(O.__proto__) console.log(O.prototype) console.log(Object.prototype) console.log(O.prototype === Object.prototype) Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-03 15:21:57 "},"async/":{"url":"async/","title":"异步和性能","keywords":"","body":"异步 通常代码中的异步操作，比如ajax请求等，并不会阻塞引擎，而使用回调函数 分块的程序 js程序写在单个.js文件中，但是这个程序几乎一定是由多个快构成的。这些块中只有一个是现在执行，其余的则会在将来执行最常见的块是函数 并行线程 并行最常见的工具：线程和进程进程和线程独立运行，多个线程共享单个进程的内存 事件循环 这是一段仿时间循环的伪代码 let eventLoop = []; let event; while (true) { if (eventLoop.length > 0) { event = eventLoop.shift(); try { event() } catch (err) { reportError(err) } } } 回调 嵌套回调 -> 回调地狱嵌套回调会导致流程追踪链路变得很复杂 【控制反转】造成的【信任危机】 比如控制反转的情况下，调用别人的api，传入回调函数，回调函数可能被调用很多次 回调的信任危机： 回调的过早 回调的过晚，甚至没有回调 调用回调次数过少或过多 回调参数有问题 吞掉可能出现的错误或异常 Promise Promise如何解决信任问题： Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 16:03:47 "},"interview/":{"url":"interview/","title":"整理知识点","keywords":"","body":"知识点 这里是整理的各种js面试题知识点 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 16:06:55 "},"interview/1.html":{"url":"interview/1.html","title":"数据类型","keywords":"","body":"数据类型 js一共有7种数据类型：string，number，boolean，undefined，null，object，symbol 为什么用void 0 代替undefined 因为在js中undefined并非是关键字，这说明undefined是可以被覆盖的，比如👇 var undefined = 1 说明IE8下的undefined被覆盖了，此时undefined已经失去了本来意义，所以使用void 0更加准确 symbol Symbol是es6才加入的新类型 因为es6出现之初是号称不会影响原本代码的，比如它的iterator迭代器等，如果强行在对象下面定义iterator属性，可能会影响很多老代码中iterator导致出问题，所以引入symbol，使用Symbol.iterator来保证它的唯一性 typeof Symbol === 'function' typeof Symbol.iterator === 'symbol' null null转化为布尔类型是false，typeof null是\"object\" undefined和null的区别 undefined表示已声明未定义，null表示空对象 null是关键字，undefined不是 typeof undefined是undefined，typeof null是object Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 17:26:03 "},"interview/2.html":{"url":"interview/2.html","title":"内存空间分为哪几种数据结构","keywords":"","body":"内存空间分为哪几种数据结构 栈数据结构 栈是特殊的列表，栈内的元素自能通过栈的一端访问，这一端成为栈顶。特点： 先进后出，后进先出 基本数据类型：string，number，boolean，undefined，null，symbol 占据空间小，大小固定，频繁被使用 由编译器自动分配释放 堆数据结构 除了基本数据类型的其他类型，如Array, Function, Object等 特点： 占据空间大，大小不固定 通过使用在栈中保存对应的指针来获取堆中的值 一个优先队列，按优先级排序 由程序员分配释放，程序结束时可能由垃圾回收机制回收 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 16:59:48 "},"interview/3.html":{"url":"interview/3.html","title":"大文件上传和断点续传","keywords":"","body":"Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 16:51:43 "},"interview/4.html":{"url":"interview/4.html","title":"内部属性[[class]]","keywords":"","body":"内部属性[[class]] typeof为object的对象，都包含一个内部属性[[class]] 此属性无法直接访问，可以通过Object.prototype.toString查看 可以看作是内部的一个分类，而且面向对象意义上的类 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 17:23:53 "},"interview/5.html":{"url":"interview/5.html","title":"继承和原型","keywords":"","body":"继承和原型 Copyright © qiangxu@clubfactory.com 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-07-02 17:32:15 "}}